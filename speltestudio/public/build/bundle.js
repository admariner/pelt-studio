
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function compute_slots(slots) {
        const result = {};
        for (const key in slots) {
            result[key] = true;
        }
        return result;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.2' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    function filterList(list, value, missingIsFalse) {
      if (list === "*") {
        return true;
      }
      return list.length > 0 ? list.indexOf(value) !== -1 : !missingIsFalse;
    }
    function extend(o1, o2, keys) {
      var i;
      o1 = o1 || {};
      o2 = o2 || {};
      var _o1 = o1,
          _o2 = o2;
      if (keys) {
        for (i = 0; i < keys.length; i++) {
          _o1[keys[i]] = _o2[keys[i]];
        }
      } else {
        for (i in _o2) {
          _o1[i] = _o2[i];
        }
      }
      return o1;
    }
    function isNumber(n) {
      return Object.prototype.toString.call(n) === "[object Number]";
    }
    function isString(s) {
      return typeof s === "string";
    }
    function isBoolean(s) {
      return typeof s === "boolean";
    }
    function isObject(o) {
      return o == null ? false : Object.prototype.toString.call(o) === "[object Object]";
    }
    function isDate(o) {
      return Object.prototype.toString.call(o) === "[object Date]";
    }
    function isFunction(o) {
      return Object.prototype.toString.call(o) === "[object Function]";
    }
    function clone(a) {
      if (isString(a)) {
        return "" + a;
      } else if (isBoolean(a)) {
        return !!a;
      } else if (isDate(a)) {
        return new Date(a.getTime());
      } else if (isFunction(a)) {
        return a;
      } else if (Array.isArray(a)) {
        var _b = [];
        for (var i = 0; i < a.length; i++) {
          _b.push(clone(a[i]));
        }
        return _b;
      } else if (isObject(a)) {
        var c = {};
        for (var j in a) {
          c[j] = clone(a[j]);
        }
        return c;
      } else {
        return a;
      }
    }
    function merge(a, b, collations, overwrites) {
      var cMap = {},
          ar,
          i,
          oMap = {};
      collations = collations || [];
      overwrites = overwrites || [];
      for (i = 0; i < collations.length; i++) {
        cMap[collations[i]] = true;
      }
      for (i = 0; i < overwrites.length; i++) {
        oMap[overwrites[i]] = true;
      }
      var c = clone(a);
      for (i in b) {
        if (c[i] == null || oMap[i]) {
          c[i] = b[i];
        } else if (cMap[i]) {
          ar = [];
          ar.push.apply(ar, Array.isArray(c[i]) ? c[i] : [c[i]]);
          ar.push(b[i]);
          c[i] = ar;
        } else if (isString(b[i]) || isBoolean(b[i]) || isFunction(b[i]) || isNumber(b[i])) {
          c[i] = b[i];
        } else {
          if (Array.isArray(b[i])) {
            ar = [];
            if (Array.isArray(c[i])) {
              ar.push.apply(ar, c[i]);
            }
            ar.push.apply(ar, b[i]);
            c[i] = ar;
          } else if (isObject(b[i])) {
            if (!isObject(c[i])) {
              c[i] = {};
            }
            for (var j in b[i]) {
              c[i][j] = b[i][j];
            }
          }
        }
      }
      return c;
    }
    function functionChain(successValue, failValue, fns) {
      for (var i = 0; i < fns.length; i++) {
        var o = fns[i][0][fns[i][1]].apply(fns[i][0], fns[i][2]);
        if (o === failValue) {
          return o;
        }
      }
      return successValue;
    }
    function populate(model, values, functionPrefix, doNotExpandFunctions) {
      var getValue = function getValue(fromString) {
        var matches = fromString.match(/(\${.*?})/g);
        if (matches != null) {
          for (var i = 0; i < matches.length; i++) {
            var val = values[matches[i].substring(2, matches[i].length - 1)] || "";
            if (val != null) {
              fromString = fromString.replace(matches[i], val);
            }
          }
        }
        return fromString;
      };
      var _one = function _one(d) {
        if (d != null) {
          if (isString(d)) {
            return getValue(d);
          } else if (isFunction(d) && !doNotExpandFunctions && (functionPrefix == null || (d.name || "").indexOf(functionPrefix) === 0)) {
            return d(values);
          } else if (Array.isArray(d)) {
            var r = [];
            for (var i = 0; i < d.length; i++) {
              r.push(_one(d[i]));
            }
            return r;
          } else if (isObject(d)) {
            var s = {};
            for (var j in d) {
              s[j] = _one(d[j]);
            }
            return s;
          } else {
            return d;
          }
        }
      };
      return _one(model);
    }
    function forEach(a, f) {
      if (a) {
        for (var i = 0; i < a.length; i++) {
          f(a[i]);
        }
      } else {
        return null;
      }
    }
    function findWithFunction(a, f) {
      if (a) {
        for (var i = 0; i < a.length; i++) {
          if (f(a[i])) {
            return i;
          }
        }
      }
      return -1;
    }
    function findAllWithFunction(a, predicate) {
      var o = [];
      if (a) {
        for (var i = 0; i < a.length; i++) {
          if (predicate(a[i])) {
            o.push(i);
          }
        }
      }
      return o;
    }
    function getWithFunction(a, f) {
      var idx = findWithFunction(a, f);
      return idx === -1 ? null : a[idx];
    }
    function getAllWithFunction(a, f) {
      var indexes = findAllWithFunction(a, f);
      return indexes.map(function (i) {
        return a[i];
      });
    }
    function getFromSetWithFunction(s, f) {
      var out = null;
      s.forEach(function (t) {
        if (f(t)) {
          out = t;
        }
      });
      return out;
    }
    function setToArray(s) {
      var a = [];
      s.forEach(function (t) {
        a.push(t);
      });
      return a;
    }
    function removeWithFunction(a, f) {
      var idx = findWithFunction(a, f);
      if (idx > -1) {
        a.splice(idx, 1);
      }
      return idx !== -1;
    }
    function fromArray(a) {
      if (Array.fromArray != null) {
        return Array.from(a);
      } else {
        var arr = [];
        Array.prototype.push.apply(arr, a);
        return arr;
      }
    }
    function remove(l, v) {
      var idx = l.indexOf(v);
      if (idx > -1) {
        l.splice(idx, 1);
      }
      return idx !== -1;
    }
    function addToDictionary(map, key, value, insertAtStart) {
      var l = map[key];
      if (l == null) {
        l = [];
        map[key] = l;
      }
      l[insertAtStart ? "unshift" : "push"](value);
      return l;
    }
    function suggest(list, item, insertAtHead) {
      if (list.indexOf(item) === -1) {
        if (insertAtHead) {
          list.unshift(item);
        } else {
          list.push(item);
        }
        return true;
      }
      return false;
    }
    var lut = [];
    for (var i = 0; i < 256; i++) {
      lut[i] = (i < 16 ? '0' : '') + i.toString(16);
    }
    function uuid() {
      var d0 = Math.random() * 0xffffffff | 0;
      var d1 = Math.random() * 0xffffffff | 0;
      var d2 = Math.random() * 0xffffffff | 0;
      var d3 = Math.random() * 0xffffffff | 0;
      return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
    }
    function rotatePoint(point, center, rotation) {
      var radial = {
        x: point.x - center.x,
        y: point.y - center.y
      },
          cr = Math.cos(rotation / 360 * Math.PI * 2),
          sr = Math.sin(rotation / 360 * Math.PI * 2);
      return {
        x: radial.x * cr - radial.y * sr + center.x,
        y: radial.y * cr + radial.x * sr + center.y,
        cr: cr,
        sr: sr
      };
    }
    function fastTrim(s) {
      if (s == null) {
        return null;
      }
      var str = s.replace(/^\s\s*/, ''),
          ws = /\s/,
          i = str.length;
      while (ws.test(str.charAt(--i))) {}
      return str.slice(0, i + 1);
    }
    function each(obj, fn) {
      obj = obj.length == null || typeof obj === "string" ? [obj] : obj;
      for (var _i = 0; _i < obj.length; _i++) {
        fn(obj[_i]);
      }
    }
    function map(obj, fn) {
      var o = [];
      for (var _i2 = 0; _i2 < obj.length; _i2++) {
        o.push(fn(obj[_i2]));
      }
      return o;
    }
    function log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (typeof console !== "undefined") {
        try {
          var msg = arguments[arguments.length - 1];
          console.log(msg);
        } catch (e) {}
      }
    }
    function wrap(wrappedFunction, newFunction, returnOnThisValue) {
      return function () {
        var r = null;
        try {
          if (newFunction != null) {
            r = newFunction.apply(this, arguments);
          }
        } catch (e) {
          log("jsPlumb function failed : " + e);
        }
        if (wrappedFunction != null && (returnOnThisValue == null || r !== returnOnThisValue)) {
          try {
            r = wrappedFunction.apply(this, arguments);
          } catch (e) {
            log("wrapped function failed : " + e);
          }
        }
        return r;
      };
    }
    function getsert(map, key, valueGenerator) {
      if (!map.has(key)) {
        map.set(key, valueGenerator());
      }
      return map.get(key);
    }
    function isAssignableFrom(object, cls) {
      var proto = object.__proto__;
      while (proto != null) {
        if (proto instanceof cls) {
          return true;
        } else {
          proto = proto.__proto__;
        }
      }
      return false;
    }
    function insertSorted(value, array, comparator, sortDescending) {
      if (array.length === 0) {
        array.push(value);
      } else {
        var flip = sortDescending ? -1 : 1;
        var min = 0;
        var max = array.length;
        var index = Math.floor((min + max) / 2);
        while (max > min) {
          var c = comparator(value, array[index]) * flip;
          if (c < 0) {
            max = index;
          } else {
            min = index + 1;
          }
          index = Math.floor((min + max) / 2);
        }
        array.splice(index, 0, value);
      }
    }

    function _classCallCheck$3(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$3(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$3(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$3(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty$3(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _inherits$2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$2(subClass, superClass);
    }

    function _getPrototypeOf$2(o) {
      _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$2(o);
    }

    function _setPrototypeOf$2(o, p) {
      _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$2(o, p);
    }

    function _isNativeReflectConstruct$2() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _assertThisInitialized$2(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$2(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$2(self);
    }

    function _createSuper$2(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$2();

      return function _createSuperInternal() {
        var Super = _getPrototypeOf$2(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$2(this).constructor;

          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return _possibleConstructorReturn$2(this, result);
      };
    }

    var EventGenerator = function () {
      function EventGenerator() {
        _classCallCheck$3(this, EventGenerator);
        _defineProperty$3(this, "_listeners", {});
        _defineProperty$3(this, "eventsSuspended", false);
        _defineProperty$3(this, "tick", false);
        _defineProperty$3(this, "eventsToDieOn", {
          "ready": true
        });
        _defineProperty$3(this, "queue", []);
      }
      _createClass$3(EventGenerator, [{
        key: "fire",
        value: function fire(event, value, originalEvent) {
          var ret = null;
          if (!this.tick) {
            this.tick = true;
            if (!this.eventsSuspended && this._listeners[event]) {
              var l = this._listeners[event].length,
                  i = 0,
                  _gone = false;
              if (!this.shouldFireEvent || this.shouldFireEvent(event, value, originalEvent)) {
                while (!_gone && i < l && ret !== false) {
                  if (this.eventsToDieOn[event]) {
                    this._listeners[event][i].apply(this, [value, originalEvent]);
                  } else {
                    try {
                      ret = this._listeners[event][i].apply(this, [value, originalEvent]);
                    } catch (e) {
                      log("jsPlumb: fire failed for event " + event + " : " + (e.message || e));
                    }
                  }
                  i++;
                  if (this._listeners == null || this._listeners[event] == null) {
                    _gone = true;
                  }
                }
              }
            }
            this.tick = false;
            this._drain();
          } else {
            this.queue.unshift(arguments);
          }
          return ret;
        }
      }, {
        key: "_drain",
        value: function _drain() {
          var n = this.queue.pop();
          if (n) {
            this.fire.apply(this, n);
          }
        }
      }, {
        key: "unbind",
        value: function unbind(eventOrListener, listener) {
          if (arguments.length === 0) {
            this._listeners = {};
          } else if (arguments.length === 1) {
            if (typeof eventOrListener === "string") {
              delete this._listeners[eventOrListener];
            } else if (eventOrListener.__jsPlumb) {
              var evt;
              for (var i in eventOrListener.__jsPlumb) {
                evt = eventOrListener.__jsPlumb[i];
                remove(this._listeners[evt] || [], eventOrListener);
              }
            }
          } else if (arguments.length === 2) {
            remove(this._listeners[eventOrListener] || [], listener);
          }
          return this;
        }
      }, {
        key: "getListener",
        value: function getListener(forEvent) {
          return this._listeners[forEvent] || [];
        }
      }, {
        key: "isSuspendEvents",
        value: function isSuspendEvents() {
          return this.eventsSuspended;
        }
      }, {
        key: "setSuspendEvents",
        value: function setSuspendEvents(val) {
          this.eventsSuspended = val;
        }
      }, {
        key: "bind",
        value: function bind(event, listener, insertAtStart) {
          var _this = this;
          var _one = function _one(evt) {
            addToDictionary(_this._listeners, evt, listener, insertAtStart);
            listener.__jsPlumb = listener.__jsPlumb || {};
            listener.__jsPlumb[uuid()] = evt;
          };
          if (typeof event === "string") {
            _one(event);
          } else if (event.length != null) {
            for (var i = 0; i < event.length; i++) {
              _one(event[i]);
            }
          }
          return this;
        }
      }, {
        key: "silently",
        value: function silently(fn) {
          this.setSuspendEvents(true);
          try {
            fn();
          } catch (e) {
            log("Cannot execute silent function " + e);
          }
          this.setSuspendEvents(false);
        }
      }]);
      return EventGenerator;
    }();
    (function (_EventGenerator) {
      _inherits$2(OptimisticEventGenerator, _EventGenerator);
      var _super = _createSuper$2(OptimisticEventGenerator);
      function OptimisticEventGenerator() {
        _classCallCheck$3(this, OptimisticEventGenerator);
        return _super.apply(this, arguments);
      }
      _createClass$3(OptimisticEventGenerator, [{
        key: "shouldFireEvent",
        value: function shouldFireEvent(event, value, originalEvent) {
          return true;
        }
      }]);
      return OptimisticEventGenerator;
    })(EventGenerator);

    var segmentMultipliers = [null, [1, -1], [1, 1], [-1, 1], [-1, -1]];
    var inverseSegmentMultipliers = [null, [-1, -1], [-1, 1], [1, 1], [1, -1]];
    var TWO_PI = 2 * Math.PI;
    function gradient(p1, p2) {
      if (p2.x === p1.x) return p2.y > p1.y ? Infinity : -Infinity;else if (p2.y === p1.y) return p2.x > p1.x ? 0 : -0;else return (p2.y - p1.y) / (p2.x - p1.x);
    }
    function normal(p1, p2) {
      return -1 / gradient(p1, p2);
    }
    function lineLength(p1, p2) {
      return Math.sqrt(Math.pow(p2.y - p1.y, 2) + Math.pow(p2.x - p1.x, 2));
    }
    function quadrant(p1, p2) {
      if (p2.x > p1.x) {
        return p2.y > p1.y ? 2 : 1;
      } else if (p2.x == p1.x) {
        return p2.y > p1.y ? 2 : 1;
      } else {
        return p2.y > p1.y ? 3 : 4;
      }
    }
    function theta(p1, p2) {
      var m = gradient(p1, p2),
          t = Math.atan(m),
          s = quadrant(p1, p2);
      if (s == 4 || s == 3) t += Math.PI;
      if (t < 0) t += 2 * Math.PI;
      return t;
    }
    function intersects(r1, r2) {
      var x1 = r1.x,
          x2 = r1.x + r1.w,
          y1 = r1.y,
          y2 = r1.y + r1.h,
          a1 = r2.x,
          a2 = r2.x + r2.w,
          b1 = r2.y,
          b2 = r2.y + r2.h;
      return x1 <= a1 && a1 <= x2 && y1 <= b1 && b1 <= y2 || x1 <= a2 && a2 <= x2 && y1 <= b1 && b1 <= y2 || x1 <= a1 && a1 <= x2 && y1 <= b2 && b2 <= y2 || x1 <= a2 && a1 <= x2 && y1 <= b2 && b2 <= y2 || a1 <= x1 && x1 <= a2 && b1 <= y1 && y1 <= b2 || a1 <= x2 && x2 <= a2 && b1 <= y1 && y1 <= b2 || a1 <= x1 && x1 <= a2 && b1 <= y2 && y2 <= b2 || a1 <= x2 && x1 <= a2 && b1 <= y2 && y2 <= b2;
    }
    function pointOnLine(fromPoint, toPoint, distance) {
      var m = gradient(fromPoint, toPoint),
          s = quadrant(fromPoint, toPoint),
          segmentMultiplier = distance > 0 ? segmentMultipliers[s] : inverseSegmentMultipliers[s],
          theta = Math.atan(m),
          y = Math.abs(distance * Math.sin(theta)) * segmentMultiplier[1],
          x = Math.abs(distance * Math.cos(theta)) * segmentMultiplier[0];
      return {
        x: fromPoint.x + x,
        y: fromPoint.y + y
      };
    }
    function perpendicularLineTo(fromPoint, toPoint, length) {
      var m = gradient(fromPoint, toPoint),
          theta2 = Math.atan(-1 / m),
          y = length / 2 * Math.sin(theta2),
          x = length / 2 * Math.cos(theta2);
      return [{
        x: toPoint.x + x,
        y: toPoint.y + y
      }, {
        x: toPoint.x - x,
        y: toPoint.y - y
      }];
    }
    function snapToGrid(pos, grid, thresholdX, thresholdY) {
      thresholdX = thresholdX == null ? grid.thresholdX == null ? grid.w / 2 : grid.thresholdX : thresholdX;
      thresholdY = thresholdY == null ? grid.thresholdY == null ? grid.h / 2 : grid.thresholdY : thresholdY;
      var _dx = Math.floor(pos.x / grid.w),
          _dxl = grid.w * _dx,
          _dxt = _dxl + grid.w,
          x = Math.abs(pos.x - _dxl) <= thresholdX ? _dxl : Math.abs(_dxt - pos.x) <= thresholdX ? _dxt : pos.x;
      var _dy = Math.floor(pos.y / grid.h),
          _dyl = grid.h * _dy,
          _dyt = _dyl + grid.h,
          y = Math.abs(pos.y - _dyl) <= thresholdY ? _dyl : Math.abs(_dyt - pos.y) <= thresholdY ? _dyt : pos.y;
      return {
        x: x,
        y: y
      };
    }

    var PerimeterAnchorShapes;
    (function (PerimeterAnchorShapes) {
      PerimeterAnchorShapes["Circle"] = "Circle";
      PerimeterAnchorShapes["Ellipse"] = "Ellipse";
      PerimeterAnchorShapes["Triangle"] = "Triangle";
      PerimeterAnchorShapes["Diamond"] = "Diamond";
      PerimeterAnchorShapes["Rectangle"] = "Rectangle";
      PerimeterAnchorShapes["Square"] = "Square";
    })(PerimeterAnchorShapes || (PerimeterAnchorShapes = {}));
    var AnchorLocations;
    (function (AnchorLocations) {
      AnchorLocations["Assign"] = "Assign";
      AnchorLocations["AutoDefault"] = "AutoDefault";
      AnchorLocations["Bottom"] = "Bottom";
      AnchorLocations["BottomLeft"] = "BottomLeft";
      AnchorLocations["BottomRight"] = "BottomRight";
      AnchorLocations["Center"] = "Center";
      AnchorLocations["Continuous"] = "Continuous";
      AnchorLocations["ContinuousBottom"] = "ContinuousBottom";
      AnchorLocations["ContinuousLeft"] = "ContinuousLeft";
      AnchorLocations["ContinuousRight"] = "ContinuousRight";
      AnchorLocations["ContinuousTop"] = "ContinuousTop";
      AnchorLocations["ContinuousLeftRight"] = "ContinuousLeftRight";
      AnchorLocations["ContinuousTopBottom"] = "ContinuousTopBottom";
      AnchorLocations["Left"] = "Left";
      AnchorLocations["Perimeter"] = "Perimeter";
      AnchorLocations["Right"] = "Right";
      AnchorLocations["Top"] = "Top";
      AnchorLocations["TopLeft"] = "TopLeft";
      AnchorLocations["TopRight"] = "TopRight";
    })(AnchorLocations || (AnchorLocations = {}));

    function _classCallCheck$2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$2(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$2(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$2(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty$2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function noSuchPoint() {
      return {
        d: Infinity,
        x: null,
        y: null,
        l: null,
        x1: null,
        y1: null,
        x2: null,
        y2: null
      };
    }
    function EMPTY_BOUNDS() {
      return {
        xmin: Infinity,
        xmax: -Infinity,
        ymin: Infinity,
        ymax: -Infinity
      };
    }
    var AbstractSegment = function () {
      function AbstractSegment(params) {
        _classCallCheck$2(this, AbstractSegment);
        this.params = params;
        _defineProperty$2(this, "x1", void 0);
        _defineProperty$2(this, "x2", void 0);
        _defineProperty$2(this, "y1", void 0);
        _defineProperty$2(this, "y2", void 0);
        _defineProperty$2(this, "extents", EMPTY_BOUNDS());
        _defineProperty$2(this, "type", void 0);
        this.x1 = params.x1;
        this.y1 = params.y1;
        this.x2 = params.x2;
        this.y2 = params.y2;
      }
      _createClass$2(AbstractSegment, [{
        key: "findClosestPointOnPath",
        value: function findClosestPointOnPath(x, y) {
          return noSuchPoint();
        }
      }, {
        key: "lineIntersection",
        value: function lineIntersection(x1, y1, x2, y2) {
          return [];
        }
      }, {
        key: "boxIntersection",
        value: function boxIntersection(x, y, w, h) {
          var a = [];
          a.push.apply(a, this.lineIntersection(x, y, x + w, y));
          a.push.apply(a, this.lineIntersection(x + w, y, x + w, y + h));
          a.push.apply(a, this.lineIntersection(x + w, y + h, x, y + h));
          a.push.apply(a, this.lineIntersection(x, y + h, x, y));
          return a;
        }
      }, {
        key: "boundingBoxIntersection",
        value: function boundingBoxIntersection(box) {
          return this.boxIntersection(box.x, box.y, box.w, box.h);
        }
      }]);
      return AbstractSegment;
    }();

    var UNDEFINED = "undefined";
    var DEFAULT = "default";
    var TRUE$1 = "true";
    var FALSE$1 = "false";
    var WILDCARD = "*";

    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$1(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$1(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$1(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty$1(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _inherits$1(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$1(subClass, superClass);
    }

    function _getPrototypeOf$1(o) {
      _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$1(o);
    }

    function _setPrototypeOf$1(o, p) {
      _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$1(o, p);
    }

    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _assertThisInitialized$1(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$1(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$1(self);
    }

    function _createSuper$1(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$1();

      return function _createSuperInternal() {
        var Super = _getPrototypeOf$1(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$1(this).constructor;

          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return _possibleConstructorReturn$1(this, result);
      };
    }

    function _superPropBase$1(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$1(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$1(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$1 = Reflect.get;
      } else {
        _get$1 = function _get(target, property, receiver) {
          var base = _superPropBase$1(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$1(target, property, receiver || target);
    }

    function _slicedToArray$1(arr, i) {
      return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1();
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
    }

    function _arrayWithHoles$1(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    function _iterableToArrayLimit$1(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;

      var _s, _e;

      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _unsupportedIterableToArray$1(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
    }

    function _arrayLikeToArray$1(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _nonIterableRest$1() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var endpointMap$1 = {};
    var endpointComputers = {};
    var handlers = {};
    var EndpointFactory = {
      get: function get(ep, name, params) {
        var e = endpointMap$1[name];
        if (!e) {
          throw {
            message: "jsPlumb: unknown endpoint type '" + name + "'"
          };
        } else {
          return new e(ep, params);
        }
      },
      clone: function clone(epr) {
        var handler = handlers[epr.type];
        return EndpointFactory.get(epr.endpoint, epr.type, handler.getParams(epr));
      },
      compute: function compute(endpoint, anchorPoint, orientation, endpointStyle) {
        var c = endpointComputers[endpoint.type];
        if (c != null) {
          return c(endpoint, anchorPoint, orientation, endpointStyle);
        } else {
          log("jsPlumb: cannot find endpoint calculator for endpoint of type ", endpoint.type);
        }
      },
      registerHandler: function registerHandler(eph) {
        handlers[eph.type] = eph;
        endpointMap$1[eph.type] = eph.cls;
        endpointComputers[eph.type] = eph.compute;
      }
    };

    var EndpointRepresentation = function () {
      function EndpointRepresentation(endpoint, params) {
        _classCallCheck$1(this, EndpointRepresentation);
        this.endpoint = endpoint;
        _defineProperty$1(this, "typeId", void 0);
        _defineProperty$1(this, "x", void 0);
        _defineProperty$1(this, "y", void 0);
        _defineProperty$1(this, "w", void 0);
        _defineProperty$1(this, "h", void 0);
        _defineProperty$1(this, "computedValue", void 0);
        _defineProperty$1(this, "bounds", EMPTY_BOUNDS());
        _defineProperty$1(this, "classes", []);
        _defineProperty$1(this, "instance", void 0);
        _defineProperty$1(this, "type", void 0);
        params = params || {};
        this.instance = endpoint.instance;
        if (endpoint.cssClass) {
          this.classes.push(endpoint.cssClass);
        }
        if (params.cssClass) {
          this.classes.push(params.cssClass);
        }
      }
      _createClass$1(EndpointRepresentation, [{
        key: "addClass",
        value: function addClass(c) {
          this.classes.push(c);
          this.instance.addEndpointClass(this.endpoint, c);
        }
      }, {
        key: "removeClass",
        value: function removeClass(c) {
          this.classes = this.classes.filter(function (_c) {
            return _c !== c;
          });
          this.instance.removeEndpointClass(this.endpoint, c);
        }
      }, {
        key: "compute",
        value: function compute(anchorPoint, orientation, endpointStyle) {
          this.computedValue = EndpointFactory.compute(this, anchorPoint, orientation, endpointStyle);
          this.bounds.xmin = this.x;
          this.bounds.ymin = this.y;
          this.bounds.xmax = this.x + this.w;
          this.bounds.ymax = this.y + this.h;
        }
      }, {
        key: "setVisible",
        value: function setVisible(v) {
          this.instance.setEndpointVisible(this.endpoint, v);
        }
      }]);
      return EndpointRepresentation;
    }();

    var DotEndpoint = function (_EndpointRepresentati) {
      _inherits$1(DotEndpoint, _EndpointRepresentati);
      var _super = _createSuper$1(DotEndpoint);
      function DotEndpoint(endpoint, params) {
        var _this;
        _classCallCheck$1(this, DotEndpoint);
        _this = _super.call(this, endpoint, params);
        _defineProperty$1(_assertThisInitialized$1(_this), "radius", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "defaultOffset", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "defaultInnerRadius", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "type", DotEndpoint.type);
        params = params || {};
        _this.radius = params.radius || 5;
        _this.defaultOffset = 0.5 * _this.radius;
        _this.defaultInnerRadius = _this.radius / 3;
        return _this;
      }
      return DotEndpoint;
    }(EndpointRepresentation);
    _defineProperty$1(DotEndpoint, "type", "Dot");
    var DotEndpointHandler = {
      type: DotEndpoint.type,
      cls: DotEndpoint,
      compute: function compute(ep, anchorPoint, orientation, endpointStyle) {
        var x = anchorPoint.curX - ep.radius,
            y = anchorPoint.curY - ep.radius,
            w = ep.radius * 2,
            h = ep.radius * 2;
        if (endpointStyle && endpointStyle.stroke) {
          var lw = endpointStyle.strokeWidth || 1;
          x -= lw;
          y -= lw;
          w += lw * 2;
          h += lw * 2;
        }
        ep.x = x;
        ep.y = y;
        ep.w = w;
        ep.h = h;
        return [x, y, w, h, ep.radius];
      },
      getParams: function getParams(ep) {
        return {
          radius: ep.radius
        };
      }
    };

    var BlankEndpoint = function (_EndpointRepresentati) {
      _inherits$1(BlankEndpoint, _EndpointRepresentati);
      var _super = _createSuper$1(BlankEndpoint);
      function BlankEndpoint(endpoint, params) {
        var _this;
        _classCallCheck$1(this, BlankEndpoint);
        _this = _super.call(this, endpoint, params);
        _defineProperty$1(_assertThisInitialized$1(_this), "type", BlankEndpoint.type);
        return _this;
      }
      return BlankEndpoint;
    }(EndpointRepresentation);
    _defineProperty$1(BlankEndpoint, "type", "Blank");
    var BlankEndpointHandler = {
      type: BlankEndpoint.type,
      cls: BlankEndpoint,
      compute: function compute(ep, anchorPoint, orientation, endpointStyle) {
        ep.x = anchorPoint.curX;
        ep.y = anchorPoint.curY;
        ep.w = 10;
        ep.h = 0;
        return [anchorPoint.curX, anchorPoint.curY, 10, 0];
      },
      getParams: function getParams(ep) {
        return {};
      }
    };

    var RectangleEndpoint = function (_EndpointRepresentati) {
      _inherits$1(RectangleEndpoint, _EndpointRepresentati);
      var _super = _createSuper$1(RectangleEndpoint);
      function RectangleEndpoint(endpoint, params) {
        var _this;
        _classCallCheck$1(this, RectangleEndpoint);
        _this = _super.call(this, endpoint, params);
        _defineProperty$1(_assertThisInitialized$1(_this), "width", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "height", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "type", RectangleEndpoint.type);
        params = params || {};
        _this.width = params.width || 10;
        _this.height = params.height || 10;
        return _this;
      }
      _createClass$1(RectangleEndpoint, null, [{
        key: "_getParams",
        value: function _getParams(ep) {
          return {
            width: ep.width,
            height: ep.height
          };
        }
      }]);
      return RectangleEndpoint;
    }(EndpointRepresentation);
    _defineProperty$1(RectangleEndpoint, "type", "Rectangle");
    var RectangleEndpointHandler = {
      type: RectangleEndpoint.type,
      cls: RectangleEndpoint,
      compute: function compute(ep, anchorPoint, orientation, endpointStyle) {
        var width = endpointStyle.width || ep.width,
            height = endpointStyle.height || ep.height,
            x = anchorPoint.curX - width / 2,
            y = anchorPoint.curY - height / 2;
        ep.x = x;
        ep.y = y;
        ep.w = width;
        ep.h = height;
        return [x, y, width, height];
      },
      getParams: function getParams(ep) {
        return {
          width: ep.width,
          height: ep.height
        };
      }
    };

    var AbstractConnector = function () {
      function AbstractConnector(connection, params) {
        _classCallCheck$1(this, AbstractConnector);
        this.connection = connection;
        _defineProperty$1(this, "type", void 0);
        _defineProperty$1(this, "edited", false);
        _defineProperty$1(this, "stub", void 0);
        _defineProperty$1(this, "sourceStub", void 0);
        _defineProperty$1(this, "targetStub", void 0);
        _defineProperty$1(this, "maxStub", void 0);
        _defineProperty$1(this, "typeId", void 0);
        _defineProperty$1(this, "gap", void 0);
        _defineProperty$1(this, "sourceGap", void 0);
        _defineProperty$1(this, "targetGap", void 0);
        _defineProperty$1(this, "segments", []);
        _defineProperty$1(this, "totalLength", 0);
        _defineProperty$1(this, "segmentProportions", []);
        _defineProperty$1(this, "segmentProportionalLengths", []);
        _defineProperty$1(this, "paintInfo", null);
        _defineProperty$1(this, "strokeWidth", void 0);
        _defineProperty$1(this, "x", void 0);
        _defineProperty$1(this, "y", void 0);
        _defineProperty$1(this, "w", void 0);
        _defineProperty$1(this, "h", void 0);
        _defineProperty$1(this, "segment", void 0);
        _defineProperty$1(this, "bounds", EMPTY_BOUNDS());
        _defineProperty$1(this, "cssClass", void 0);
        _defineProperty$1(this, "hoverClass", void 0);
        _defineProperty$1(this, "geometry", void 0);
        this.stub = params.stub || this.getDefaultStubs();
        this.sourceStub = Array.isArray(this.stub) ? this.stub[0] : this.stub;
        this.targetStub = Array.isArray(this.stub) ? this.stub[1] : this.stub;
        this.gap = params.gap || 0;
        this.sourceGap = Array.isArray(this.gap) ? this.gap[0] : this.gap;
        this.targetGap = Array.isArray(this.gap) ? this.gap[1] : this.gap;
        this.maxStub = Math.max(this.sourceStub, this.targetStub);
        this.cssClass = params.cssClass || "";
        this.hoverClass = params.hoverClass || "";
      }
      _createClass$1(AbstractConnector, [{
        key: "getTypeDescriptor",
        value: function getTypeDescriptor() {
          return "connector";
        }
      }, {
        key: "getIdPrefix",
        value: function getIdPrefix() {
          return "_jsplumb_connector";
        }
      }, {
        key: "setGeometry",
        value: function setGeometry(g, internal) {
          this.geometry = g;
          this.edited = g != null && !internal;
        }
      }, {
        key: "exportGeometry",
        value: function exportGeometry() {
          return this.geometry;
        }
      }, {
        key: "importGeometry",
        value: function importGeometry(g) {
          this.geometry = g;
          return true;
        }
      }, {
        key: "resetGeometry",
        value: function resetGeometry() {
          this.geometry = null;
          this.edited = false;
        }
      }, {
        key: "transformAnchorPlacement",
        value:
        function transformAnchorPlacement(a, dx, dy) {
          return {
            x: a.x,
            y: a.y,
            ox: a.ox,
            oy: a.oy,
            curX: a.curX + dx,
            curY: a.curY + dy
          };
        }
      }, {
        key: "resetBounds",
        value: function resetBounds() {
          this.bounds = EMPTY_BOUNDS();
        }
      }, {
        key: "findSegmentForPoint",
        value: function findSegmentForPoint(x, y) {
          var out = {
            d: Infinity,
            s: null,
            x: null,
            y: null,
            l: null,
            x1: null,
            y1: null,
            x2: null,
            y2: null,
            index: null,
            connectorLocation: null
          };
          for (var i = 0; i < this.segments.length; i++) {
            var _s = this.segments[i].findClosestPointOnPath(x, y);
            if (_s.d < out.d) {
              out.d = _s.d;
              out.l = _s.l;
              out.x = _s.x;
              out.y = _s.y;
              out.s = this.segments[i];
              out.x1 = _s.x1;
              out.x2 = _s.x2;
              out.y1 = _s.y1;
              out.y2 = _s.y2;
              out.index = i;
              out.connectorLocation = this.segmentProportions[i][0] + _s.l * (this.segmentProportions[i][1] - this.segmentProportions[i][0]);
            }
          }
          return out;
        }
      }, {
        key: "lineIntersection",
        value: function lineIntersection(x1, y1, x2, y2) {
          var out = [];
          for (var i = 0; i < this.segments.length; i++) {
            out.push.apply(out, this.segments[i].lineIntersection(x1, y1, x2, y2));
          }
          return out;
        }
      }, {
        key: "boxIntersection",
        value: function boxIntersection(x, y, w, h) {
          var out = [];
          for (var i = 0; i < this.segments.length; i++) {
            out.push.apply(out, this.segments[i].boxIntersection(x, y, w, h));
          }
          return out;
        }
      }, {
        key: "boundingBoxIntersection",
        value: function boundingBoxIntersection(box) {
          var out = [];
          for (var i = 0; i < this.segments.length; i++) {
            out.push.apply(out, this.segments[i].boundingBoxIntersection(box));
          }
          return out;
        }
      }, {
        key: "_updateSegmentProportions",
        value: function _updateSegmentProportions() {
          var curLoc = 0;
          for (var i = 0; i < this.segments.length; i++) {
            var sl = this.segments[i].getLength();
            this.segmentProportionalLengths[i] = sl / this.totalLength;
            this.segmentProportions[i] = [curLoc, curLoc += sl / this.totalLength];
          }
        }
      }, {
        key: "_findSegmentForLocation",
        value: function _findSegmentForLocation(location, absolute) {
          var idx, i, inSegmentProportion;
          if (absolute) {
            location = location > 0 ? location / this.totalLength : (this.totalLength + location) / this.totalLength;
          }
          if (location === 1) {
            idx = this.segments.length - 1;
            inSegmentProportion = 1;
          } else if (location === 0) {
            inSegmentProportion = 0;
            idx = 0;
          } else {
            if (location >= 0.5) {
              idx = 0;
              inSegmentProportion = 0;
              for (i = this.segmentProportions.length - 1; i > -1; i--) {
                if (this.segmentProportions[i][1] >= location && this.segmentProportions[i][0] <= location) {
                  idx = i;
                  inSegmentProportion = (location - this.segmentProportions[i][0]) / this.segmentProportionalLengths[i];
                  break;
                }
              }
            } else {
              idx = this.segmentProportions.length - 1;
              inSegmentProportion = 1;
              for (i = 0; i < this.segmentProportions.length; i++) {
                if (this.segmentProportions[i][1] >= location) {
                  idx = i;
                  inSegmentProportion = (location - this.segmentProportions[i][0]) / this.segmentProportionalLengths[i];
                  break;
                }
              }
            }
          }
          return {
            segment: this.segments[idx],
            proportion: inSegmentProportion,
            index: idx
          };
        }
      }, {
        key: "_addSegment",
        value: function _addSegment(clazz, params) {
          if (params.x1 === params.x2 && params.y1 === params.y2) {
            return;
          }
          var s = new clazz(params);
          this.segments.push(s);
          this.totalLength += s.getLength();
          this.updateBounds(s);
        }
      }, {
        key: "_clearSegments",
        value: function _clearSegments() {
          this.totalLength = 0;
          this.segments.length = 0;
          this.segmentProportions.length = 0;
          this.segmentProportionalLengths.length = 0;
        }
      }, {
        key: "getLength",
        value: function getLength() {
          return this.totalLength;
        }
      }, {
        key: "_prepareCompute",
        value: function _prepareCompute(params) {
          this.strokeWidth = params.strokeWidth;
          var x1 = params.sourcePos.curX,
              x2 = params.targetPos.curX,
              y1 = params.sourcePos.curY,
              y2 = params.targetPos.curY,
              segment = quadrant({
            x: x1,
            y: y1
          }, {
            x: x2,
            y: y2
          }),
              swapX = x2 < x1,
              swapY = y2 < y1,
              so = [params.sourcePos.ox, params.sourcePos.oy],
              to = [params.targetPos.ox, params.targetPos.oy],
              x = swapX ? x2 : x1,
              y = swapY ? y2 : y1,
              w = Math.abs(x2 - x1),
              h = Math.abs(y2 - y1);
          if (so[0] === 0 && so[1] === 0 || to[0] === 0 && to[1] === 0) {
            var index = w > h ? 0 : 1,
                oIndex = [1, 0][index],
                v1 = index === 0 ? x1 : y1,
                v2 = index === 0 ? x2 : y2;
            so[index] = v1 > v2 ? -1 : 1;
            to[index] = v1 > v2 ? 1 : -1;
            so[oIndex] = 0;
            to[oIndex] = 0;
          }
          var sx = swapX ? w + this.sourceGap * so[0] : this.sourceGap * so[0],
              sy = swapY ? h + this.sourceGap * so[1] : this.sourceGap * so[1],
              tx = swapX ? this.targetGap * to[0] : w + this.targetGap * to[0],
              ty = swapY ? this.targetGap * to[1] : h + this.targetGap * to[1],
              oProduct = so[0] * to[0] + so[1] * to[1];
          var result = {
            sx: sx,
            sy: sy,
            tx: tx,
            ty: ty,
            xSpan: Math.abs(tx - sx),
            ySpan: Math.abs(ty - sy),
            mx: (sx + tx) / 2,
            my: (sy + ty) / 2,
            so: so,
            to: to,
            x: x,
            y: y,
            w: w,
            h: h,
            segment: segment,
            startStubX: sx + so[0] * this.sourceStub,
            startStubY: sy + so[1] * this.sourceStub,
            endStubX: tx + to[0] * this.targetStub,
            endStubY: ty + to[1] * this.targetStub,
            isXGreaterThanStubTimes2: Math.abs(sx - tx) > this.sourceStub + this.targetStub,
            isYGreaterThanStubTimes2: Math.abs(sy - ty) > this.sourceStub + this.targetStub,
            opposite: oProduct === -1,
            perpendicular: oProduct === 0,
            orthogonal: oProduct === 1,
            sourceAxis: so[0] === 0 ? "y" : "x",
            points: [x, y, w, h, sx, sy, tx, ty],
            stubs: [this.sourceStub, this.targetStub]
          };
          result.anchorOrientation = result.opposite ? "opposite" : result.orthogonal ? "orthogonal" : "perpendicular";
          return result;
        }
      }, {
        key: "updateBounds",
        value: function updateBounds(segment) {
          var segBounds = segment.extents;
          this.bounds.xmin = Math.min(this.bounds.xmin, segBounds.xmin);
          this.bounds.xmax = Math.max(this.bounds.xmax, segBounds.xmax);
          this.bounds.ymin = Math.min(this.bounds.ymin, segBounds.ymin);
          this.bounds.ymax = Math.max(this.bounds.ymax, segBounds.ymax);
        }
      }, {
        key: "dumpSegmentsToConsole",
        value: function dumpSegmentsToConsole() {
          log("SEGMENTS:");
          for (var i = 0; i < this.segments.length; i++) {
            log(this.segments[i].type, "" + this.segments[i].getLength(), "" + this.segmentProportions[i]);
          }
        }
      }, {
        key: "pointOnPath",
        value: function pointOnPath(location, absolute) {
          var seg = this._findSegmentForLocation(location, absolute);
          return seg.segment && seg.segment.pointOnPath(seg.proportion, false) || {
            x: 0,
            y: 0
          };
        }
      }, {
        key: "gradientAtPoint",
        value: function gradientAtPoint(location, absolute) {
          var seg = this._findSegmentForLocation(location, absolute);
          return seg.segment && seg.segment.gradientAtPoint(seg.proportion, false) || 0;
        }
      }, {
        key: "pointAlongPathFrom",
        value: function pointAlongPathFrom(location, distance, absolute) {
          var seg = this._findSegmentForLocation(location, absolute);
          return seg.segment && seg.segment.pointAlongPathFrom(seg.proportion, distance, false) || {
            x: 0,
            y: 0
          };
        }
      }, {
        key: "compute",
        value: function compute(params) {
          this.paintInfo = this._prepareCompute(params);
          this._clearSegments();
          this._compute(this.paintInfo, params);
          this.x = this.paintInfo.points[0];
          this.y = this.paintInfo.points[1];
          this.w = this.paintInfo.points[2];
          this.h = this.paintInfo.points[3];
          this.segment = this.paintInfo.segment;
          this._updateSegmentProportions();
        }
      }, {
        key: "setAnchorOrientation",
        value: function setAnchorOrientation(idx, orientation) {}
      }]);
      return AbstractConnector;
    }();

    var StraightSegment = function (_AbstractSegment) {
      _inherits$1(StraightSegment, _AbstractSegment);
      var _super = _createSuper$1(StraightSegment);
      function StraightSegment(params) {
        var _this;
        _classCallCheck$1(this, StraightSegment);
        _this = _super.call(this, params);
        _defineProperty$1(_assertThisInitialized$1(_this), "length", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "m", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "m2", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "type", StraightSegment.segmentType);
        _this._setCoordinates({
          x1: params.x1,
          y1: params.y1,
          x2: params.x2,
          y2: params.y2
        });
        return _this;
      }
      _createClass$1(StraightSegment, [{
        key: "getPath",
        value: function getPath(isFirstSegment) {
          return (isFirstSegment ? "M " + this.x1 + " " + this.y1 + " " : "") + "L " + this.x2 + " " + this.y2;
        }
      }, {
        key: "_recalc",
        value: function _recalc() {
          this.length = Math.sqrt(Math.pow(this.x2 - this.x1, 2) + Math.pow(this.y2 - this.y1, 2));
          this.m = gradient({
            x: this.x1,
            y: this.y1
          }, {
            x: this.x2,
            y: this.y2
          });
          this.m2 = -1 / this.m;
          this.extents = {
            xmin: Math.min(this.x1, this.x2),
            ymin: Math.min(this.y1, this.y2),
            xmax: Math.max(this.x1, this.x2),
            ymax: Math.max(this.y1, this.y2)
          };
        }
      }, {
        key: "getLength",
        value: function getLength() {
          return this.length;
        }
      }, {
        key: "getGradient",
        value: function getGradient() {
          return this.m;
        }
      }, {
        key: "_setCoordinates",
        value: function _setCoordinates(coords) {
          this.x1 = coords.x1;
          this.y1 = coords.y1;
          this.x2 = coords.x2;
          this.y2 = coords.y2;
          this._recalc();
        }
      }, {
        key: "pointOnPath",
        value: function pointOnPath(location, absolute) {
          if (location === 0 && !absolute) {
            return {
              x: this.x1,
              y: this.y1
            };
          } else if (location === 1 && !absolute) {
            return {
              x: this.x2,
              y: this.y2
            };
          } else {
            var l = absolute ? location > 0 ? location : this.length + location : location * this.length;
            return pointOnLine({
              x: this.x1,
              y: this.y1
            }, {
              x: this.x2,
              y: this.y2
            }, l);
          }
        }
      }, {
        key: "gradientAtPoint",
        value: function gradientAtPoint(location, absolute) {
          return this.m;
        }
      }, {
        key: "pointAlongPathFrom",
        value: function pointAlongPathFrom(location, distance, absolute) {
          var p = this.pointOnPath(location, absolute),
              farAwayPoint = distance <= 0 ? {
            x: this.x1,
            y: this.y1
          } : {
            x: this.x2,
            y: this.y2
          };
          if (distance <= 0 && Math.abs(distance) > 1) {
            distance *= -1;
          }
          return pointOnLine(p, farAwayPoint, distance);
        }
      }, {
        key: "within",
        value: function within(a, b, c) {
          return c >= Math.min(a, b) && c <= Math.max(a, b);
        }
      }, {
        key: "closest",
        value: function closest(a, b, c) {
          return Math.abs(c - a) < Math.abs(c - b) ? a : b;
        }
      }, {
        key: "findClosestPointOnPath",
        value: function findClosestPointOnPath(x, y) {
          var out = {
            d: Infinity,
            x: null,
            y: null,
            l: null,
            x1: this.x1,
            x2: this.x2,
            y1: this.y1,
            y2: this.y2
          };
          if (this.m === 0) {
            out.y = this.y1;
            out.x = this.within(this.x1, this.x2, x) ? x : this.closest(this.x1, this.x2, x);
          } else if (this.m === Infinity || this.m === -Infinity) {
            out.x = this.x1;
            out.y = this.within(this.y1, this.y2, y) ? y : this.closest(this.y1, this.y2, y);
          } else {
            var b = this.y1 - this.m * this.x1,
                b2 = y - this.m2 * x,
            _x1 = (b2 - b) / (this.m - this.m2),
                _y1 = this.m * _x1 + b;
            out.x = this.within(this.x1, this.x2, _x1) ? _x1 : this.closest(this.x1, this.x2, _x1);
            out.y = this.within(this.y1, this.y2, _y1) ? _y1 : this.closest(this.y1, this.y2, _y1);
          }
          var fractionInSegment = lineLength({
            x: out.x,
            y: out.y
          }, {
            x: this.x1,
            y: this.y1
          });
          out.d = lineLength({
            x: x,
            y: y
          }, out);
          out.l = fractionInSegment / length;
          return out;
        }
      }, {
        key: "_pointLiesBetween",
        value: function _pointLiesBetween(q, p1, p2) {
          return p2 > p1 ? p1 <= q && q <= p2 : p1 >= q && q >= p2;
        }
      }, {
        key: "lineIntersection",
        value: function lineIntersection(_x1, _y1, _x2, _y2) {
          var m2 = Math.abs(gradient({
            x: _x1,
            y: _y1
          }, {
            x: _x2,
            y: _y2
          })),
              m1 = Math.abs(this.m),
              b = m1 === Infinity ? this.x1 : this.y1 - m1 * this.x1,
              out = [],
              b2 = m2 === Infinity ? _x1 : _y1 - m2 * _x1;
          if (m2 !== m1) {
            if (m2 === Infinity && m1 === 0) {
              if (this._pointLiesBetween(_x1, this.x1, this.x2) && this._pointLiesBetween(this.y1, _y1, _y2)) {
                out.push({
                  x: _x1,
                  y: this.y1
                });
              }
            } else if (m2 === 0 && m1 === Infinity) {
              if (this._pointLiesBetween(_y1, this.y1, this.y2) && this._pointLiesBetween(this.x1, _x1, _x2)) {
                out.push({
                  x: this.x1,
                  y: _y1
                });
              }
            } else {
              var X, Y;
              if (m2 === Infinity) {
                X = _x1;
                if (this._pointLiesBetween(X, this.x1, this.x2)) {
                  Y = m1 * _x1 + b;
                  if (this._pointLiesBetween(Y, _y1, _y2)) {
                    out.push({
                      x: X,
                      y: Y
                    });
                  }
                }
              } else if (m2 === 0) {
                Y = _y1;
                if (this._pointLiesBetween(Y, this.y1, this.y2)) {
                  X = (_y1 - b) / m1;
                  if (this._pointLiesBetween(X, _x1, _x2)) {
                    out.push({
                      x: X,
                      y: Y
                    });
                  }
                }
              } else {
                X = (b2 - b) / (m1 - m2);
                Y = m1 * X + b;
                if (this._pointLiesBetween(X, this.x1, this.x2) && this._pointLiesBetween(Y, this.y1, this.y2)) {
                  out.push({
                    x: X,
                    y: Y
                  });
                }
              }
            }
          }
          return out;
        }
      }, {
        key: "boxIntersection",
        value: function boxIntersection(x, y, w, h) {
          var a = [];
          a.push.apply(a, this.lineIntersection(x, y, x + w, y));
          a.push.apply(a, this.lineIntersection(x + w, y, x + w, y + h));
          a.push.apply(a, this.lineIntersection(x + w, y + h, x, y + h));
          a.push.apply(a, this.lineIntersection(x, y + h, x, y));
          return a;
        }
      }]);
      return StraightSegment;
    }(AbstractSegment);
    _defineProperty$1(StraightSegment, "segmentType", "Straight");

    var StraightConnector = function (_AbstractConnector) {
      _inherits$1(StraightConnector, _AbstractConnector);
      var _super = _createSuper$1(StraightConnector);
      function StraightConnector() {
        var _this;
        _classCallCheck$1(this, StraightConnector);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$1(_assertThisInitialized$1(_this), "type", StraightConnector.type);
        return _this;
      }
      _createClass$1(StraightConnector, [{
        key: "getDefaultStubs",
        value: function getDefaultStubs() {
          return [0, 0];
        }
      }, {
        key: "_compute",
        value: function _compute(paintInfo, p) {
          this._addSegment(StraightSegment, {
            x1: paintInfo.sx,
            y1: paintInfo.sy,
            x2: paintInfo.startStubX,
            y2: paintInfo.startStubY
          });
          this._addSegment(StraightSegment, {
            x1: paintInfo.startStubX,
            y1: paintInfo.startStubY,
            x2: paintInfo.endStubX,
            y2: paintInfo.endStubY
          });
          this._addSegment(StraightSegment, {
            x1: paintInfo.endStubX,
            y1: paintInfo.endStubY,
            x2: paintInfo.tx,
            y2: paintInfo.ty
          });
          this.geometry = {
            source: p.sourcePos,
            target: p.targetPos
          };
        }
      }, {
        key: "transformGeometry",
        value: function transformGeometry(g, dx, dy) {
          return {
            source: this.transformAnchorPlacement(g.source, dx, dy),
            target: this.transformAnchorPlacement(g.target, dx, dy)
          };
        }
      }]);
      return StraightConnector;
    }(AbstractConnector);
    _defineProperty$1(StraightConnector, "type", "Straight");

    var connectorMap = {};
    var Connectors = {
      get: function get(connection, name, params) {
        var c = connectorMap[name];
        if (!c) {
          throw {
            message: "jsPlumb: unknown connector type '" + name + "'"
          };
        } else {
          return new c(connection, params);
        }
      },
      register: function register(name, conn) {
        connectorMap[name] = conn;
      }
    };

    function cls() {
      for (var _len = arguments.length, className = new Array(_len), _key = 0; _key < _len; _key++) {
        className[_key] = arguments[_key];
      }
      return className.map(function (cn) {
        return "." + cn;
      }).join(",");
    }
    function classList() {
      for (var _len2 = arguments.length, className = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        className[_key2] = arguments[_key2];
      }
      return className.join(" ");
    }
    function att() {
      for (var _len3 = arguments.length, attName = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        attName[_key3] = arguments[_key3];
      }
      return attName.map(function (an) {
        return "[" + an + "]";
      }).join(",");
    }
    var SOURCE = "source";
    var TARGET = "target";
    var BLOCK = "block";
    var NONE = "none";
    var ABSOLUTE = "absolute";
    var FIXED = "fixed";
    var STATIC = "static";
    var ATTRIBUTE_GROUP = "data-jtk-group";
    var ATTRIBUTE_MANAGED = "data-jtk-managed";
    var ATTRIBUTE_NOT_DRAGGABLE = "data-jtk-not-draggable";
    var ATTRIBUTE_TABINDEX = "tabindex";
    var ATTRIBUTE_SCOPE = "data-jtk-scope";
    var ATTRIBUTE_SCOPE_PREFIX = ATTRIBUTE_SCOPE + "-";
    var CHECK_CONDITION = "checkCondition";
    var CHECK_DROP_ALLOWED = "checkDropAllowed";
    var CLASS_CONNECTOR = "jtk-connector";
    var CLASS_CONNECTOR_OUTLINE = "jtk-connector-outline";
    var CLASS_CONNECTED = "jtk-connected";
    var CLASS_ENDPOINT = "jtk-endpoint";
    var CLASS_ENDPOINT_CONNECTED = "jtk-endpoint-connected";
    var CLASS_ENDPOINT_FULL = "jtk-endpoint-full";
    var CLASS_ENDPOINT_DROP_ALLOWED = "jtk-endpoint-drop-allowed";
    var CLASS_ENDPOINT_DROP_FORBIDDEN = "jtk-endpoint-drop-forbidden";
    var CLASS_ENDPOINT_ANCHOR_PREFIX = "jtk-endpoint-anchor";
    var CLASS_GROUP_COLLAPSED = "jtk-group-collapsed";
    var CLASS_GROUP_EXPANDED = "jtk-group-expanded";
    var CLASS_OVERLAY = "jtk-overlay";
    var EVENT_ANCHOR_CHANGED = "anchor:changed";
    var EVENT_CONNECTION = "connection";
    var EVENT_INTERNAL_CONNECTION = "internal.connection";
    var EVENT_CONNECTION_DETACHED = "connection:detach";
    var EVENT_CONNECTION_MOVED = "connection:move";
    var EVENT_CONTAINER_CHANGE = "container:change";
    var EVENT_ENDPOINT_REPLACED = "endpoint:replaced";
    var EVENT_INTERNAL_ENDPOINT_UNREGISTERED = "internal.endpoint:unregistered";
    var EVENT_INTERNAL_CONNECTION_DETACHED = "internal.connection:detached";
    var EVENT_MANAGE_ELEMENT = "element:manage";
    var EVENT_GROUP_ADDED = "group:added";
    var EVENT_GROUP_COLLAPSE = "group:collapse";
    var EVENT_GROUP_EXPAND = "group:expand";
    var EVENT_GROUP_MEMBER_ADDED = "group:member:added";
    var EVENT_GROUP_MEMBER_REMOVED = "group:member:removed";
    var EVENT_GROUP_REMOVED = "group:removed";
    var EVENT_MAX_CONNECTIONS = "maxConnections";
    var EVENT_NESTED_GROUP_ADDED = "group:nested:added";
    var EVENT_NESTED_GROUP_REMOVED = "group:nested:removed";
    var EVENT_UNMANAGE_ELEMENT = "element:unmanage";
    var EVENT_ZOOM = "zoom";
    var IS_DETACH_ALLOWED = "isDetachAllowed";
    var INTERCEPT_BEFORE_DRAG = "beforeDrag";
    var INTERCEPT_BEFORE_DROP = "beforeDrop";
    var INTERCEPT_BEFORE_DETACH = "beforeDetach";
    var INTERCEPT_BEFORE_START_DETACH = "beforeStartDetach";
    var SELECTOR_MANAGED_ELEMENT = att(ATTRIBUTE_MANAGED);
    var ERROR_SOURCE_ENDPOINT_FULL = "Cannot establish connection: source endpoint is full";
    var ERROR_TARGET_ENDPOINT_FULL = "Cannot establish connection: target endpoint is full";
    var ERROR_SOURCE_DOES_NOT_EXIST = "Cannot establish connection: source does not exist";
    var ERROR_TARGET_DOES_NOT_EXIST = "Cannot establish connection: target does not exist";
    var KEY_CONNECTION_OVERLAYS = "connectionOverlays";
    function convertToFullOverlaySpec(spec) {
      var o = null;
      if (isString(spec)) {
        o = {
          type: spec,
          options: {}
        };
      } else {
        o = spec;
      }
      o.options.id = o.options.id || uuid();
      return o;
    }
    var Overlay = function (_EventGenerator) {
      _inherits$1(Overlay, _EventGenerator);
      var _super = _createSuper$1(Overlay);
      function Overlay(instance, component, p) {
        var _this;
        _classCallCheck$1(this, Overlay);
        _this = _super.call(this);
        _this.instance = instance;
        _this.component = component;
        _defineProperty$1(_assertThisInitialized$1(_this), "id", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "type", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "cssClass", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "visible", true);
        _defineProperty$1(_assertThisInitialized$1(_this), "location", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "events", void 0);
        p = p || {};
        _this.id = p.id || uuid();
        _this.cssClass = p.cssClass || "";
        _this.location = p.location || 0.5;
        _this.events = p.events || {};
        for (var _event in _this.events) {
          _this.bind(_event, _this.events[_event]);
        }
        return _this;
      }
      _createClass$1(Overlay, [{
        key: "shouldFireEvent",
        value: function shouldFireEvent(event, value, originalEvent) {
          return true;
        }
      }, {
        key: "setVisible",
        value: function setVisible(v) {
          this.visible = v;
          this.instance.setOverlayVisible(this, v);
        }
      }, {
        key: "isVisible",
        value: function isVisible() {
          return this.visible;
        }
      }]);
      return Overlay;
    }(EventGenerator);

    var overlayMap = {};
    var OverlayFactory = {
      get: function get(instance, name, component, params) {
        var c = overlayMap[name];
        if (!c) {
          throw {
            message: "jsPlumb: unknown overlay type '" + name + "'"
          };
        } else {
          return new c(instance, component, params);
        }
      },
      register: function register(name, overlay) {
        overlayMap[name] = overlay;
      }
    };

    var LabelOverlay = function (_Overlay) {
      _inherits$1(LabelOverlay, _Overlay);
      var _super = _createSuper$1(LabelOverlay);
      function LabelOverlay(instance, component, p) {
        var _this;
        _classCallCheck$1(this, LabelOverlay);
        _this = _super.call(this, instance, component, p);
        _this.instance = instance;
        _this.component = component;
        _defineProperty$1(_assertThisInitialized$1(_this), "label", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "labelText", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "type", LabelOverlay.type);
        _defineProperty$1(_assertThisInitialized$1(_this), "cachedDimensions", void 0);
        p = p || {
          label: ""
        };
        _this.setLabel(p.label);
        return _this;
      }
      _createClass$1(LabelOverlay, [{
        key: "getLabel",
        value: function getLabel() {
          if (isFunction(this.label)) {
            return this.label(this);
          } else {
            return this.labelText;
          }
        }
      }, {
        key: "setLabel",
        value: function setLabel(l) {
          this.label = l;
          this.labelText = null;
          this.instance.updateLabel(this);
        }
      }, {
        key: "getDimensions",
        value: function getDimensions() {
          return {
            w: 1,
            h: 1
          };
        }
      }, {
        key: "updateFrom",
        value: function updateFrom(d) {
          if (d.label != null) {
            this.setLabel(d.label);
          }
        }
      }]);
      return LabelOverlay;
    }(Overlay);
    _defineProperty$1(LabelOverlay, "type", "Label");
    function isLabelOverlay(o) {
      return o.type === LabelOverlay.type;
    }
    OverlayFactory.register("Label", LabelOverlay);

    function _splitType(t) {
      return t == null ? null : t.split(" ");
    }
    function _mapType(map, obj, typeId) {
      for (var i in obj) {
        map[i] = typeId;
      }
    }
    var CONNECTOR = "connector";
    var MERGE_STRATEGY_OVERRIDE = "override";
    var CSS_CLASS = "cssClass";
    var DEFAULT_TYPE_KEY = "__default";
    var ANCHOR = "anchor";
    var ANCHORS = "anchors";
    var _internalLabelOverlayId = "__label";
    var TYPE_ITEM_OVERLAY = "overlay";
    var LOCATION_ATTRIBUTE = "labelLocation";
    var ACTION_ADD = "add";
    var ACTION_REMOVE = "remove";
    function _applyTypes(component, params) {
      if (component.getDefaultType) {
        var td = component.getTypeDescriptor(),
            map = {};
        var defType = component.getDefaultType();
        var o = extend({}, defType);
        _mapType(map, defType, DEFAULT_TYPE_KEY);
        for (var i = 0, j = component._types.length; i < j; i++) {
          var tid = component._types[i];
          if (tid !== DEFAULT_TYPE_KEY) {
            var _t = component.instance.getType(tid, td);
            if (_t != null) {
              var overrides = new Set([CONNECTOR, ANCHOR, ANCHORS]);
              if (_t.mergeStrategy === MERGE_STRATEGY_OVERRIDE) {
                for (var k in _t) {
                  overrides.add(k);
                }
              }
              o = merge(o, _t, [CSS_CLASS], setToArray(overrides));
              _mapType(map, _t, tid);
            }
          }
        }
        if (params) {
          o = populate(o, params, "_");
        }
        component.applyType(o, map);
      }
    }
    function _removeTypeCssHelper(component, typeIndex) {
      var typeId = component._types[typeIndex],
          type = component.instance.getType(typeId, component.getTypeDescriptor());
      if (type != null && type.cssClass) {
        component.removeClass(type.cssClass);
      }
    }
    function _updateHoverStyle(component) {
      if (component.paintStyle && component.hoverPaintStyle) {
        var mergedHoverStyle = {};
        extend(mergedHoverStyle, component.paintStyle);
        extend(mergedHoverStyle, component.hoverPaintStyle);
        component.hoverPaintStyle = mergedHoverStyle;
      }
    }
    function _makeLabelOverlay(component, params) {
      var _params = {
        cssClass: params.cssClass,
        id: _internalLabelOverlayId,
        component: component
      },
          mergedParams = extend(_params, params);
      return new LabelOverlay(component.instance, component, mergedParams);
    }
    function _processOverlay(component, o) {
      var _newOverlay = null;
      if (isString(o)) {
        _newOverlay = OverlayFactory.get(component.instance, o, component, {});
      } else if (o.type != null && o.options != null) {
        var oa = o;
        var p = extend({}, oa.options);
        _newOverlay = OverlayFactory.get(component.instance, oa.type, component, p);
      } else {
        _newOverlay = o;
      }
      _newOverlay.id = _newOverlay.id || uuid();
      component.cacheTypeItem(TYPE_ITEM_OVERLAY, _newOverlay, _newOverlay.id);
      component.overlays[_newOverlay.id] = _newOverlay;
      return _newOverlay;
    }
    var Component = function (_EventGenerator) {
      _inherits$1(Component, _EventGenerator);
      var _super = _createSuper$1(Component);
      function Component(instance, params) {
        var _this;
        _classCallCheck$1(this, Component);
        _this = _super.call(this);
        _this.instance = instance;
        _defineProperty$1(_assertThisInitialized$1(_this), "defaultLabelLocation", 0.5);
        _defineProperty$1(_assertThisInitialized$1(_this), "overlays", {});
        _defineProperty$1(_assertThisInitialized$1(_this), "overlayPositions", {});
        _defineProperty$1(_assertThisInitialized$1(_this), "overlayPlacements", {});
        _defineProperty$1(_assertThisInitialized$1(_this), "clone", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "deleted", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "segment", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "x", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "y", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "w", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "h", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "id", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "visible", true);
        _defineProperty$1(_assertThisInitialized$1(_this), "typeId", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "params", {});
        _defineProperty$1(_assertThisInitialized$1(_this), "paintStyle", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "hoverPaintStyle", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "paintStyleInUse", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "_hover", false);
        _defineProperty$1(_assertThisInitialized$1(_this), "lastPaintedAt", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "data", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "_defaultType", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "events", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "parameters", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "_types", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "_typeCache", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "cssClass", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "hoverClass", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "beforeDetach", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "beforeDrop", void 0);
        params = params || {};
        _this.cssClass = params.cssClass || "";
        _this.hoverClass = params.hoverClass || instance.defaults.hoverClass;
        _this.beforeDetach = params.beforeDetach;
        _this.beforeDrop = params.beforeDrop;
        _this._types = [];
        _this._typeCache = {};
        _this.parameters = clone(params.parameters || {});
        _this.id = params.id || _this.getIdPrefix() + new Date().getTime();
        _this._defaultType = {
          parameters: _this.parameters,
          scope: params.scope || _this.instance.defaultScope,
          overlays: {}
        };
        if (params.events) {
          for (var evtName in params.events) {
            _this.bind(evtName, params.events[evtName]);
          }
        }
        _this.clone = function () {
          var o = Object.create(_this.constructor.prototype);
          _this.constructor.apply(o, [instance, params]);
          return o;
        };
        _this.overlays = {};
        _this.overlayPositions = {};
        var o = params.overlays || [],
            oo = {};
        var defaultOverlayKey = _this.getDefaultOverlayKey();
        if (defaultOverlayKey) {
          var defaultOverlays = _this.instance.defaults[defaultOverlayKey];
          if (defaultOverlays) {
            o.push.apply(o, _toConsumableArray(defaultOverlays));
          }
          for (var i = 0; i < o.length; i++) {
            var fo = convertToFullOverlaySpec(o[i]);
            oo[fo.options.id] = fo;
          }
        }
        _this._defaultType.overlays = oo;
        if (params.label) {
          _this.getDefaultType().overlays[_internalLabelOverlayId] = {
            type: LabelOverlay.type,
            options: {
              label: params.label,
              location: params.labelLocation || _this.defaultLabelLocation,
              id: _internalLabelOverlayId
            }
          };
        }
        return _this;
      }
      _createClass$1(Component, [{
        key: "isDetachAllowed",
        value: function isDetachAllowed(connection) {
          var r = true;
          if (this.beforeDetach) {
            try {
              r = this.beforeDetach(connection);
            } catch (e) {
              log("jsPlumb: beforeDetach callback failed", e);
            }
          }
          return r;
        }
      }, {
        key: "isDropAllowed",
        value: function isDropAllowed(sourceId, targetId, scope, connection, dropEndpoint) {
          var r;
          var payload = {
            sourceId: sourceId,
            targetId: targetId,
            scope: scope,
            connection: connection,
            dropEndpoint: dropEndpoint
          };
          if (this.beforeDrop) {
            try {
              r = this.beforeDrop(payload);
            } catch (e) {
              log("jsPlumb: beforeDrop callback failed", e);
            }
          } else {
            r = this.instance.checkCondition(INTERCEPT_BEFORE_DROP, payload);
          }
          return r;
        }
      }, {
        key: "getDefaultType",
        value: function getDefaultType() {
          return this._defaultType;
        }
      }, {
        key: "appendToDefaultType",
        value: function appendToDefaultType(obj) {
          for (var i in obj) {
            this._defaultType[i] = obj[i];
          }
        }
      }, {
        key: "getId",
        value: function getId() {
          return this.id;
        }
      }, {
        key: "cacheTypeItem",
        value: function cacheTypeItem(key, item, typeId) {
          this._typeCache[typeId] = this._typeCache[typeId] || {};
          this._typeCache[typeId][key] = item;
        }
      }, {
        key: "getCachedTypeItem",
        value: function getCachedTypeItem(key, typeId) {
          return this._typeCache[typeId] ? this._typeCache[typeId][key] : null;
        }
      }, {
        key: "setType",
        value: function setType(typeId, params) {
          this.clearTypes();
          this._types = _splitType(typeId) || [];
          _applyTypes(this, params);
        }
      }, {
        key: "getType",
        value: function getType() {
          return this._types;
        }
      }, {
        key: "reapplyTypes",
        value: function reapplyTypes(params) {
          _applyTypes(this, params);
        }
      }, {
        key: "hasType",
        value: function hasType(typeId) {
          return this._types.indexOf(typeId) !== -1;
        }
      }, {
        key: "addType",
        value: function addType(typeId, params) {
          var t = _splitType(typeId),
              _somethingAdded = false;
          if (t != null) {
            for (var i = 0, j = t.length; i < j; i++) {
              if (!this.hasType(t[i])) {
                this._types.push(t[i]);
                _somethingAdded = true;
              }
            }
            if (_somethingAdded) {
              _applyTypes(this, params);
            }
          }
        }
      }, {
        key: "removeType",
        value: function removeType(typeId, params) {
          var _this2 = this;
          var t = _splitType(typeId),
              _cont = false,
              _one = function _one(tt) {
            var idx = _this2._types.indexOf(tt);
            if (idx !== -1) {
              _removeTypeCssHelper(_this2, idx);
              _this2._types.splice(idx, 1);
              return true;
            }
            return false;
          };
          if (t != null) {
            for (var i = 0, j = t.length; i < j; i++) {
              _cont = _one(t[i]) || _cont;
            }
            if (_cont) {
              _applyTypes(this, params);
            }
          }
        }
      }, {
        key: "clearTypes",
        value: function clearTypes(params, doNotRepaint) {
          var i = this._types.length;
          for (var j = 0; j < i; j++) {
            _removeTypeCssHelper(this, 0);
            this._types.splice(0, 1);
          }
          _applyTypes(this, params);
        }
      }, {
        key: "toggleType",
        value: function toggleType(typeId, params) {
          var t = _splitType(typeId);
          if (t != null) {
            for (var i = 0, j = t.length; i < j; i++) {
              var idx = this._types.indexOf(t[i]);
              if (idx !== -1) {
                _removeTypeCssHelper(this, idx);
                this._types.splice(idx, 1);
              } else {
                this._types.push(t[i]);
              }
            }
            _applyTypes(this, params);
          }
        }
      }, {
        key: "applyType",
        value: function applyType(t, params) {
          this.setPaintStyle(t.paintStyle);
          this.setHoverPaintStyle(t.hoverPaintStyle);
          this.mergeParameters(t.parameters);
          this.paintStyleInUse = this.getPaintStyle();
          if (t.overlays) {
            var keep = {},
                i;
            for (i in t.overlays) {
              var existing = this.overlays[t.overlays[i].options.id];
              if (existing) {
                existing.updateFrom(t.overlays[i].options);
                keep[t.overlays[i].options.id] = true;
                this.instance.reattachOverlay(existing, this);
              } else {
                var _c = this.getCachedTypeItem("overlay", t.overlays[i].options.id);
                if (_c != null) {
                  this.instance.reattachOverlay(_c, this);
                  _c.setVisible(true);
                  _c.updateFrom(t.overlays[i].options);
                  this.overlays[_c.id] = _c;
                } else {
                  _c = this.addOverlay(t.overlays[i]);
                }
                keep[_c.id] = true;
              }
            }
            for (i in this.overlays) {
              if (keep[this.overlays[i].id] == null) {
                this.removeOverlay(this.overlays[i].id, true);
              }
            }
          }
        }
      }, {
        key: "setPaintStyle",
        value: function setPaintStyle(style) {
          this.paintStyle = style;
          this.paintStyleInUse = this.paintStyle;
          _updateHoverStyle(this);
        }
      }, {
        key: "getPaintStyle",
        value: function getPaintStyle() {
          return this.paintStyle;
        }
      }, {
        key: "setHoverPaintStyle",
        value: function setHoverPaintStyle(style) {
          this.hoverPaintStyle = style;
          _updateHoverStyle(this);
        }
      }, {
        key: "getHoverPaintStyle",
        value: function getHoverPaintStyle() {
          return this.hoverPaintStyle;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          for (var i in this.overlays) {
            this.instance.destroyOverlay(this.overlays[i]);
          }
          this.overlays = {};
          this.overlayPositions = {};
          this.unbind();
          this.clone = null;
        }
      }, {
        key: "isHover",
        value: function isHover() {
          return this._hover;
        }
      }, {
        key: "mergeParameters",
        value: function mergeParameters(p) {
          if (p != null) {
            extend(this.parameters, p);
          }
        }
      }, {
        key: "setVisible",
        value: function setVisible(v) {
          this.visible = v;
          if (v) {
            this.showOverlays();
          } else {
            this.hideOverlays();
          }
        }
      }, {
        key: "isVisible",
        value: function isVisible() {
          return this.visible;
        }
      }, {
        key: "setAbsoluteOverlayPosition",
        value: function setAbsoluteOverlayPosition(overlay, xy) {
          this.overlayPositions[overlay.id] = xy;
        }
      }, {
        key: "getAbsoluteOverlayPosition",
        value: function getAbsoluteOverlayPosition(overlay) {
          return this.overlayPositions ? this.overlayPositions[overlay.id] : null;
        }
      }, {
        key: "_clazzManip",
        value: function _clazzManip(action, clazz) {
          for (var i in this.overlays) {
            if (action === ACTION_ADD) {
              this.instance.addOverlayClass(this.overlays[i], clazz);
            } else if (action === ACTION_REMOVE) {
              this.instance.removeOverlayClass(this.overlays[i], clazz);
            }
          }
        }
      }, {
        key: "addClass",
        value: function addClass(clazz, cascade) {
          var parts = (this.cssClass || "").split(" ");
          parts.push(clazz);
          this.cssClass = parts.join(" ");
          this._clazzManip(ACTION_ADD, clazz);
        }
      }, {
        key: "removeClass",
        value: function removeClass(clazz, cascade) {
          var parts = (this.cssClass || "").split(" ");
          this.cssClass = parts.filter(function (p) {
            return p !== clazz;
          }).join(" ");
          this._clazzManip(ACTION_REMOVE, clazz);
        }
      }, {
        key: "getClass",
        value: function getClass() {
          return this.cssClass;
        }
      }, {
        key: "shouldFireEvent",
        value: function shouldFireEvent(event, value, originalEvent) {
          return true;
        }
      }, {
        key: "getData",
        value: function getData() {
          return this.data;
        }
      }, {
        key: "setData",
        value: function setData(d) {
          this.data = d || {};
        }
      }, {
        key: "mergeData",
        value: function mergeData(d) {
          this.data = extend(this.data, d);
        }
      }, {
        key: "addOverlay",
        value: function addOverlay(overlay) {
          var o = _processOverlay(this, overlay);
          if (this.getData && o.type === LabelOverlay.type && !isString(overlay)) {
            var d = this.getData(),
                p = overlay.options;
            if (d) {
              var locationAttribute = p.labelLocationAttribute || LOCATION_ATTRIBUTE;
              var loc = d[locationAttribute];
              if (loc) {
                o.location = loc;
              }
            }
          }
          return o;
        }
      }, {
        key: "getOverlay",
        value: function getOverlay(id) {
          return this.overlays[id];
        }
      }, {
        key: "getOverlays",
        value: function getOverlays() {
          return this.overlays;
        }
      }, {
        key: "hideOverlay",
        value: function hideOverlay(id) {
          var o = this.getOverlay(id);
          if (o) {
            o.setVisible(false);
          }
        }
      }, {
        key: "hideOverlays",
        value: function hideOverlays() {
          for (var i in this.overlays) {
            this.overlays[i].setVisible(false);
          }
        }
      }, {
        key: "showOverlay",
        value: function showOverlay(id) {
          var o = this.getOverlay(id);
          if (o) {
            o.setVisible(true);
          }
        }
      }, {
        key: "showOverlays",
        value: function showOverlays() {
          for (var i in this.overlays) {
            this.overlays[i].setVisible(true);
          }
        }
      }, {
        key: "removeAllOverlays",
        value: function removeAllOverlays() {
          for (var i in this.overlays) {
            this.instance.destroyOverlay(this.overlays[i]);
          }
          this.overlays = {};
          this.overlayPositions = null;
          this.overlayPlacements = {};
        }
      }, {
        key: "removeOverlay",
        value: function removeOverlay(overlayId, dontCleanup) {
          var o = this.overlays[overlayId];
          if (o) {
            o.setVisible(false);
            if (!dontCleanup) {
              this.instance.destroyOverlay(o);
            }
            delete this.overlays[overlayId];
            if (this.overlayPositions) {
              delete this.overlayPositions[overlayId];
            }
            if (this.overlayPlacements) {
              delete this.overlayPlacements[overlayId];
            }
          }
        }
      }, {
        key: "removeOverlays",
        value: function removeOverlays() {
          for (var _len = arguments.length, overlays = new Array(_len), _key = 0; _key < _len; _key++) {
            overlays[_key] = arguments[_key];
          }
          for (var i = 0, j = overlays.length; i < j; i++) {
            this.removeOverlay(arguments[i]);
          }
        }
      }, {
        key: "getLabel",
        value: function getLabel() {
          var lo = this.getLabelOverlay();
          return lo != null ? lo.getLabel() : null;
        }
      }, {
        key: "getLabelOverlay",
        value: function getLabelOverlay() {
          return this.getOverlay(_internalLabelOverlayId);
        }
      }, {
        key: "setLabel",
        value: function setLabel(l) {
          var lo = this.getLabelOverlay();
          if (!lo) {
            var _params2 = isString(l) || isFunction(l) ? {
              label: l
            } : l;
            lo = _makeLabelOverlay(this, _params2);
            this.overlays[_internalLabelOverlayId] = lo;
          } else {
            if (isString(l) || isFunction(l)) {
              lo.setLabel(l);
            } else {
              var ll = l;
              if (ll.label) {
                lo.setLabel(ll.label);
              }
              if (ll.location) {
                lo.location = ll.location;
              }
            }
          }
        }
      }]);
      return Component;
    }(EventGenerator);

    var _opposites, _clockwiseOptions, _antiClockwiseOptions;
    var FaceValues;
    (function (FaceValues) {
      FaceValues["top"] = "top";
      FaceValues["left"] = "left";
      FaceValues["right"] = "right";
      FaceValues["bottom"] = "bottom";
    })(FaceValues || (FaceValues = {}));
    var TOP = FaceValues.top;
    var LEFT = FaceValues.left;
    var RIGHT = FaceValues.right;
    var BOTTOM = FaceValues.bottom;
    var X_AXIS_FACES = [LEFT, RIGHT];
    var Y_AXIS_FACES = [TOP, BOTTOM];
    var LightweightFloatingAnchor = function () {
      function LightweightFloatingAnchor(instance, element) {
        _classCallCheck$1(this, LightweightFloatingAnchor);
        this.instance = instance;
        this.element = element;
        _defineProperty$1(this, "isFloating", true);
        _defineProperty$1(this, "isContinuous", void 0);
        _defineProperty$1(this, "isDynamic", void 0);
        _defineProperty$1(this, "locations", [{
          x: 0.5,
          y: 0.5,
          ox: 0,
          oy: 0,
          offx: 0,
          offy: 0,
          iox: 0,
          ioy: 0,
          cls: ''
        }]);
        _defineProperty$1(this, "currentLocation", 0);
        _defineProperty$1(this, "locked", false);
        _defineProperty$1(this, "cssClass", '');
        _defineProperty$1(this, "timestamp", null);
        _defineProperty$1(this, "type", "Floating");
        _defineProperty$1(this, "id", uuid());
        _defineProperty$1(this, "orientation", [0, 0]);
        _defineProperty$1(this, "size", void 0);
        this.size = instance.getSize(element);
      }
      _createClass$1(LightweightFloatingAnchor, [{
        key: "_updateOrientationInRouter",
        value: function _updateOrientationInRouter() {
          this.instance.router.setAnchorOrientation(this, [this.locations[0].ox, this.locations[0].oy]);
        }
      }, {
        key: "over",
        value: function over(endpoint) {
          this.orientation = this.instance.router.getEndpointOrientation(endpoint);
          this.locations[0].ox = this.orientation[0];
          this.locations[0].oy = this.orientation[1];
          this._updateOrientationInRouter();
        }
      }, {
        key: "out",
        value: function out() {
          this.orientation = null;
          this.locations[0].ox = this.locations[0].iox;
          this.locations[0].oy = this.locations[0].ioy;
          this._updateOrientationInRouter();
        }
      }]);
      return LightweightFloatingAnchor;
    }();
    var opposites = (_opposites = {}, _defineProperty$1(_opposites, TOP, BOTTOM), _defineProperty$1(_opposites, RIGHT, LEFT), _defineProperty$1(_opposites, LEFT, RIGHT), _defineProperty$1(_opposites, BOTTOM, TOP), _opposites);
    var clockwiseOptions = (_clockwiseOptions = {}, _defineProperty$1(_clockwiseOptions, TOP, RIGHT), _defineProperty$1(_clockwiseOptions, RIGHT, BOTTOM), _defineProperty$1(_clockwiseOptions, LEFT, TOP), _defineProperty$1(_clockwiseOptions, BOTTOM, LEFT), _clockwiseOptions);
    var antiClockwiseOptions = (_antiClockwiseOptions = {}, _defineProperty$1(_antiClockwiseOptions, TOP, LEFT), _defineProperty$1(_antiClockwiseOptions, RIGHT, TOP), _defineProperty$1(_antiClockwiseOptions, LEFT, BOTTOM), _defineProperty$1(_antiClockwiseOptions, BOTTOM, RIGHT), _antiClockwiseOptions);
    function getDefaultFace(a) {
      return a.faces.length === 0 ? TOP : a.faces[0];
    }
    function _isFaceAvailable(a, face) {
      return a.faces.indexOf(face) !== -1;
    }
    function _secondBest(a, edge) {
      return (a.clockwise ? clockwiseOptions : antiClockwiseOptions)[edge];
    }
    function _lastChoice(a, edge) {
      return (a.clockwise ? antiClockwiseOptions : clockwiseOptions)[edge];
    }
    function isEdgeSupported(a, edge) {
      return a.lockedAxis == null ? a.lockedFace == null ? _isFaceAvailable(a, edge) === true : a.lockedFace === edge : a.lockedAxis.indexOf(edge) !== -1;
    }
    function verifyFace(a, edge) {
      if (_isFaceAvailable(a, edge)) {
        return edge;
      } else if (_isFaceAvailable(a, opposites[edge])) {
        return opposites[edge];
      } else {
        var secondBest = _secondBest(a, edge);
        if (_isFaceAvailable(a, secondBest)) {
          return secondBest;
        } else {
          var lastChoice = _lastChoice(a, edge);
          if (_isFaceAvailable(a, lastChoice)) {
            return lastChoice;
          }
        }
      }
      return edge;
    }
    var _top = {
      x: 0.5,
      y: 0,
      ox: 0,
      oy: -1,
      offx: 0,
      offy: 0
    },
        _bottom = {
      x: 0.5,
      y: 1,
      ox: 0,
      oy: 1,
      offx: 0,
      offy: 0
    },
        _left = {
      x: 0,
      y: 0.5,
      ox: -1,
      oy: 0,
      offx: 0,
      offy: 0
    },
        _right = {
      x: 1,
      y: 0.5,
      ox: 1,
      oy: 0,
      offx: 0,
      offy: 0
    },
        _topLeft = {
      x: 0,
      y: 0,
      ox: 0,
      oy: -1,
      offx: 0,
      offy: 0
    },
        _topRight = {
      x: 1,
      y: 0,
      ox: 1,
      oy: -1,
      offx: 0,
      offy: 0
    },
        _bottomLeft = {
      x: 0,
      y: 1,
      ox: 0,
      oy: 1,
      offx: 0,
      offy: 0
    },
        _bottomRight = {
      x: 1,
      y: 1,
      ox: 0,
      oy: 1,
      offx: 0,
      offy: 0
    },
        _center = {
      x: 0.5,
      y: 0.5,
      ox: 0,
      oy: 0,
      offx: 0,
      offy: 0
    };
    var namedValues = {
      "Top": [_top],
      "Bottom": [_bottom],
      "Left": [_left],
      "Right": [_right],
      "TopLeft": [_topLeft],
      "TopRight": [_topRight],
      "BottomLeft": [_bottomLeft],
      "BottomRight": [_bottomRight],
      "Center": [_center],
      "AutoDefault": [_top, _left, _bottom, _right]
    };
    var namedContinuousValues = {
      "Continuous": {
        faces: [TOP, LEFT, BOTTOM, RIGHT]
      },
      "ContinuousTop": {
        faces: [TOP]
      },
      "ContinuousRight": {
        faces: [RIGHT]
      },
      "ContinuousBottom": {
        faces: [BOTTOM]
      },
      "ContinuousLeft": {
        faces: [LEFT]
      },
      "ContinuousLeftRight": {
        faces: [LEFT, RIGHT]
      },
      "ContinuousTopBottom": {
        faces: [TOP, BOTTOM]
      }
    };
    function getNamedAnchor(name, params) {
      params = params || {};
      if (name === AnchorLocations.Perimeter) {
        return _createPerimeterAnchor(params);
      }
      var a = namedValues[name];
      if (a != null) {
        return _createAnchor(name, map(a, function (_a) {
          return extend({
            iox: _a.ox,
            ioy: _a.oy
          }, _a);
        }), params);
      }
      a = namedContinuousValues[name];
      if (a != null) {
        return _createContinuousAnchor(name, a.faces, params);
      }
      throw {
        message: "jsPlumb: unknown anchor type '" + name + "'"
      };
    }
    function _createAnchor(type, locations, params) {
      return {
        type: type,
        locations: locations,
        currentLocation: 0,
        locked: false,
        id: uuid(),
        isFloating: false,
        isContinuous: false,
        isDynamic: locations.length > 1,
        timestamp: null,
        cssClass: params.cssClass || ""
      };
    }
    function createFloatingAnchor(instance, element) {
      return new LightweightFloatingAnchor(instance, element);
    }
    var PROPERTY_CURRENT_FACE = "currentFace";
    function _createContinuousAnchor(type, faces, params) {
      var ca = {
        type: type,
        locations: [],
        currentLocation: 0,
        locked: false,
        id: uuid(),
        cssClass: params.cssClass || "",
        isFloating: false,
        isContinuous: true,
        timestamp: null,
        faces: params.faces || faces,
        lockedFace: null,
        lockedAxis: null,
        clockwise: !(params.clockwise === false),
        __currentFace: null
      };
      Object.defineProperty(ca, PROPERTY_CURRENT_FACE, {
        get: function get() {
          return this.__currentFace;
        },
        set: function set(f) {
          this.__currentFace = verifyFace(this, f);
        }
      });
      return ca;
    }
    function isPrimitiveAnchorSpec(sa) {
      return sa.length < 7 && sa.every(isNumber) || sa.length === 7 && sa.slice(0, 5).every(isNumber) && isString(sa[6]);
    }
    function makeLightweightAnchorFromSpec(spec) {
      if (isString(spec)) {
        return getNamedAnchor(spec, null);
      } else if (Array.isArray(spec)) {
        if (isPrimitiveAnchorSpec(spec)) {
          var _spec = spec;
          return _createAnchor(null, [{
            x: _spec[0],
            y: _spec[1],
            ox: _spec[2],
            oy: _spec[3],
            offx: _spec[4] == null ? 0 : _spec[4],
            offy: _spec[5] == null ? 0 : _spec[5],
            iox: _spec[2],
            ioy: _spec[3],
            cls: _spec[6] || ""
          }], {
            cssClass: _spec[6] || ""
          });
        } else {
          var locations = map(spec, function (aSpec) {
            if (isString(aSpec)) {
              var a = namedValues[aSpec];
              return a != null ? extend({
                iox: a[0].ox,
                ioy: a[0].oy,
                cls: ""
              }, a[0]) : null;
            } else if (isPrimitiveAnchorSpec(aSpec)) {
              return {
                x: aSpec[0],
                y: aSpec[1],
                ox: aSpec[2],
                oy: aSpec[3],
                offx: aSpec[4] == null ? 0 : aSpec[4],
                offy: aSpec[5] == null ? 0 : aSpec[5],
                iox: aSpec[2],
                ioy: aSpec[3],
                cls: aSpec[6] || ""
              };
            }
          }).filter(function (ar) {
            return ar != null;
          });
          return _createAnchor("Dynamic", locations, {});
        }
      } else {
        var sa = spec;
        return getNamedAnchor(sa.type, sa.options);
      }
    }
    function circleGenerator(anchorCount) {
      var r = 0.5,
          step = Math.PI * 2 / anchorCount,
          a = [];
      var current = 0;
      for (var i = 0; i < anchorCount; i++) {
        var x = r + r * Math.sin(current),
            y = r + r * Math.cos(current);
        a.push({
          x: x,
          y: y,
          ox: 0,
          oy: 0,
          offx: 0,
          offy: 0,
          iox: 0,
          ioy: 0,
          cls: ''
        });
        current += step;
      }
      return a;
    }
    function _path(segments, anchorCount) {
      var anchorsPerFace = anchorCount / segments.length,
          a = [],
          _computeFace = function _computeFace(x1, y1, x2, y2, fractionalLength, ox, oy) {
        anchorsPerFace = anchorCount * fractionalLength;
        var dx = (x2 - x1) / anchorsPerFace,
            dy = (y2 - y1) / anchorsPerFace;
        for (var i = 0; i < anchorsPerFace; i++) {
          a.push({
            x: x1 + dx * i,
            y: y1 + dy * i,
            ox: ox == null ? 0 : ox,
            oy: oy == null ? 0 : oy,
            offx: 0,
            offy: 0,
            iox: 0,
            ioy: 0,
            cls: ''
          });
        }
      };
      for (var i = 0; i < segments.length; i++) {
        _computeFace.apply(null, segments[i]);
      }
      return a;
    }
    function shapeGenerator(faces, anchorCount) {
      var s = [];
      for (var i = 0; i < faces.length; i++) {
        s.push([faces[i][0], faces[i][1], faces[i][2], faces[i][3], 1 / faces.length, faces[i][4], faces[i][5]]);
      }
      return _path(s, anchorCount);
    }
    function rectangleGenerator(anchorCount) {
      return shapeGenerator([[0, 0, 1, 0, 0, -1], [1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 1, 0, 0, -1, 0]], anchorCount);
    }
    function diamondGenerator(anchorCount) {
      return shapeGenerator([[0.5, 0, 1, 0.5], [1, 0.5, 0.5, 1], [0.5, 1, 0, 0.5], [0, 0.5, 0.5, 0]], anchorCount);
    }
    function triangleGenerator(anchorCount) {
      return shapeGenerator([[0.5, 0, 1, 1], [1, 1, 0, 1], [0, 1, 0.5, 0]], anchorCount);
    }
    function rotate$1(points, amountInDegrees) {
      var o = [],
          theta = amountInDegrees / 180 * Math.PI;
      for (var i = 0; i < points.length; i++) {
        var _x = points[i].x - 0.5,
            _y = points[i].y - 0.5;
        o.push({
          x: 0.5 + (_x * Math.cos(theta) - _y * Math.sin(theta)),
          y: 0.5 + (_x * Math.sin(theta) + _y * Math.cos(theta)),
          ox: points[i].ox,
          oy: points[i].oy,
          offx: 0,
          offy: 0,
          iox: 0,
          ioy: 0,
          cls: ''
        });
      }
      return o;
    }
    var anchorGenerators = new Map();
    anchorGenerators.set(PerimeterAnchorShapes.Circle, circleGenerator);
    anchorGenerators.set(PerimeterAnchorShapes.Ellipse, circleGenerator);
    anchorGenerators.set(PerimeterAnchorShapes.Rectangle, rectangleGenerator);
    anchorGenerators.set(PerimeterAnchorShapes.Square, rectangleGenerator);
    anchorGenerators.set(PerimeterAnchorShapes.Diamond, diamondGenerator);
    anchorGenerators.set(PerimeterAnchorShapes.Triangle, triangleGenerator);
    function _createPerimeterAnchor(params) {
      params = params || {};
      var anchorCount = params.anchorCount || 60,
          shape = params.shape;
      if (!shape) {
        throw new Error("no shape supplied to Perimeter Anchor type");
      }
      if (!anchorGenerators.has(shape)) {
        throw new Error("Shape [" + shape + "] is unknown by Perimeter Anchor type");
      }
      var da = anchorGenerators.get(shape)(anchorCount);
      if (params.rotation) {
        da = rotate$1(da, params.rotation);
      }
      var a = _createAnchor(AnchorLocations.Perimeter, da, params);
      var aa = extend(a, {
        shape: shape
      });
      return aa;
    }

    var TYPE_ITEM_ANCHORS = "anchors";
    var TYPE_ITEM_CONNECTOR = "connector";
    function prepareEndpoint(conn, existing, index, anchor, element, elementId, endpoint) {
      var e;
      if (existing) {
        conn.endpoints[index] = existing;
        existing.addConnection(conn);
      } else {
        var ep = endpoint || conn.endpointSpec || conn.endpointsSpec[index] || conn.instance.defaults.endpoints[index] || conn.instance.defaults.endpoint;
        var es = conn.endpointStyles[index] || conn.endpointStyle || conn.instance.defaults.endpointStyles[index] || conn.instance.defaults.endpointStyle;
        if (es.fill == null && conn.paintStyle != null) {
          es.fill = conn.paintStyle.stroke;
        }
        if (es.outlineStroke == null && conn.paintStyle != null) {
          es.outlineStroke = conn.paintStyle.outlineStroke;
        }
        if (es.outlineWidth == null && conn.paintStyle != null) {
          es.outlineWidth = conn.paintStyle.outlineWidth;
        }
        var ehs = conn.endpointHoverStyles[index] || conn.endpointHoverStyle || conn.endpointHoverStyle || conn.instance.defaults.endpointHoverStyles[index] || conn.instance.defaults.endpointHoverStyle;
        if (conn.hoverPaintStyle != null) {
          if (ehs == null) {
            ehs = {};
          }
          if (ehs.fill == null) {
            ehs.fill = conn.hoverPaintStyle.stroke;
          }
        }
        var u = conn.uuids ? conn.uuids[index] : null;
        anchor = anchor != null ? anchor : conn.instance.defaults.anchors != null ? conn.instance.defaults.anchors[index] : conn.instance.defaults.anchor;
        e = conn.instance._internal_newEndpoint({
          paintStyle: es,
          hoverPaintStyle: ehs,
          endpoint: ep,
          connections: [conn],
          uuid: u,
          element: element,
          scope: conn.scope,
          anchor: anchor,
          reattachConnections: conn.reattach || conn.instance.defaults.reattachConnections,
          connectionsDetachable: conn.detachable || conn.instance.defaults.connectionsDetachable
        });
        if (existing == null) {
          e.deleteOnEmpty = true;
        }
        conn.endpoints[index] = e;
      }
      return e;
    }
    var Connection = function (_Component) {
      _inherits$1(Connection, _Component);
      var _super = _createSuper$1(Connection);
      function Connection(instance, params) {
        var _this;
        _classCallCheck$1(this, Connection);
        _this = _super.call(this, instance, params);
        _this.instance = instance;
        _defineProperty$1(_assertThisInitialized$1(_this), "connector", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "defaultLabelLocation", 0.5);
        _defineProperty$1(_assertThisInitialized$1(_this), "scope", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "typeId", "_jsplumb_connection");
        _defineProperty$1(_assertThisInitialized$1(_this), "previousConnection", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "sourceId", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "targetId", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "source", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "target", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "detachable", true);
        _defineProperty$1(_assertThisInitialized$1(_this), "reattach", false);
        _defineProperty$1(_assertThisInitialized$1(_this), "uuids", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "cost", 1);
        _defineProperty$1(_assertThisInitialized$1(_this), "directed", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "endpoints", [null, null]);
        _defineProperty$1(_assertThisInitialized$1(_this), "endpointStyles", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "endpointSpec", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "endpointsSpec", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "endpointStyle", {});
        _defineProperty$1(_assertThisInitialized$1(_this), "endpointHoverStyle", {});
        _defineProperty$1(_assertThisInitialized$1(_this), "endpointHoverStyles", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "suspendedEndpoint", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "suspendedIndex", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "suspendedElement", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "suspendedElementId", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "suspendedElementType", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "_forceReattach", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "_forceDetach", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "proxies", []);
        _defineProperty$1(_assertThisInitialized$1(_this), "pending", false);
        _this.id = params.id;
        _this.previousConnection = params.previousConnection;
        _this.source = params.source;
        _this.target = params.target;
        if (params.sourceEndpoint) {
          _this.source = params.sourceEndpoint.element;
          _this.sourceId = params.sourceEndpoint.elementId;
        } else {
          _this.sourceId = instance.getId(_this.source);
        }
        if (params.targetEndpoint) {
          _this.target = params.targetEndpoint.element;
          _this.targetId = params.targetEndpoint.elementId;
        } else {
          _this.targetId = instance.getId(_this.target);
        }
        _this.scope = params.scope;
        var sourceAnchor = params.anchors ? params.anchors[0] : params.anchor;
        var targetAnchor = params.anchors ? params.anchors[1] : params.anchor;
        instance.manage(_this.source);
        instance.manage(_this.target);
        _this.visible = true;
        _this.params = {
          cssClass: params.cssClass,
          hoverClass: params.hoverClass,
          "pointer-events": params["pointer-events"],
          overlays: params.overlays
        };
        _this.lastPaintedAt = null;
        if (params.type) {
          params.endpoints = params.endpoints || _this.instance._deriveEndpointAndAnchorSpec(params.type).endpoints;
        }
        _this.endpointSpec = params.endpoint;
        _this.endpointsSpec = params.endpoints || [null, null];
        _this.endpointStyle = params.endpointStyle;
        _this.endpointHoverStyle = params.endpointHoverStyle;
        _this.endpointStyles = params.endpointStyles || [null, null];
        _this.endpointHoverStyles = params.endpointHoverStyles || [null, null];
        _this.paintStyle = params.paintStyle;
        _this.hoverPaintStyle = params.hoverPaintStyle;
        _this.uuids = params.uuids;
        _this.makeEndpoint(true, _this.source, _this.sourceId, sourceAnchor, params.sourceEndpoint);
        _this.makeEndpoint(false, _this.target, _this.targetId, targetAnchor, params.targetEndpoint);
        if (!_this.scope) {
          _this.scope = _this.endpoints[0].scope;
        }
        if (params.deleteEndpointsOnEmpty != null) {
          _this.endpoints[0].deleteOnEmpty = params.deleteEndpointsOnEmpty;
          _this.endpoints[1].deleteOnEmpty = params.deleteEndpointsOnEmpty;
        }
        var _detachable = _this.instance.defaults.connectionsDetachable;
        if (params.detachable === false) {
          _detachable = false;
        }
        if (_this.endpoints[0].connectionsDetachable === false) {
          _detachable = false;
        }
        if (_this.endpoints[1].connectionsDetachable === false) {
          _detachable = false;
        }
        _this.endpointsSpec = params.endpoints || [null, null];
        _this.endpointSpec = params.endpoint || null;
        var _reattach = params.reattach || _this.endpoints[0].reattachConnections || _this.endpoints[1].reattachConnections || _this.instance.defaults.reattachConnections;
        _this.appendToDefaultType({
          detachable: _detachable,
          reattach: _reattach,
          paintStyle: _this.endpoints[0].connectorStyle || _this.endpoints[1].connectorStyle || params.paintStyle || _this.instance.defaults.paintStyle,
          hoverPaintStyle: _this.endpoints[0].connectorHoverStyle || _this.endpoints[1].connectorHoverStyle || params.hoverPaintStyle || _this.instance.defaults.hoverPaintStyle
        });
        if (!_this.instance._suspendDrawing) {
          var initialTimestamp = _this.instance._suspendedAt || uuid();
          _this.instance.paintEndpoint(_this.endpoints[0], {
            timestamp: initialTimestamp
          });
          _this.instance.paintEndpoint(_this.endpoints[1], {
            timestamp: initialTimestamp
          });
        }
        _this.cost = params.cost || _this.endpoints[0].connectionCost;
        _this.directed = params.directed;
        if (params.directed == null) {
          _this.directed = _this.endpoints[0].connectionsDirected;
        }
        var _p = extend({}, _this.endpoints[1].parameters);
        extend(_p, _this.endpoints[0].parameters);
        extend(_p, _this.parameters);
        _this.parameters = _p;
        _this.paintStyleInUse = _this.getPaintStyle() || {};
        _this.setConnector(_this.endpoints[0].connector || _this.endpoints[1].connector || params.connector || _this.instance.defaults.connector, true);
        var data = params.data == null || !isObject(params.data) ? {} : params.data;
        _this.setData(data);
        var _types = [DEFAULT, _this.endpoints[0].edgeType, _this.endpoints[1].edgeType, params.type].join(" ");
        if (/[^\s]/.test(_types)) {
          _this.addType(_types, params.data);
        }
        return _this;
      }
      _createClass$1(Connection, [{
        key: "getIdPrefix",
        value: function getIdPrefix() {
          return "_jsPlumb_c";
        }
      }, {
        key: "getDefaultOverlayKey",
        value: function getDefaultOverlayKey() {
          return KEY_CONNECTION_OVERLAYS;
        }
      }, {
        key: "getXY",
        value: function getXY() {
          return {
            x: this.connector.x,
            y: this.connector.y
          };
        }
      }, {
        key: "makeEndpoint",
        value: function makeEndpoint(isSource, el, elId, anchor, ep) {
          elId = elId || this.instance.getId(el);
          return prepareEndpoint(this, ep, isSource ? 0 : 1, anchor, el);
        }
      }, {
        key: "getTypeDescriptor",
        value: function getTypeDescriptor() {
          return Connection.type;
        }
      }, {
        key: "isDetachable",
        value: function isDetachable(ep) {
          return this.detachable === false ? false : ep != null ? ep.connectionsDetachable === true : this.detachable === true;
        }
      }, {
        key: "setDetachable",
        value: function setDetachable(detachable) {
          this.detachable = detachable === true;
        }
      }, {
        key: "isReattach",
        value: function isReattach() {
          return this.reattach === true || this.endpoints[0].reattachConnections === true || this.endpoints[1].reattachConnections === true;
        }
      }, {
        key: "setReattach",
        value: function setReattach(reattach) {
          this.reattach = reattach === true;
        }
      }, {
        key: "applyType",
        value: function applyType(t, typeMap) {
          var _connector = null;
          if (t.connector != null) {
            _connector = this.getCachedTypeItem(TYPE_ITEM_CONNECTOR, typeMap.connector);
            if (_connector == null) {
              _connector = this.prepareConnector(t.connector, typeMap.connector);
              this.cacheTypeItem(TYPE_ITEM_CONNECTOR, _connector, typeMap.connector);
            }
            this.setPreparedConnector(_connector);
          }
          _get$1(_getPrototypeOf$1(Connection.prototype), "applyType", this).call(this, t, typeMap);
          if (t.detachable != null) {
            this.setDetachable(t.detachable);
          }
          if (t.reattach != null) {
            this.setReattach(t.reattach);
          }
          if (t.scope) {
            this.scope = t.scope;
          }
          var _anchors = null;
          if (t.anchor) {
            _anchors = this.getCachedTypeItem(TYPE_ITEM_ANCHORS, typeMap.anchor);
            if (_anchors == null) {
              _anchors = [makeLightweightAnchorFromSpec(t.anchor), makeLightweightAnchorFromSpec(t.anchor)];
              this.cacheTypeItem(TYPE_ITEM_ANCHORS, _anchors, typeMap.anchor);
            }
          } else if (t.anchors) {
            _anchors = this.getCachedTypeItem(TYPE_ITEM_ANCHORS, typeMap.anchors);
            if (_anchors == null) {
              _anchors = [makeLightweightAnchorFromSpec(t.anchors[0]), makeLightweightAnchorFromSpec(t.anchors[1])];
              this.cacheTypeItem(TYPE_ITEM_ANCHORS, _anchors, typeMap.anchors);
            }
          }
          if (_anchors != null) {
            this.instance.router.setConnectionAnchors(this, _anchors);
            if (this.instance.router.isDynamicAnchor(this.endpoints[1])) {
              this.instance.repaint(this.endpoints[1].element);
            }
          }
          this.instance.applyConnectorType(this.connector, t);
        }
      }, {
        key: "addClass",
        value: function addClass(c, cascade) {
          _get$1(_getPrototypeOf$1(Connection.prototype), "addClass", this).call(this, c);
          if (cascade) {
            this.endpoints[0].addClass(c);
            this.endpoints[1].addClass(c);
            if (this.suspendedEndpoint) {
              this.suspendedEndpoint.addClass(c);
            }
          }
          if (this.connector) {
            this.instance.addConnectorClass(this.connector, c);
          }
        }
      }, {
        key: "removeClass",
        value: function removeClass(c, cascade) {
          _get$1(_getPrototypeOf$1(Connection.prototype), "removeClass", this).call(this, c);
          if (cascade) {
            this.endpoints[0].removeClass(c);
            this.endpoints[1].removeClass(c);
            if (this.suspendedEndpoint) {
              this.suspendedEndpoint.removeClass(c);
            }
          }
          if (this.connector) {
            this.instance.removeConnectorClass(this.connector, c);
          }
        }
      }, {
        key: "setVisible",
        value: function setVisible(v) {
          _get$1(_getPrototypeOf$1(Connection.prototype), "setVisible", this).call(this, v);
          if (this.connector) {
            this.instance.setConnectorVisible(this.connector, v);
          }
          this.instance.paintConnection(this);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get$1(_getPrototypeOf$1(Connection.prototype), "destroy", this).call(this);
          this.endpoints = null;
          this.endpointStyles = null;
          this.source = null;
          this.target = null;
          this.instance.destroyConnector(this);
          this.connector = null;
          this.deleted = true;
        }
      }, {
        key: "getUuids",
        value: function getUuids() {
          return [this.endpoints[0].getUuid(), this.endpoints[1].getUuid()];
        }
      }, {
        key: "prepareConnector",
        value: function prepareConnector(connectorSpec, typeId) {
          var connectorArgs = {
            cssClass: this.params.cssClass,
            hoverClass: this.params.hoverClass,
            "pointer-events": this.params["pointer-events"]
          },
              connector;
          if (isString(connectorSpec)) {
            connector = this.instance.makeConnector(this, connectorSpec, connectorArgs);
          } else {
            var co = connectorSpec;
            connector = this.instance.makeConnector(this, co.type, merge(co.options, connectorArgs));
          }
          if (typeId != null) {
            connector.typeId = typeId;
          }
          return connector;
        }
      }, {
        key: "setPreparedConnector",
        value: function setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId) {
          if (this.connector !== connector) {
            var previous,
                previousClasses = "";
            if (this.connector != null) {
              previous = this.connector;
              previousClasses = this.instance.getConnectorClass(this.connector);
              this.instance.destroyConnector(this);
            }
            this.connector = connector;
            if (typeId) {
              this.cacheTypeItem(TYPE_ITEM_CONNECTOR, connector, typeId);
            }
            this.addClass(previousClasses);
            if (previous != null) {
              var o = this.getOverlays();
              for (var i in o) {
                this.instance.reattachOverlay(o[i], this);
              }
            }
            if (!doNotRepaint) {
              this.instance.paintConnection(this);
            }
          }
        }
      }, {
        key: "setConnector",
        value: function setConnector(connectorSpec, doNotRepaint, doNotChangeListenerComponent, typeId) {
          var connector = this.prepareConnector(connectorSpec, typeId);
          this.setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId);
        }
      }, {
        key: "replaceEndpoint",
        value: function replaceEndpoint(idx, endpointDef) {
          var current = this.endpoints[idx],
              elId = current.elementId,
              ebe = this.instance.getEndpoints(current.element),
              _idx = ebe.indexOf(current),
              _new = prepareEndpoint(this, null, idx, null, current.element, elId, endpointDef);
          this.endpoints[idx] = _new;
          ebe.splice(_idx, 1, _new);
          current.detachFromConnection(this);
          this.instance.deleteEndpoint(current);
          this.instance.fire(EVENT_ENDPOINT_REPLACED, {
            previous: current,
            current: _new
          });
        }
      }]);
      return Connection;
    }(Component);
    _defineProperty$1(Connection, "type", "connection");

    var typeParameters = ["connectorStyle", "connectorHoverStyle", "connectorOverlays", "connector", "connectionType", "connectorClass", "connectorHoverClass"];
    var Endpoint = function (_Component) {
      _inherits$1(Endpoint, _Component);
      var _super = _createSuper$1(Endpoint);
      function Endpoint(instance, params) {
        var _this;
        _classCallCheck$1(this, Endpoint);
        _this = _super.call(this, instance, params);
        _this.instance = instance;
        _defineProperty$1(_assertThisInitialized$1(_this), "connections", []);
        _defineProperty$1(_assertThisInitialized$1(_this), "endpoint", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "element", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "elementId", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "dragAllowedWhenFull", true);
        _defineProperty$1(_assertThisInitialized$1(_this), "timestamp", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "portId", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "maxConnections", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "proxiedBy", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "connectorClass", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "connectorHoverClass", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "finalEndpoint", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "enabled", true);
        _defineProperty$1(_assertThisInitialized$1(_this), "isSource", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "isTarget", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "isTemporarySource", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "connectionCost", 1);
        _defineProperty$1(_assertThisInitialized$1(_this), "connectionsDirected", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "connectionsDetachable", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "reattachConnections", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "currentAnchorClass", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "referenceEndpoint", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "edgeType", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "connector", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "connectorOverlays", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "connectorStyle", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "connectorHoverStyle", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "deleteOnEmpty", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "uuid", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "scope", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "_anchor", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "defaultLabelLocation", [0.5, 0.5]);
        _this.appendToDefaultType({
          edgeType: params.edgeType,
          maxConnections: params.maxConnections == null ? _this.instance.defaults.maxConnections : params.maxConnections,
          paintStyle: params.paintStyle || _this.instance.defaults.endpointStyle,
          hoverPaintStyle: params.hoverPaintStyle || _this.instance.defaults.endpointHoverStyle,
          connectorStyle: params.connectorStyle,
          connectorHoverStyle: params.connectorHoverStyle,
          connectorClass: params.connectorClass,
          connectorHoverClass: params.connectorHoverClass,
          connectorOverlays: params.connectorOverlays,
          connector: params.connector
        });
        _this.enabled = !(params.enabled === false);
        _this.visible = true;
        _this.element = params.element;
        _this.uuid = params.uuid;
        _this.portId = params.portId;
        _this.elementId = params.elementId;
        _this.connectionCost = params.connectionCost == null ? 1 : params.connectionCost;
        _this.connectionsDirected = params.connectionsDirected;
        _this.currentAnchorClass = "";
        _this.events = {};
        _this.connectorOverlays = params.connectorOverlays;
        _this.connectorStyle = params.connectorStyle;
        _this.connectorHoverStyle = params.connectorHoverStyle;
        _this.connector = params.connector;
        _this.edgeType = params.edgeType;
        _this.connectorClass = params.connectorClass;
        _this.connectorHoverClass = params.connectorHoverClass;
        _this.deleteOnEmpty = params.deleteOnEmpty === true;
        _this.isSource = params.source || false;
        _this.isTemporarySource = params.isTemporarySource || false;
        _this.isTarget = params.target || false;
        _this.connections = params.connections || [];
        _this.scope = params.scope || instance.defaultScope;
        _this.timestamp = null;
        _this.reattachConnections = params.reattachConnections || instance.defaults.reattachConnections;
        _this.connectionsDetachable = instance.defaults.connectionsDetachable;
        if (params.connectionsDetachable === false) {
          _this.connectionsDetachable = false;
        }
        _this.dragAllowedWhenFull = params.dragAllowedWhenFull !== false;
        if (params.onMaxConnections) {
          _this.bind(EVENT_MAX_CONNECTIONS, params.onMaxConnections);
        }
        var ep = params.endpoint || params.existingEndpoint || instance.defaults.endpoint;
        _this.setEndpoint(ep);
        if (params.preparedAnchor != null) {
          _this.setPreparedAnchor(params.preparedAnchor);
        } else {
          var anchorParamsToUse = params.anchor ? params.anchor : params.anchors ? params.anchors : instance.defaults.anchor || AnchorLocations.Top;
          _this.setAnchor(anchorParamsToUse);
        }
        var type = [DEFAULT, params.type || ""].join(" ");
        _this.addType(type, params.data);
        return _this;
      }
      _createClass$1(Endpoint, [{
        key: "getIdPrefix",
        value: function getIdPrefix() {
          return "_jsplumb_e";
        }
      }, {
        key: "getTypeDescriptor",
        value: function getTypeDescriptor() {
          return "endpoint";
        }
      }, {
        key: "getXY",
        value: function getXY() {
          return {
            x: this.endpoint.x,
            y: this.endpoint.y
          };
        }
      }, {
        key: "getDefaultOverlayKey",
        value: function getDefaultOverlayKey() {
          return "endpointOverlays";
        }
      }, {
        key: "_updateAnchorClass",
        value: function _updateAnchorClass() {
          var ac = this._anchor && this._anchor.cssClass;
          if (ac != null && ac.length > 0) {
            var oldAnchorClass = this.instance.endpointAnchorClassPrefix + "-" + this.currentAnchorClass;
            this.currentAnchorClass = ac;
            var anchorClass = this.instance.endpointAnchorClassPrefix + (this.currentAnchorClass ? "-" + this.currentAnchorClass : "");
            if (oldAnchorClass !== anchorClass) {
              this.removeClass(oldAnchorClass);
              this.addClass(anchorClass);
              this.instance.removeClass(this.element, oldAnchorClass);
              this.instance.addClass(this.element, anchorClass);
            }
          }
        }
      }, {
        key: "setPreparedAnchor",
        value: function setPreparedAnchor(anchor) {
          this.instance.router.setAnchor(this, anchor);
          this._updateAnchorClass();
          return this;
        }
      }, {
        key: "_anchorLocationChanged",
        value: function _anchorLocationChanged(currentAnchor) {
          this.fire(EVENT_ANCHOR_CHANGED, {
            endpoint: this,
            anchor: currentAnchor
          });
          this._updateAnchorClass();
        }
      }, {
        key: "setAnchor",
        value: function setAnchor(anchorParams) {
          var a = this.instance.router.prepareAnchor(this, anchorParams);
          this.setPreparedAnchor(a);
          return this;
        }
      }, {
        key: "addConnection",
        value: function addConnection(conn) {
          var wasFull = this.isFull();
          var wasEmpty = this.connections.length === 0;
          this.connections.push(conn);
          if (wasEmpty) {
            this.addClass(this.instance.endpointConnectedClass);
          }
          if (this.isFull()) {
            if (!wasFull) {
              this.addClass(this.instance.endpointFullClass);
            }
          } else if (wasFull) {
            this.removeClass(this.instance.endpointFullClass);
          }
        }
      }, {
        key: "detachFromConnection",
        value: function detachFromConnection(connection, idx, transientDetach) {
          idx = idx == null ? this.connections.indexOf(connection) : idx;
          if (idx >= 0) {
            this.connections.splice(idx, 1);
            this.instance.refreshEndpoint(this);
          }
          if (!transientDetach && this.deleteOnEmpty && this.connections.length === 0) {
            this.instance.deleteEndpoint(this);
          }
        }
      }, {
        key: "deleteEveryConnection",
        value: function deleteEveryConnection(params) {
          var c = this.connections.length;
          for (var i = 0; i < c; i++) {
            this.instance.deleteConnection(this.connections[0], params);
          }
        }
      }, {
        key: "detachFrom",
        value: function detachFrom(otherEndpoint) {
          var c = [];
          for (var i = 0; i < this.connections.length; i++) {
            if (this.connections[i].endpoints[1] === otherEndpoint || this.connections[i].endpoints[0] === otherEndpoint) {
              c.push(this.connections[i]);
            }
          }
          for (var j = 0, count = c.length; j < count; j++) {
            this.instance.deleteConnection(c[0]);
          }
          return this;
        }
      }, {
        key: "setVisible",
        value: function setVisible(v, doNotChangeConnections, doNotNotifyOtherEndpoint) {
          _get$1(_getPrototypeOf$1(Endpoint.prototype), "setVisible", this).call(this, v);
          this.endpoint.setVisible(v);
          if (v) {
            this.showOverlays();
          } else {
            this.hideOverlays();
          }
          if (!doNotChangeConnections) {
            for (var i = 0; i < this.connections.length; i++) {
              this.connections[i].setVisible(v);
              if (!doNotNotifyOtherEndpoint) {
                var oIdx = this === this.connections[i].endpoints[0] ? 1 : 0;
                if (this.connections[i].endpoints[oIdx].connections.length === 1) {
                  this.connections[i].endpoints[oIdx].setVisible(v, true, true);
                }
              }
            }
          }
        }
      }, {
        key: "applyType",
        value: function applyType(t, typeMap) {
          _get$1(_getPrototypeOf$1(Endpoint.prototype), "applyType", this).call(this, t, typeMap);
          this.setPaintStyle(t.endpointStyle || t.paintStyle);
          this.setHoverPaintStyle(t.endpointHoverStyle || t.hoverPaintStyle);
          this.connectorStyle = t.connectorStyle;
          this.connectorHoverStyle = t.connectorHoverStyle;
          this.connector = t.connector;
          this.connectorOverlays = t.connectorOverlays;
          this.edgeType = t.edgeType;
          if (t.maxConnections != null) {
            this.maxConnections = t.maxConnections;
          }
          if (t.scope) {
            this.scope = t.scope;
          }
          extend(t, typeParameters);
          this.instance.applyEndpointType(this, t);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get$1(_getPrototypeOf$1(Endpoint.prototype), "destroy", this).call(this);
          if (this.endpoint != null) {
            this.instance.destroyEndpoint(this);
          }
        }
      }, {
        key: "isFull",
        value: function isFull() {
          return this.maxConnections === 0 ? true : !(this.isFloating() || this.maxConnections < 0 || this.connections.length < this.maxConnections);
        }
      }, {
        key: "isFloating",
        value: function isFloating() {
          return this.instance.router.isFloating(this);
        }
      }, {
        key: "isConnectedTo",
        value: function isConnectedTo(otherEndpoint) {
          var found = false;
          if (otherEndpoint) {
            for (var i = 0; i < this.connections.length; i++) {
              if (this.connections[i].endpoints[1] === otherEndpoint || this.connections[i].endpoints[0] === otherEndpoint) {
                found = true;
                break;
              }
            }
          }
          return found;
        }
      }, {
        key: "setDragAllowedWhenFull",
        value: function setDragAllowedWhenFull(allowed) {
          this.dragAllowedWhenFull = allowed;
        }
      }, {
        key: "getUuid",
        value: function getUuid() {
          return this.uuid;
        }
      }, {
        key: "connectorSelector",
        value: function connectorSelector() {
          return this.connections[0];
        }
      }, {
        key: "prepareEndpoint",
        value: function prepareEndpoint(ep, typeId) {
          var endpointArgs = {
            cssClass: this.cssClass,
            endpoint: this
          };
          var endpoint;
          if (isAssignableFrom(ep, EndpointRepresentation)) {
            var epr = ep;
            endpoint = EndpointFactory.clone(epr);
          } else if (isString(ep)) {
            endpoint = EndpointFactory.get(this, ep, endpointArgs);
          } else {
            var fep = ep;
            extend(endpointArgs, fep.options || {});
            endpoint = EndpointFactory.get(this, fep.type, endpointArgs);
          }
          endpoint.typeId = typeId;
          return endpoint;
        }
      }, {
        key: "setEndpoint",
        value: function setEndpoint(ep) {
          var _ep = this.prepareEndpoint(ep);
          this.setPreparedEndpoint(_ep);
        }
      }, {
        key: "setPreparedEndpoint",
        value: function setPreparedEndpoint(ep) {
          if (this.endpoint != null) {
            this.instance.destroyEndpoint(this);
          }
          this.endpoint = ep;
        }
      }, {
        key: "addClass",
        value: function addClass(clazz, cascade) {
          _get$1(_getPrototypeOf$1(Endpoint.prototype), "addClass", this).call(this, clazz, cascade);
          if (this.endpoint != null) {
            this.endpoint.addClass(clazz);
          }
        }
      }, {
        key: "removeClass",
        value: function removeClass(clazz, cascade) {
          _get$1(_getPrototypeOf$1(Endpoint.prototype), "removeClass", this).call(this, clazz, cascade);
          if (this.endpoint != null) {
            this.endpoint.removeClass(clazz);
          }
        }
      }]);
      return Endpoint;
    }(Component);

    var UINode = function UINode(instance, el) {
      _classCallCheck$1(this, UINode);
      this.instance = instance;
      this.el = el;
      _defineProperty$1(this, "group", void 0);
    };
    var UIGroup = function (_UINode) {
      _inherits$1(UIGroup, _UINode);
      var _super = _createSuper$1(UIGroup);
      function UIGroup(instance, el, options) {
        var _this;
        _classCallCheck$1(this, UIGroup);
        _this = _super.call(this, instance, el);
        _this.instance = instance;
        _defineProperty$1(_assertThisInitialized$1(_this), "children", []);
        _defineProperty$1(_assertThisInitialized$1(_this), "collapsed", false);
        _defineProperty$1(_assertThisInitialized$1(_this), "droppable", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "enabled", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "orphan", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "constrain", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "proxied", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "ghost", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "revert", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "prune", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "dropOverride", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "anchor", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "endpoint", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "connections", {
          source: [],
          target: [],
          internal: []
        });
        _defineProperty$1(_assertThisInitialized$1(_this), "manager", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "id", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "elId", void 0);
        var jel = _this.el;
        jel._isJsPlumbGroup = true;
        jel._jsPlumbGroup = _assertThisInitialized$1(_this);
        _this.elId = instance.getId(el);
        _this.orphan = options.orphan === true;
        _this.revert = _this.orphan === true ? false : options.revert !== false;
        _this.droppable = options.droppable !== false;
        _this.ghost = options.ghost === true;
        _this.enabled = options.enabled !== false;
        _this.prune = _this.orphan !== true && options.prune === true;
        _this.constrain = _this.ghost || options.constrain === true;
        _this.proxied = options.proxied !== false;
        _this.id = options.id || uuid();
        _this.dropOverride = options.dropOverride === true;
        _this.anchor = options.anchor;
        _this.endpoint = options.endpoint;
        _this.anchor = options.anchor;
        instance.setAttribute(el, ATTRIBUTE_GROUP, "");
        return _this;
      }
      _createClass$1(UIGroup, [{
        key: "overrideDrop",
        value: function overrideDrop(el, targetGroup) {
          return this.dropOverride && (this.revert || this.prune || this.orphan);
        }
      }, {
        key: "getAnchor",
        value: function getAnchor(conn, endpointIndex) {
          return this.anchor || "Continuous";
        }
      }, {
        key: "getEndpoint",
        value: function getEndpoint(conn, endpointIndex) {
          return this.endpoint || {
            type: DotEndpoint.type,
            options: {
              radius: 10
            }
          };
        }
      }, {
        key: "add",
        value: function add(_el, doNotFireEvent) {
          var dragArea = this.instance.getGroupContentArea(this);
          var __el = _el;
          if (__el._jsPlumbParentGroup != null) {
            if (__el._jsPlumbParentGroup === this) {
              return;
            } else {
              __el._jsPlumbParentGroup.remove(_el, true, doNotFireEvent, false);
            }
          }
          __el._jsPlumbParentGroup = this;
          this.children.push(new UINode(this.instance, _el));
          this.instance._appendElement(__el, dragArea);
          this.manager._updateConnectionsForGroup(this);
        }
      }, {
        key: "resolveNode",
        value: function resolveNode(el) {
          return el == null ? null : getWithFunction(this.children, function (u) {
            return u.el === el;
          });
        }
      }, {
        key: "remove",
        value: function remove(el, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup) {
          var uiNode = this.resolveNode(el);
          if (uiNode != null) {
            this._doRemove(uiNode, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup);
          }
        }
      }, {
        key: "_doRemove",
        value: function _doRemove(child, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup) {
          var __el = child.el;
          delete __el._jsPlumbParentGroup;
          removeWithFunction(this.children, function (e) {
            return e === child;
          });
          if (manipulateDOM) {
            try {
              this.instance.getGroupContentArea(this).removeChild(__el);
            } catch (e) {
              log("Could not remove element from Group " + e);
            }
          }
          if (!doNotFireEvent) {
            var p = {
              group: this,
              el: __el
            };
            if (targetGroup) {
              p.targetGroup = targetGroup;
            }
            this.instance.fire(EVENT_GROUP_MEMBER_REMOVED, p);
          }
          if (!doNotUpdateConnections) {
            this.manager._updateConnectionsForGroup(this);
          }
        }
      }, {
        key: "removeAll",
        value: function removeAll(manipulateDOM, doNotFireEvent) {
          for (var i = 0, l = this.children.length; i < l; i++) {
            var child = this.children[0];
            this._doRemove(child, manipulateDOM, doNotFireEvent, true);
            this.instance.unmanage(child.el, true);
          }
          this.children.length = 0;
          this.manager._updateConnectionsForGroup(this);
        }
      }, {
        key: "orphanAll",
        value: function orphanAll() {
          var orphanedPositions = {};
          for (var i = 0; i < this.children.length; i++) {
            var newPosition = this.manager.orphan(this.children[i].el, false);
            orphanedPositions[newPosition.id] = newPosition.pos;
          }
          this.children.length = 0;
          return orphanedPositions;
        }
      }, {
        key: "addGroup",
        value: function addGroup(group) {
          if (this.instance.allowNestedGroups && group !== this) {
            if (this.instance.groupManager.isAncestor(this, group)) {
              return false;
            }
            if (group.group != null) {
              group.group.removeGroup(group);
            }
            var groupElId = this.instance.getId(group.el);
            var entry = this.instance.getManagedElements()[groupElId];
            entry.group = this.elId;
            var elpos = this.instance.getOffsetRelativeToRoot(group.el);
            var cpos = this.collapsed ? this.instance.getOffsetRelativeToRoot(this.el) : this.instance.getOffsetRelativeToRoot(this.instance.getGroupContentArea(this));
            group.el._jsPlumbParentGroup = this;
            this.children.push(group);
            this.instance._appendElement(group.el, this.instance.getGroupContentArea(this));
            group.group = this;
            var newPosition = {
              x: elpos.x - cpos.x,
              y: elpos.y - cpos.y
            };
            this.instance.setPosition(group.el, newPosition);
            this.instance.fire(EVENT_NESTED_GROUP_ADDED, {
              parent: this,
              child: group
            });
            return true;
          } else {
            return false;
          }
        }
      }, {
        key: "removeGroup",
        value: function removeGroup(group) {
          if (group.group === this) {
            var jel = group.el;
            var d = this.instance.getGroupContentArea(this);
            if (d === jel.parentNode) {
              d.removeChild(group.el);
            }
            var groupElId = this.instance.getId(group.el);
            var entry = this.instance.getManagedElements()[groupElId];
            if (entry) {
              delete entry.group;
            }
            this.children = this.children.filter(function (cg) {
              return cg.id !== group.id;
            });
            delete group.group;
            delete jel._jsPlumbParentGroup;
            this.instance.fire(EVENT_NESTED_GROUP_REMOVED, {
              parent: this,
              child: group
            });
          }
        }
      }, {
        key: "getGroups",
        value: function getGroups() {
          return this.children.filter(function (cg) {
            return cg.constructor === UIGroup;
          });
        }
      }, {
        key: "getNodes",
        value: function getNodes() {
          return this.children.filter(function (cg) {
            return cg.constructor === UINode;
          });
        }
      }, {
        key: "collapseParent",
        get: function get() {
          var cg = null;
          if (this.group == null) {
            return null;
          } else {
            var g = this.group;
            while (g != null) {
              if (g.collapsed) {
                cg = g;
              }
              g = g.group;
            }
            return cg;
          }
        }
      }]);
      return UIGroup;
    }(UINode);

    var GroupManager = function () {
      function GroupManager(instance) {
        var _this = this;
        _classCallCheck$1(this, GroupManager);
        this.instance = instance;
        _defineProperty$1(this, "groupMap", {});
        _defineProperty$1(this, "_connectionSourceMap", {});
        _defineProperty$1(this, "_connectionTargetMap", {});
        instance.bind(EVENT_INTERNAL_CONNECTION, function (p) {
          var sourceGroup = _this.getGroupFor(p.source);
          var targetGroup = _this.getGroupFor(p.target);
          if (sourceGroup != null && targetGroup != null && sourceGroup === targetGroup) {
            _this._connectionSourceMap[p.connection.id] = sourceGroup;
            _this._connectionTargetMap[p.connection.id] = sourceGroup;
            suggest(sourceGroup.connections.internal, p.connection);
          } else {
            if (sourceGroup != null) {
              if (p.target._jsPlumbGroup === sourceGroup) {
                suggest(sourceGroup.connections.internal, p.connection);
              } else {
                suggest(sourceGroup.connections.source, p.connection);
              }
              _this._connectionSourceMap[p.connection.id] = sourceGroup;
            }
            if (targetGroup != null) {
              if (p.source._jsPlumbGroup === targetGroup) {
                suggest(targetGroup.connections.internal, p.connection);
              } else {
                suggest(targetGroup.connections.target, p.connection);
              }
              _this._connectionTargetMap[p.connection.id] = targetGroup;
            }
          }
        });
        instance.bind(EVENT_INTERNAL_CONNECTION_DETACHED, function (p) {
          _this._cleanupDetachedConnection(p.connection);
        });
        instance.bind(EVENT_CONNECTION_MOVED, function (p) {
          var originalElement = p.originalEndpoint.element,
              originalGroup = _this.getGroupFor(originalElement),
              newEndpoint = p.connection.endpoints[p.index],
              newElement = newEndpoint.element,
              newGroup = _this.getGroupFor(newElement),
              connMap = p.index === 0 ? _this._connectionSourceMap : _this._connectionTargetMap,
              otherConnMap = p.index === 0 ? _this._connectionTargetMap : _this._connectionSourceMap;
          if (newGroup != null) {
            connMap[p.connection.id] = newGroup;
            if (p.connection.source === p.connection.target) {
              otherConnMap[p.connection.id] = newGroup;
            }
          } else {
            delete connMap[p.connection.id];
            if (p.connection.source === p.connection.target) {
              delete otherConnMap[p.connection.id];
            }
          }
          if (originalGroup != null) {
            _this._updateConnectionsForGroup(originalGroup);
          }
          if (newGroup != null) {
            _this._updateConnectionsForGroup(newGroup);
          }
        });
      }
      _createClass$1(GroupManager, [{
        key: "_cleanupDetachedConnection",
        value: function _cleanupDetachedConnection(conn) {
          conn.proxies.length = 0;
          var group = this._connectionSourceMap[conn.id],
              f;
          if (group != null) {
            f = function f(c) {
              return c.id === conn.id;
            };
            removeWithFunction(group.connections.source, f);
            removeWithFunction(group.connections.target, f);
            removeWithFunction(group.connections.internal, f);
            delete this._connectionSourceMap[conn.id];
          }
          group = this._connectionTargetMap[conn.id];
          if (group != null) {
            f = function f(c) {
              return c.id === conn.id;
            };
            removeWithFunction(group.connections.source, f);
            removeWithFunction(group.connections.target, f);
            removeWithFunction(group.connections.internal, f);
            delete this._connectionTargetMap[conn.id];
          }
        }
      }, {
        key: "addGroup",
        value: function addGroup(params) {
          var jel = params.el;
          if (this.groupMap[params.id] != null) {
            throw new Error("cannot create Group [" + params.id + "]; a Group with that ID exists");
          }
          if (jel._isJsPlumbGroup != null) {
            throw new Error("cannot create Group [" + params.id + "]; the given element is already a Group");
          }
          var group = new UIGroup(this.instance, params.el, params);
          this.groupMap[group.id] = group;
          if (params.collapsed) {
            this.collapseGroup(group);
          }
          this.instance.manage(group.el);
          this.instance.addClass(group.el, CLASS_GROUP_EXPANDED);
          group.manager = this;
          this._updateConnectionsForGroup(group);
          this.instance.fire(EVENT_GROUP_ADDED, {
            group: group
          });
          return group;
        }
      }, {
        key: "getGroup",
        value: function getGroup(groupId) {
          var group = groupId;
          if (isString(groupId)) {
            group = this.groupMap[groupId];
            if (group == null) {
              throw new Error("No such group [" + groupId + "]");
            }
          }
          return group;
        }
      }, {
        key: "getGroupFor",
        value: function getGroupFor(el) {
          var jel = el;
          var c = this.instance.getContainer();
          var abort = false,
              g = null;
          while (!abort) {
            if (jel == null || jel === c) {
              abort = true;
            } else {
              if (jel._jsPlumbParentGroup) {
                g = jel._jsPlumbParentGroup;
                abort = true;
              } else {
                jel = jel.parentNode;
              }
            }
          }
          return g;
        }
      }, {
        key: "getGroups",
        value: function getGroups() {
          var g = [];
          for (var key in this.groupMap) {
            g.push(this.groupMap[key]);
          }
          return g;
        }
      }, {
        key: "removeGroup",
        value: function removeGroup(group, deleteMembers, manipulateView, doNotFireEvent) {
          var _this2 = this;
          var actualGroup = this.getGroup(group);
          this.expandGroup(actualGroup, true);
          var newPositions = {};
          forEach(actualGroup.children, function (uiNode) {
            var entry = _this2.instance.getManagedElements()[_this2.instance.getId(uiNode.el)];
            if (entry) {
              delete entry.group;
            }
          });
          if (deleteMembers) {
            forEach(actualGroup.getGroups(), function (cg) {
              return _this2.removeGroup(cg, deleteMembers, manipulateView);
            });
            actualGroup.removeAll(manipulateView, doNotFireEvent);
          } else {
            if (actualGroup.group) {
              forEach(actualGroup.children, function (c) {
                return actualGroup.group.add(c.el);
              });
            }
            newPositions = actualGroup.orphanAll();
          }
          if (actualGroup.group) {
            actualGroup.group.removeGroup(actualGroup);
          }
          this.instance.unmanage(actualGroup.el, true);
          delete this.groupMap[actualGroup.id];
          this.instance.fire(EVENT_GROUP_REMOVED, {
            group: actualGroup
          });
          return newPositions;
        }
      }, {
        key: "removeAllGroups",
        value: function removeAllGroups(deleteMembers, manipulateView, doNotFireEvent) {
          for (var _g in this.groupMap) {
            this.removeGroup(this.groupMap[_g], deleteMembers, manipulateView, doNotFireEvent);
          }
        }
      }, {
        key: "forEach",
        value: function forEach(f) {
          for (var key in this.groupMap) {
            f(this.groupMap[key]);
          }
        }
      }, {
        key: "orphan",
        value: function orphan(el, doNotTransferToAncestor) {
          var jel = el;
          if (jel._jsPlumbParentGroup) {
            var currentParent = jel._jsPlumbParentGroup;
            var positionRelativeToGroup = this.instance.getOffset(jel);
            var id = this.instance.getId(jel);
            var pos = this.instance.getOffset(el);
            jel.parentNode.removeChild(jel);
            if (doNotTransferToAncestor !== true && currentParent.group) {
              pos.x += positionRelativeToGroup.x;
              pos.y += positionRelativeToGroup.y;
              this.instance.getGroupContentArea(currentParent.group).appendChild(el);
            } else {
              this.instance._appendElement(el, this.instance.getContainer());
            }
            this.instance.setPosition(el, pos);
            delete jel._jsPlumbParentGroup;
            return {
              id: id,
              pos: pos
            };
          }
        }
      }, {
        key: "_updateConnectionsForGroup",
        value: function _updateConnectionsForGroup(group) {
          var _this3 = this;
          group.connections.source.length = 0;
          group.connections.target.length = 0;
          group.connections.internal.length = 0;
          var members = group.children.slice().map(function (cn) {
            return cn.el;
          });
          var childMembers = [];
          forEach(members, function (member) {
            Array.prototype.push.apply(childMembers, _this3.instance.getSelector(member, SELECTOR_MANAGED_ELEMENT));
          });
          Array.prototype.push.apply(members, childMembers);
          if (members.length > 0) {
            var c1 = this.instance.getConnections({
              source: members,
              scope: WILDCARD
            }, true);
            var c2 = this.instance.getConnections({
              target: members,
              scope: WILDCARD
            }, true);
            var processed = {};
            var gs, gt;
            var oneSet = function oneSet(c) {
              for (var i = 0; i < c.length; i++) {
                if (processed[c[i].id]) {
                  continue;
                }
                processed[c[i].id] = true;
                gs = _this3.getGroupFor(c[i].source);
                gt = _this3.getGroupFor(c[i].target);
                if (c[i].source === group.el && gt === group || c[i].target === group.el && gs === group) {
                  group.connections.internal.push(c[i]);
                } else if (gs === group) {
                  if (gt !== group) {
                    group.connections.source.push(c[i]);
                  } else {
                    group.connections.internal.push(c[i]);
                  }
                  _this3._connectionSourceMap[c[i].id] = group;
                } else if (gt === group) {
                  group.connections.target.push(c[i]);
                  _this3._connectionTargetMap[c[i].id] = group;
                }
              }
            };
            oneSet(c1);
            oneSet(c2);
          }
        }
      }, {
        key: "_collapseConnection",
        value: function _collapseConnection(conn, index, group) {
          var otherEl = conn.endpoints[index === 0 ? 1 : 0].element;
          if (otherEl._jsPlumbParentGroup && !otherEl._jsPlumbParentGroup.proxied && otherEl._jsPlumbParentGroup.collapsed) {
            return false;
          }
          var es = conn.endpoints[0].element,
              esg = es._jsPlumbParentGroup,
              esgcp = esg != null ? esg.collapseParent || esg : null,
              et = conn.endpoints[1].element,
              etg = et._jsPlumbParentGroup,
              etgcp = etg != null ? etg.collapseParent || etg : null;
          if (esgcp == null || etgcp == null || esgcp.id !== etgcp.id) {
            var groupEl = group.el;
                this.instance.getId(groupEl);
            this.instance.proxyConnection(conn, index, groupEl,
            function (conn, index) {
              return group.getEndpoint(conn, index);
            }, function (conn, index) {
              return group.getAnchor(conn, index);
            });
            return true;
          } else {
            return false;
          }
        }
      }, {
        key: "_expandConnection",
        value: function _expandConnection(c, index, group) {
          this.instance.unproxyConnection(c, index);
        }
      }, {
        key: "isElementDescendant",
        value: function isElementDescendant(el, parentEl) {
          var c = this.instance.getContainer();
          var abort = false;
          while (!abort) {
            if (el == null || el === c) {
              return false;
            } else {
              if (el === parentEl) {
                return true;
              } else {
                el = el.parentNode;
              }
            }
          }
        }
      }, {
        key: "collapseGroup",
        value: function collapseGroup(group) {
          var _this4 = this;
          var actualGroup = this.getGroup(group);
          if (actualGroup == null || actualGroup.collapsed) {
            return;
          }
          var groupEl = actualGroup.el;
          if (actualGroup.collapseParent == null) {
            this.instance.setGroupVisible(actualGroup, false);
            actualGroup.collapsed = true;
            this.instance.removeClass(groupEl, CLASS_GROUP_EXPANDED);
            this.instance.addClass(groupEl, CLASS_GROUP_COLLAPSED);
            if (actualGroup.proxied) {
              var collapsedConnectionIds = new Set();
              var _collapseSet = function _collapseSet(conns, index) {
                for (var i = 0; i < conns.length; i++) {
                  var c = conns[i];
                  if (_this4._collapseConnection(c, index, actualGroup) === true) {
                    collapsedConnectionIds.add(c.id);
                  }
                }
              };
              _collapseSet(actualGroup.connections.source, 0);
              _collapseSet(actualGroup.connections.target, 1);
              forEach(actualGroup.getGroups(), function (cg) {
                _this4.cascadeCollapse(actualGroup, cg, collapsedConnectionIds);
              });
            }
            this.instance.revalidate(groupEl);
            this.repaintGroup(actualGroup);
            this.instance.fire(EVENT_GROUP_COLLAPSE, {
              group: actualGroup
            });
          } else {
            actualGroup.collapsed = true;
            this.instance.removeClass(groupEl, CLASS_GROUP_EXPANDED);
            this.instance.addClass(groupEl, CLASS_GROUP_COLLAPSED);
          }
        }
      }, {
        key: "cascadeCollapse",
        value: function cascadeCollapse(collapsedGroup, targetGroup, collapsedIds) {
          var _this5 = this;
          if (collapsedGroup.proxied) {
            var _collapseSet = function _collapseSet(conns, index) {
              for (var i = 0; i < conns.length; i++) {
                var c = conns[i];
                if (!collapsedIds.has(c.id)) {
                  if (_this5._collapseConnection(c, index, collapsedGroup) === true) {
                    collapsedIds.add(c.id);
                  }
                }
              }
            };
            _collapseSet(targetGroup.connections.source, 0);
            _collapseSet(targetGroup.connections.target, 1);
          }
          forEach(targetGroup.getGroups(), function (cg) {
            _this5.cascadeCollapse(collapsedGroup, cg, collapsedIds);
          });
        }
      }, {
        key: "expandGroup",
        value: function expandGroup(group, doNotFireEvent) {
          var _this6 = this;
          var actualGroup = this.getGroup(group);
          if (actualGroup == null) {
            return;
          }
          var groupEl = actualGroup.el;
          if (actualGroup.collapseParent == null) {
            this.instance.setGroupVisible(actualGroup, true);
            actualGroup.collapsed = false;
            this.instance.addClass(groupEl, CLASS_GROUP_EXPANDED);
            this.instance.removeClass(groupEl, CLASS_GROUP_COLLAPSED);
            if (actualGroup.proxied) {
              var _expandSet = function _expandSet(conns, index) {
                for (var i = 0; i < conns.length; i++) {
                  var c = conns[i];
                  _this6._expandConnection(c, index, actualGroup);
                }
              };
              _expandSet(actualGroup.connections.source, 0);
              _expandSet(actualGroup.connections.target, 1);
              var _expandNestedGroup = function _expandNestedGroup(group, ignoreCollapsedStateForNested) {
                if (ignoreCollapsedStateForNested || group.collapsed) {
                  var _collapseSet = function _collapseSet(conns, index) {
                    for (var i = 0; i < conns.length; i++) {
                      var c = conns[i];
                      _this6._collapseConnection(c, index, group.collapseParent || group);
                    }
                  };
                  _collapseSet(group.connections.source, 0);
                  _collapseSet(group.connections.target, 1);
                  forEach(group.connections.internal, function (c) {
                    return c.setVisible(false);
                  });
                  forEach(group.getGroups(), function (g) {
                    return _expandNestedGroup(g, true);
                  });
                } else {
                  _this6.expandGroup(group, true);
                }
              };
              forEach(actualGroup.getGroups(), _expandNestedGroup);
            }
            this.instance.revalidate(groupEl);
            this.repaintGroup(actualGroup);
            if (!doNotFireEvent) {
              this.instance.fire(EVENT_GROUP_EXPAND, {
                group: actualGroup
              });
            }
          } else {
            actualGroup.collapsed = false;
            this.instance.addClass(groupEl, CLASS_GROUP_EXPANDED);
            this.instance.removeClass(groupEl, CLASS_GROUP_COLLAPSED);
          }
        }
      }, {
        key: "toggleGroup",
        value: function toggleGroup(group) {
          group = this.getGroup(group);
          if (group != null) {
            if (group.collapsed) {
              this.expandGroup(group);
            } else {
              this.collapseGroup(group);
            }
          }
        }
      }, {
        key: "repaintGroup",
        value: function repaintGroup(group) {
          var actualGroup = this.getGroup(group);
          var m = actualGroup.children;
          for (var i = 0; i < m.length; i++) {
            this.instance.revalidate(m[i].el);
          }
        }
      }, {
        key: "addToGroup",
        value: function addToGroup(group, doNotFireEvent) {
          var _this7 = this;
          var actualGroup = this.getGroup(group);
          if (actualGroup) {
            var groupEl = actualGroup.el;
            var _one = function _one(el) {
              var jel = el;
              var isGroup = jel._isJsPlumbGroup != null,
                  droppingGroup = jel._jsPlumbGroup;
              var currentGroup = jel._jsPlumbParentGroup;
              if (currentGroup !== actualGroup) {
                var entry = _this7.instance.manage(el);
                var elpos = _this7.instance.getOffset(el);
                var cpos = actualGroup.collapsed ? _this7.instance.getOffsetRelativeToRoot(groupEl) : _this7.instance.getOffset(_this7.instance.getGroupContentArea(actualGroup));
                entry.group = actualGroup.elId;
                if (currentGroup != null) {
                  currentGroup.remove(el, false, doNotFireEvent, false, actualGroup);
                  _this7._updateConnectionsForGroup(currentGroup);
                }
                if (isGroup) {
                  actualGroup.addGroup(droppingGroup);
                } else {
                  actualGroup.add(el, doNotFireEvent);
                }
                var handleDroppedConnections = function handleDroppedConnections(list, index) {
                  var oidx = index === 0 ? 1 : 0;
                  list.each(function (c) {
                    c.setVisible(false);
                    if (c.endpoints[oidx].element._jsPlumbGroup === actualGroup) {
                      c.endpoints[oidx].setVisible(false);
                      _this7._expandConnection(c, oidx, actualGroup);
                    } else {
                      c.endpoints[index].setVisible(false);
                      _this7._collapseConnection(c, index, actualGroup);
                    }
                  });
                };
                if (actualGroup.collapsed) {
                  handleDroppedConnections(_this7.instance.select({
                    source: el
                  }), 0);
                  handleDroppedConnections(_this7.instance.select({
                    target: el
                  }), 1);
                }
                _this7.instance.getId(el);
                var newPosition = {
                  x: elpos.x - cpos.x,
                  y: elpos.y - cpos.y
                };
                _this7.instance.setPosition(el, newPosition);
                _this7._updateConnectionsForGroup(actualGroup);
                _this7.instance.revalidate(el);
                if (!doNotFireEvent) {
                  var p = {
                    group: actualGroup,
                    el: el,
                    pos: newPosition
                  };
                  if (currentGroup) {
                    p.sourceGroup = currentGroup;
                  }
                  _this7.instance.fire(EVENT_GROUP_MEMBER_ADDED, p);
                }
              }
            };
            for (var _len = arguments.length, el = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              el[_key - 2] = arguments[_key];
            }
            forEach(el, _one);
          }
        }
      }, {
        key: "removeFromGroup",
        value: function removeFromGroup(group, doNotFireEvent) {
          var _this8 = this;
          var actualGroup = this.getGroup(group);
          if (actualGroup) {
            var _one = function _one(_el) {
              if (actualGroup.collapsed) {
                var _expandSet = function _expandSet(conns, index) {
                  for (var i = 0; i < conns.length; i++) {
                    var c = conns[i];
                    if (c.proxies) {
                      for (var j = 0; j < c.proxies.length; j++) {
                        if (c.proxies[j] != null) {
                          var proxiedElement = c.proxies[j].originalEp.element;
                          if (proxiedElement === _el || _this8.isElementDescendant(proxiedElement, _el)) {
                            _this8._expandConnection(c, index, actualGroup);
                          }
                        }
                      }
                    }
                  }
                };
                _expandSet(actualGroup.connections.source.slice(), 0);
                _expandSet(actualGroup.connections.target.slice(), 1);
              }
              actualGroup.remove(_el, null, doNotFireEvent);
              var entry = _this8.instance.getManagedElements()[_this8.instance.getId(_el)];
              if (entry) {
                delete entry.group;
              }
            };
            for (var _len2 = arguments.length, el = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              el[_key2 - 2] = arguments[_key2];
            }
            forEach(el, _one);
          }
        }
      }, {
        key: "getAncestors",
        value: function getAncestors(group) {
          var ancestors = [];
          var p = group.group;
          while (p != null) {
            ancestors.push(p);
            p = p.group;
          }
          return ancestors;
        }
      }, {
        key: "isAncestor",
        value: function isAncestor(group, possibleAncestor) {
          if (group == null || possibleAncestor == null) {
            return false;
          }
          return this.getAncestors(group).indexOf(possibleAncestor) !== -1;
        }
      }, {
        key: "getDescendants",
        value: function getDescendants(group) {
          var d = [];
          var _one = function _one(g) {
            var childGroups = g.getGroups();
            d.push.apply(d, _toConsumableArray(childGroups));
            forEach(childGroups, _one);
          };
          _one(group);
          return d;
        }
      }, {
        key: "isDescendant",
        value: function isDescendant(possibleDescendant, ancestor) {
          if (possibleDescendant == null || ancestor == null) {
            return false;
          }
          return this.getDescendants(ancestor).indexOf(possibleDescendant) !== -1;
        }
      }, {
        key: "reset",
        value: function reset() {
          this._connectionSourceMap = {};
          this._connectionTargetMap = {};
          this.groupMap = {};
        }
      }]);
      return GroupManager;
    }();

    var SelectionBase = function () {
      function SelectionBase(instance, entries) {
        _classCallCheck$1(this, SelectionBase);
        this.instance = instance;
        this.entries = entries;
      }
      _createClass$1(SelectionBase, [{
        key: "length",
        get: function get() {
          return this.entries.length;
        }
      }, {
        key: "each",
        value: function each(handler) {
          forEach(this.entries, function (e) {
            return handler(e);
          });
          return this;
        }
      }, {
        key: "get",
        value: function get(index) {
          return this.entries[index];
        }
      }, {
        key: "addClass",
        value: function addClass(clazz, cascade) {
          this.each(function (c) {
            return c.addClass(clazz, cascade);
          });
          return this;
        }
      }, {
        key: "removeClass",
        value: function removeClass(clazz, cascade) {
          this.each(function (c) {
            return c.removeClass(clazz, cascade);
          });
          return this;
        }
      }, {
        key: "removeAllOverlays",
        value: function removeAllOverlays() {
          this.each(function (c) {
            return c.removeAllOverlays();
          });
          return this;
        }
      }, {
        key: "setLabel",
        value: function setLabel(label) {
          this.each(function (c) {
            return c.setLabel(label);
          });
          return this;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.entries.length = 0;
          return this;
        }
      }, {
        key: "map",
        value: function map(fn) {
          var a = [];
          this.each(function (e) {
            return a.push(fn(e));
          });
          return a;
        }
      }, {
        key: "addOverlay",
        value: function addOverlay(spec) {
          this.each(function (c) {
            return c.addOverlay(spec);
          });
          return this;
        }
      }, {
        key: "removeOverlay",
        value: function removeOverlay(id) {
          this.each(function (c) {
            return c.removeOverlay(id);
          });
          return this;
        }
      }, {
        key: "removeOverlays",
        value: function removeOverlays() {
          this.each(function (c) {
            return c.removeOverlays();
          });
          return this;
        }
      }, {
        key: "showOverlay",
        value: function showOverlay(id) {
          this.each(function (c) {
            return c.showOverlay(id);
          });
          return this;
        }
      }, {
        key: "hideOverlay",
        value: function hideOverlay(id) {
          this.each(function (c) {
            return c.hideOverlay(id);
          });
          return this;
        }
      }, {
        key: "setPaintStyle",
        value: function setPaintStyle(style) {
          this.each(function (c) {
            return c.setPaintStyle(style);
          });
          return this;
        }
      }, {
        key: "setHoverPaintStyle",
        value: function setHoverPaintStyle(style) {
          this.each(function (c) {
            return c.setHoverPaintStyle(style);
          });
          return this;
        }
      }, {
        key: "setSuspendEvents",
        value: function setSuspendEvents(suspend) {
          this.each(function (c) {
            return c.setSuspendEvents(suspend);
          });
          return this;
        }
      }, {
        key: "setParameter",
        value: function setParameter(name, value) {
          this.each(function (c) {
            return c.parameters[name] = value;
          });
          return this;
        }
      }, {
        key: "setParameters",
        value: function setParameters(p) {
          this.each(function (c) {
            return c.parameters = p;
          });
          return this;
        }
      }, {
        key: "setVisible",
        value: function setVisible(v) {
          this.each(function (c) {
            return c.setVisible(v);
          });
          return this;
        }
      }, {
        key: "addType",
        value: function addType(name) {
          this.each(function (c) {
            return c.addType(name);
          });
          return this;
        }
      }, {
        key: "toggleType",
        value: function toggleType(name) {
          this.each(function (c) {
            return c.toggleType(name);
          });
          return this;
        }
      }, {
        key: "removeType",
        value: function removeType(name) {
          this.each(function (c) {
            return c.removeType(name);
          });
          return this;
        }
      }, {
        key: "bind",
        value: function bind(evt, handler) {
          this.each(function (c) {
            return c.bind(evt, handler);
          });
          return this;
        }
      }, {
        key: "unbind",
        value: function unbind(evt, handler) {
          this.each(function (c) {
            return c.unbind(evt, handler);
          });
          return this;
        }
      }, {
        key: "setHover",
        value: function setHover(h) {
          var _this = this;
          this.each(function (c) {
            return _this.instance.setHover(c, h);
          });
          return this;
        }
      }]);
      return SelectionBase;
    }();

    var EndpointSelection = function (_SelectionBase) {
      _inherits$1(EndpointSelection, _SelectionBase);
      var _super = _createSuper$1(EndpointSelection);
      function EndpointSelection() {
        _classCallCheck$1(this, EndpointSelection);
        return _super.apply(this, arguments);
      }
      _createClass$1(EndpointSelection, [{
        key: "setEnabled",
        value: function setEnabled(e) {
          this.each(function (ep) {
            return ep.enabled = e;
          });
          return this;
        }
      }, {
        key: "setAnchor",
        value: function setAnchor(a) {
          this.each(function (ep) {
            return ep.setAnchor(a);
          });
          return this;
        }
      }, {
        key: "deleteEveryConnection",
        value: function deleteEveryConnection() {
          this.each(function (ep) {
            return ep.deleteEveryConnection();
          });
          return this;
        }
      }, {
        key: "deleteAll",
        value: function deleteAll() {
          var _this = this;
          this.each(function (ep) {
            return _this.instance.deleteEndpoint(ep);
          });
          this.clear();
          return this;
        }
      }]);
      return EndpointSelection;
    }(SelectionBase);

    var ConnectionSelection = function (_SelectionBase) {
      _inherits$1(ConnectionSelection, _SelectionBase);
      var _super = _createSuper$1(ConnectionSelection);
      function ConnectionSelection() {
        _classCallCheck$1(this, ConnectionSelection);
        return _super.apply(this, arguments);
      }
      _createClass$1(ConnectionSelection, [{
        key: "setDetachable",
        value: function setDetachable(d) {
          this.each(function (c) {
            return c.setDetachable(d);
          });
          return this;
        }
      }, {
        key: "setReattach",
        value: function setReattach(d) {
          this.each(function (c) {
            return c.setReattach(d);
          });
          return this;
        }
      }, {
        key: "setConnector",
        value: function setConnector(spec) {
          this.each(function (c) {
            return c.setConnector(spec);
          });
          return this;
        }
      }, {
        key: "deleteAll",
        value: function deleteAll() {
          var _this = this;
          this.each(function (c) {
            return _this.instance.deleteConnection(c);
          });
          this.clear();
        }
      }, {
        key: "repaint",
        value: function repaint() {
          var _this2 = this;
          this.each(function (c) {
            return _this2.instance.paintConnection(c);
          });
          return this;
        }
      }]);
      return ConnectionSelection;
    }(SelectionBase);

    var Transaction = function Transaction() {
      _classCallCheck$1(this, Transaction);
      _defineProperty$1(this, "affectedElements", new Set());
    };
    function EMPTY_POSITION() {
      return {
        x: 0,
        y: 0,
        w: 0,
        h: 0,
        r: 0,
        c: {
          x: 0,
          y: 0
        },
        x2: 0,
        y2: 0,
        t: {
          x: 0,
          y: 0,
          c: {
            x: 0,
            y: 0
          },
          w: 0,
          h: 0,
          r: 0,
          x2: 0,
          y2: 0,
          cr: 0,
          sr: 0
        },
        dirty: true
      };
    }
    function rotate(x, y, w, h, r) {
      var center = {
        x: x + w / 2,
        y: y + h / 2
      },
          cr = Math.cos(r / 360 * Math.PI * 2),
          sr = Math.sin(r / 360 * Math.PI * 2),
          _point = function _point(x, y) {
        return {
          x: center.x + Math.round((x - center.x) * cr - (y - center.y) * sr),
          y: center.y + Math.round((y - center.y) * cr - (x - center.x) * sr)
        };
      };
      var p1 = _point(x, y),
          p2 = _point(x + w, y),
          p3 = _point(x + w, y + h),
          p4 = _point(x, y + h),
          c = _point(x + w / 2, y + h / 2);
      var xmin = Math.min(p1.x, p2.x, p3.x, p4.x),
          xmax = Math.max(p1.x, p2.x, p3.x, p4.x),
          ymin = Math.min(p1.y, p2.y, p3.y, p4.y),
          ymax = Math.max(p1.y, p2.y, p3.y, p4.y);
      return {
        x: xmin,
        y: ymin,
        w: xmax - xmin,
        h: ymax - ymin,
        c: c,
        r: r,
        x2: xmax,
        y2: ymax,
        cr: cr,
        sr: sr
      };
    }
    var entryComparator = function entryComparator(value, arrayEntry) {
      var c = 0;
      if (arrayEntry[1] > value[1]) {
        c = -1;
      } else if (arrayEntry[1] < value[1]) {
        c = 1;
      }
      return c;
    };
    var reverseEntryComparator = function reverseEntryComparator(value, arrayEntry) {
      return entryComparator(value, arrayEntry) * -1;
    };
    function _updateElementIndex(id, value, array, sortDescending) {
      insertSorted([id, value], array, entryComparator, sortDescending);
    }
    function _clearElementIndex(id, array) {
      var idx = findWithFunction(array, function (entry) {
        return entry[0] === id;
      });
      if (idx > -1) {
        array.splice(idx, 1);
      }
    }
    var Viewport = function (_EventGenerator) {
      _inherits$1(Viewport, _EventGenerator);
      var _super = _createSuper$1(Viewport);
      function Viewport(instance) {
        var _this;
        _classCallCheck$1(this, Viewport);
        _this = _super.call(this);
        _this.instance = instance;
        _defineProperty$1(_assertThisInitialized$1(_this), "_currentTransaction", null);
        _defineProperty$1(_assertThisInitialized$1(_this), "_sortedElements", {
          xmin: [],
          xmax: [],
          ymin: [],
          ymax: []
        });
        _defineProperty$1(_assertThisInitialized$1(_this), "_elementMap", new Map());
        _defineProperty$1(_assertThisInitialized$1(_this), "_transformedElementMap", new Map());
        _defineProperty$1(_assertThisInitialized$1(_this), "_bounds", {
          minx: 0,
          maxx: 0,
          miny: 0,
          maxy: 0
        });
        return _this;
      }
      _createClass$1(Viewport, [{
        key: "_updateBounds",
        value: function _updateBounds(id, updatedElement, doNotRecalculateBounds) {
          if (updatedElement != null) {
            _clearElementIndex(id, this._sortedElements.xmin);
            _clearElementIndex(id, this._sortedElements.xmax);
            _clearElementIndex(id, this._sortedElements.ymin);
            _clearElementIndex(id, this._sortedElements.ymax);
            _updateElementIndex(id, updatedElement.t.x, this._sortedElements.xmin, false);
            _updateElementIndex(id, updatedElement.t.x + updatedElement.t.w, this._sortedElements.xmax, true);
            _updateElementIndex(id, updatedElement.t.y, this._sortedElements.ymin, false);
            _updateElementIndex(id, updatedElement.t.y + updatedElement.t.h, this._sortedElements.ymax, true);
            if (doNotRecalculateBounds !== true) {
              this._recalculateBounds();
            }
          }
        }
      }, {
        key: "_recalculateBounds",
        value: function _recalculateBounds() {
          this._bounds.minx = this._sortedElements.xmin.length > 0 ? this._sortedElements.xmin[0][1] : 0;
          this._bounds.maxx = this._sortedElements.xmax.length > 0 ? this._sortedElements.xmax[0][1] : 0;
          this._bounds.miny = this._sortedElements.ymin.length > 0 ? this._sortedElements.ymin[0][1] : 0;
          this._bounds.maxy = this._sortedElements.ymax.length > 0 ? this._sortedElements.ymax[0][1] : 0;
        }
      }, {
        key: "recomputeBounds",
        value: function recomputeBounds() {
          var _this2 = this;
          this._sortedElements.xmin.length = 0;
          this._sortedElements.xmax.length = 0;
          this._sortedElements.ymin.length = 0;
          this._sortedElements.ymax.length = 0;
          this._elementMap.forEach(function (vp, id) {
            _this2._sortedElements.xmin.push([id, vp.t.x]);
            _this2._sortedElements.xmax.push([id, vp.t.x + vp.t.w]);
            _this2._sortedElements.ymin.push([id, vp.t.y]);
            _this2._sortedElements.ymax.push([id, vp.t.y + vp.t.h]);
          });
          this._sortedElements.xmin.sort(entryComparator);
          this._sortedElements.ymin.sort(entryComparator);
          this._sortedElements.xmax.sort(reverseEntryComparator);
          this._sortedElements.ymax.sort(reverseEntryComparator);
          this._recalculateBounds();
        }
      }, {
        key: "_finaliseUpdate",
        value: function _finaliseUpdate(id, e, doNotRecalculateBounds) {
          e.t = rotate(e.x, e.y, e.w, e.h, e.r);
          this._transformedElementMap.set(id, e.t);
          if (doNotRecalculateBounds !== true) {
            this._updateBounds(id, e, doNotRecalculateBounds);
          }
        }
      }, {
        key: "shouldFireEvent",
        value: function shouldFireEvent(event, value, originalEvent) {
          return true;
        }
      }, {
        key: "startTransaction",
        value: function startTransaction() {
          if (this._currentTransaction != null) {
            throw new Error("Viewport: cannot start transaction; a transaction is currently active.");
          }
          this._currentTransaction = new Transaction();
        }
      }, {
        key: "endTransaction",
        value: function endTransaction() {
          var _this3 = this;
          if (this._currentTransaction != null) {
            this._currentTransaction.affectedElements.forEach(function (id) {
              var entry = _this3.getPosition(id);
              _this3._finaliseUpdate(id, entry, true);
            });
            this.recomputeBounds();
            this._currentTransaction = null;
          }
        }
      }, {
        key: "updateElements",
        value: function updateElements(entries) {
          var _this4 = this;
          forEach(entries, function (e) {
            return _this4.updateElement(e.id, e.x, e.y, e.width, e.height, e.rotation);
          });
        }
      }, {
        key: "updateElement",
        value: function updateElement(id, x, y, width, height, rotation, doNotRecalculateBounds) {
          var e = getsert(this._elementMap, id, EMPTY_POSITION);
          e.dirty = x == null && e.x == null || y == null && e.y == null || width == null && e.w == null || height == null && e.h == null;
          if (x != null) {
            e.x = x;
          }
          if (y != null) {
            e.y = y;
          }
          if (width != null) {
            e.w = width;
          }
          if (height != null) {
            e.h = height;
          }
          if (rotation != null) {
            e.r = rotation || 0;
          }
          e.c.x = e.x + e.w / 2;
          e.c.y = e.y + e.h / 2;
          e.x2 = e.x + e.w;
          e.y2 = e.y + e.h;
          if (this._currentTransaction == null) {
            this._finaliseUpdate(id, e, doNotRecalculateBounds);
          } else {
            this._currentTransaction.affectedElements.add(id);
          }
          return e;
        }
      }, {
        key: "refreshElement",
        value: function refreshElement(elId, doNotRecalculateBounds) {
          var me = this.instance.getManagedElements();
          var s = me[elId] ? me[elId].el : null;
          if (s != null) {
            var size = this.getSize(s);
            var offset = this.getOffset(s);
            return this.updateElement(elId, offset.x, offset.y, size.w, size.h, null, doNotRecalculateBounds);
          } else {
            return null;
          }
        }
      }, {
        key: "getSize",
        value: function getSize(el) {
          return this.instance.getSize(el);
        }
      }, {
        key: "getOffset",
        value: function getOffset(el) {
          return this.instance.getOffset(el);
        }
      }, {
        key: "registerElement",
        value: function registerElement(id, doNotRecalculateBounds) {
          return this.updateElement(id, 0, 0, 0, 0, 0, doNotRecalculateBounds);
        }
      }, {
        key: "addElement",
        value: function addElement(id, x, y, width, height, rotation) {
          return this.updateElement(id, x, y, width, height, rotation);
        }
      }, {
        key: "rotateElement",
        value: function rotateElement(id, rotation) {
          var e = getsert(this._elementMap, id, EMPTY_POSITION);
          e.r = rotation || 0;
          this._finaliseUpdate(id, e);
          return e;
        }
      }, {
        key: "getBoundsWidth",
        value: function getBoundsWidth() {
          return this._bounds.maxx - this._bounds.minx;
        }
      }, {
        key: "getBoundsHeight",
        value: function getBoundsHeight() {
          return this._bounds.maxy - this._bounds.miny;
        }
      }, {
        key: "getX",
        value: function getX() {
          return this._bounds.minx;
        }
      }, {
        key: "getY",
        value: function getY() {
          return this._bounds.miny;
        }
      }, {
        key: "setSize",
        value: function setSize(id, w, h) {
          if (this._elementMap.has(id)) {
            return this.updateElement(id, null, null, w, h, null);
          }
        }
      }, {
        key: "setPosition",
        value: function setPosition(id, x, y) {
          if (this._elementMap.has(id)) {
            return this.updateElement(id, x, y, null, null, null);
          }
        }
      }, {
        key: "reset",
        value: function reset() {
          this._sortedElements.xmin.length = 0;
          this._sortedElements.xmax.length = 0;
          this._sortedElements.ymin.length = 0;
          this._sortedElements.ymax.length = 0;
          this._elementMap.clear();
          this._transformedElementMap.clear();
          this._recalculateBounds();
        }
      }, {
        key: "remove",
        value: function remove(id) {
          _clearElementIndex(id, this._sortedElements.xmin);
          _clearElementIndex(id, this._sortedElements.xmax);
          _clearElementIndex(id, this._sortedElements.ymin);
          _clearElementIndex(id, this._sortedElements.ymax);
          this._elementMap["delete"](id);
          this._transformedElementMap["delete"](id);
          this._recalculateBounds();
        }
      }, {
        key: "getPosition",
        value: function getPosition(id) {
          return this._elementMap.get(id);
        }
      }, {
        key: "getElements",
        value: function getElements() {
          return this._elementMap;
        }
      }, {
        key: "isEmpty",
        value: function isEmpty() {
          return this._elementMap.size === 0;
        }
      }]);
      return Viewport;
    }(EventGenerator);

    var ConnectionDragSelector = function () {
      function ConnectionDragSelector(selector, def) {
        var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        _classCallCheck$1(this, ConnectionDragSelector);
        this.selector = selector;
        this.def = def;
        this.exclude = exclude;
        _defineProperty$1(this, "id", void 0);
        this.id = uuid();
      }
      _createClass$1(ConnectionDragSelector, [{
        key: "setEnabled",
        value: function setEnabled(enabled) {
          this.def.enabled = enabled;
        }
      }, {
        key: "isEnabled",
        value: function isEnabled() {
          return this.def.enabled !== false;
        }
      }]);
      return ConnectionDragSelector;
    }();
    var REDROP_POLICY_STRICT = "strict";
    var REDROP_POLICY_ANY = "any";
    var SourceSelector = function (_ConnectionDragSelect) {
      _inherits$1(SourceSelector, _ConnectionDragSelect);
      var _super = _createSuper$1(SourceSelector);
      function SourceSelector(selector, def, exclude) {
        var _this;
        _classCallCheck$1(this, SourceSelector);
        _this = _super.call(this, selector, def, exclude);
        _this.def = def;
        _defineProperty$1(_assertThisInitialized$1(_this), "redrop", void 0);
        _this.redrop = def.def.redrop || REDROP_POLICY_STRICT;
        return _this;
      }
      return SourceSelector;
    }(ConnectionDragSelector);
    var TargetSelector = function (_ConnectionDragSelect2) {
      _inherits$1(TargetSelector, _ConnectionDragSelect2);
      var _super2 = _createSuper$1(TargetSelector);
      function TargetSelector(selector, def, exclude) {
        var _this2;
        _classCallCheck$1(this, TargetSelector);
        _this2 = _super2.call(this, selector, def, exclude);
        _this2.def = def;
        return _this2;
      }
      return TargetSelector;
    }(ConnectionDragSelector);

    var _edgeSortFunctions;
    function _placeAnchorsOnLine(element, connections, horizontal, otherMultiplier, reverse) {
      var sizeInAxis = horizontal ? element.w : element.h;
      var sizeInOtherAxis = horizontal ? element.h : element.w;
      var a = [],
          step = sizeInAxis / (connections.length + 1);
      for (var i = 0; i < connections.length; i++) {
        var val = (i + 1) * step,
            other = otherMultiplier * sizeInOtherAxis;
        if (reverse) {
          val = sizeInAxis - val;
        }
        var dx = horizontal ? val : other,
            x = element.x + dx,
            xp = dx / element.w;
        var dy = horizontal ? other : val,
            y = element.y + dy,
            yp = dy / element.h;
        if (element.r !== 0 && element.r != null) {
          var rotated = rotatePoint({
            x: x,
            y: y
          }, element.c, element.r);
          x = rotated.x;
          y = rotated.y;
        }
        a.push({
          x: x,
          y: y,
          xLoc: xp,
          yLoc: yp,
          c: connections[i].c
        });
      }
      return a;
    }
    function _rightAndBottomSort(a, b) {
      return b.theta - a.theta;
    }
    function _leftAndTopSort(a, b) {
      var p1 = a.theta < 0 ? -Math.PI - a.theta : Math.PI - a.theta,
          p2 = b.theta < 0 ? -Math.PI - b.theta : Math.PI - b.theta;
      return p1 - p2;
    }
    var edgeSortFunctions = (_edgeSortFunctions = {}, _defineProperty$1(_edgeSortFunctions, TOP, _leftAndTopSort), _defineProperty$1(_edgeSortFunctions, RIGHT, _rightAndBottomSort), _defineProperty$1(_edgeSortFunctions, BOTTOM, _rightAndBottomSort), _defineProperty$1(_edgeSortFunctions, LEFT, _leftAndTopSort), _edgeSortFunctions);
    function isContinuous(a) {
      return a.isContinuous === true;
    }
    function _isFloating(a) {
      return a.isContinuous === true;
    }
    function isDynamic(a) {
      return a.locations.length > 1;
    }
    function getCurrentLocation(anchor) {
      return [anchor.currentLocation, anchor.locations[anchor.currentLocation]];
    }
    var LightweightRouter = function () {
      function LightweightRouter(instance) {
        var _this = this;
        _classCallCheck$1(this, LightweightRouter);
        this.instance = instance;
        _defineProperty$1(this, "anchorLists", new Map());
        _defineProperty$1(this, "anchorLocations", new Map());
        instance.bind(EVENT_INTERNAL_CONNECTION_DETACHED, function (p) {
          _this._removeEndpointFromAnchorLists(p.sourceEndpoint);
          _this._removeEndpointFromAnchorLists(p.targetEndpoint);
        });
        instance.bind(EVENT_INTERNAL_ENDPOINT_UNREGISTERED, function (ep) {
          _this._removeEndpointFromAnchorLists(ep);
        });
      }
      _createClass$1(LightweightRouter, [{
        key: "getAnchorOrientation",
        value: function getAnchorOrientation(anchor) {
          var loc = this.anchorLocations.get(anchor.id);
          return loc ? [loc.ox, loc.oy] : [0, 0];
        }
      }, {
        key: "_distance",
        value: function _distance(anchor, cx, cy, xy, wh, rotation, targetRotation) {
          var ax = xy.x + anchor.x * wh.w,
              ay = xy.y + anchor.y * wh.h,
              acx = xy.x + wh.w / 2,
              acy = xy.y + wh.h / 2;
          if (rotation != null && rotation.length > 0) {
            var rotated = this.instance._applyRotations([ax, ay, 0, 0], rotation);
            ax = rotated.x;
            ay = rotated.y;
          }
          return Math.sqrt(Math.pow(cx - ax, 2) + Math.pow(cy - ay, 2)) + Math.sqrt(Math.pow(acx - ax, 2) + Math.pow(acy - ay, 2));
        }
      }, {
        key: "_anchorSelector",
        value: function _anchorSelector(xy, wh, txy, twh, rotation, targetRotation, locations) {
          var cx = txy.x + twh.w / 2,
              cy = txy.y + twh.h / 2;
          var minIdx = -1,
              minDist = Infinity;
          for (var i = 0; i < locations.length; i++) {
            var d = this._distance(locations[i], cx, cy, xy, wh, rotation, targetRotation);
            if (d < minDist) {
              minIdx = i + 0;
              minDist = d;
            }
          }
          return [minIdx, locations[minIdx]];
        }
      }, {
        key: "_floatingAnchorCompute",
        value: function _floatingAnchorCompute(anchor, params) {
          var xy = params.xy;
          var pos = {
            curX: xy.x + anchor.size.w / 2,
            curY: xy.y + anchor.size.h / 2,
            x: 0,
            y: 0,
            ox: 0,
            oy: 0
          };
          return this._setComputedPosition(anchor, pos);
        }
      }, {
        key: "_setComputedPosition",
        value: function _setComputedPosition(anchor, pos, timestamp) {
          this.anchorLocations.set(anchor.id, pos);
          anchor.computedPosition = pos;
          if (timestamp) {
            anchor.timestamp = timestamp;
          }
          return pos;
        }
      }, {
        key: "_computeSingleLocation",
        value: function _computeSingleLocation(loc, xy, wh, params) {
          var candidate = {
            curX: xy.x + loc.x * wh.w + loc.offx,
            curY: xy.y + loc.y * wh.h + loc.offy,
            x: loc.x,
            y: loc.y,
            ox: 0,
            oy: 0
          };
          var pos;
          var rotation = params.rotation;
          if (rotation != null && rotation.length > 0) {
            var o = [loc.iox, loc.ioy],
                current = {
              x: candidate.curX,
              y: candidate.curY,
              cr: 0,
              sr: 0
            };
            forEach(rotation, function (r) {
              current = rotatePoint(current, r.c, r.r);
              var _o = [Math.round(o[0] * current.cr - o[1] * current.sr), Math.round(o[1] * current.cr + o[0] * current.sr)];
              o = _o.slice();
            });
            loc.ox = o[0];
            loc.oy = o[1];
            pos = {
              curX: current.x,
              curY: current.y,
              x: loc.x,
              y: loc.y,
              ox: o[0],
              oy: o[1]
            };
          } else {
            loc.ox = loc.iox;
            loc.oy = loc.ioy;
            pos = extend({
              ox: loc.iox,
              oy: loc.ioy
            }, candidate);
          }
          return pos;
        }
      }, {
        key: "_singleAnchorCompute",
        value: function _singleAnchorCompute(anchor, params) {
          var xy = params.xy,
              wh = params.wh,
              timestamp = params.timestamp,
              pos = this.anchorLocations.get(anchor.id);
          if (pos != null && timestamp && timestamp === anchor.timestamp) {
            return pos;
          }
          var _getCurrentLocation = getCurrentLocation(anchor),
              _getCurrentLocation2 = _slicedToArray$1(_getCurrentLocation, 2);
              _getCurrentLocation2[0];
              var currentLoc = _getCurrentLocation2[1];
          pos = this._computeSingleLocation(currentLoc, xy, wh, params);
          return this._setComputedPosition(anchor, pos, timestamp);
        }
      }, {
        key: "_defaultAnchorCompute",
        value: function _defaultAnchorCompute(anchor, params) {
          var pos;
          if (anchor.locations.length === 1) {
            return this._singleAnchorCompute(anchor, params);
          }
          var xy = params.xy,
              wh = params.wh,
              txy = params.txy,
              twh = params.twh;
          var _getCurrentLocation3 = getCurrentLocation(anchor),
              _getCurrentLocation4 = _slicedToArray$1(_getCurrentLocation3, 2),
              currentIdx = _getCurrentLocation4[0],
              currentLoc = _getCurrentLocation4[1];
          if (anchor.locked || txy == null || twh == null) {
            pos = this._computeSingleLocation(currentLoc, xy, wh, params);
          } else {
            var _this$_anchorSelector = this._anchorSelector(xy, wh, txy, twh, params.rotation, params.tRotation, anchor.locations),
                _this$_anchorSelector2 = _slicedToArray$1(_this$_anchorSelector, 2),
                newIdx = _this$_anchorSelector2[0],
                newLoc = _this$_anchorSelector2[1];
            anchor.currentLocation = newIdx;
            if (newIdx !== currentIdx) {
              anchor.cssClass = newLoc.cls || anchor.cssClass;
              params.element._anchorLocationChanged(anchor);
            }
            pos = this._computeSingleLocation(newLoc, xy, wh, params);
          }
          return this._setComputedPosition(anchor, pos, params.timestamp);
        }
      }, {
        key: "_placeAnchors",
        value: function _placeAnchors(elementId, _anchorLists) {
          var _this2 = this;
          var cd = this.instance.viewport.getPosition(elementId),
              placeSomeAnchors = function placeSomeAnchors(desc, element, unsortedConnections, isHorizontal, otherMultiplier, orientation) {
            if (unsortedConnections.length > 0) {
              var sc = unsortedConnections.sort(edgeSortFunctions[desc]),
              reverse = desc === RIGHT || desc === TOP,
                  anchors = _placeAnchorsOnLine(cd, sc, isHorizontal, otherMultiplier, reverse);
              for (var i = 0; i < anchors.length; i++) {
                var c = anchors[i].c,
                    weAreSource = c.endpoints[0].elementId === elementId,
                    ep = weAreSource ? c.endpoints[0] : c.endpoints[1];
                _this2._setComputedPosition(ep._anchor, {
                  curX: anchors[i].x,
                  curY: anchors[i].y,
                  x: anchors[i].xLoc,
                  y: anchors[i].yLoc,
                  ox: orientation[0],
                  oy: orientation[1]
                });
              }
            }
          };
          placeSomeAnchors(BOTTOM, cd, _anchorLists.bottom, true, 1, [0, 1]);
          placeSomeAnchors(TOP, cd, _anchorLists.top, true, 0, [0, -1]);
          placeSomeAnchors(LEFT, cd, _anchorLists.left, false, 0, [-1, 0]);
          placeSomeAnchors(RIGHT, cd, _anchorLists.right, false, 1, [1, 0]);
        }
      }, {
        key: "_updateAnchorList",
        value: function _updateAnchorList(lists, theta, order, conn, aBoolean, otherElId, idx, reverse, edgeId, connsToPaint, endpointsToPaint) {
          var endpoint = conn.endpoints[idx],
              endpointId = endpoint.id,
              oIdx = [1, 0][idx],
              values = {
            theta: theta,
            order: order,
            c: conn,
            b: aBoolean,
            elId: otherElId,
            epId: endpointId
          },
              listToAddTo = lists[edgeId],
              listToRemoveFrom = endpoint._continuousAnchorEdge ? lists[endpoint._continuousAnchorEdge] : null,
              candidate;
          if (listToRemoveFrom) {
            var rIdx = findWithFunction(listToRemoveFrom, function (e) {
              return e.epId === endpointId;
            });
            if (rIdx !== -1) {
              listToRemoveFrom.splice(rIdx, 1);
              for (var i = 0; i < listToRemoveFrom.length; i++) {
                candidate = listToRemoveFrom[i].c;
                if (candidate.placeholder !== true) {
                  connsToPaint.add(candidate);
                }
                endpointsToPaint.add(listToRemoveFrom[i].c.endpoints[idx]);
                endpointsToPaint.add(listToRemoveFrom[i].c.endpoints[oIdx]);
              }
            }
          }
          for (var _i = 0; _i < listToAddTo.length; _i++) {
            candidate = listToAddTo[_i].c;
            if (candidate.placeholder !== true) {
              connsToPaint.add(candidate);
            }
            endpointsToPaint.add(listToAddTo[_i].c.endpoints[idx]);
            endpointsToPaint.add(listToAddTo[_i].c.endpoints[oIdx]);
          }
          {
            var insertIdx = reverse ? 0 : listToAddTo.length;
            listToAddTo.splice(insertIdx, 0, values);
          }
          endpoint._continuousAnchorEdge = edgeId;
        }
      }, {
        key: "_removeEndpointFromAnchorLists",
        value: function _removeEndpointFromAnchorLists(endpoint) {
          var listsForElement = this.anchorLists.get(endpoint.elementId);
          var total = 0;
          (function (list, eId) {
            if (list) {
              var f = function f(e) {
                return e.epId === eId;
              };
              removeWithFunction(list.top, f);
              removeWithFunction(list.left, f);
              removeWithFunction(list.bottom, f);
              removeWithFunction(list.right, f);
              total += list.top.length;
              total += list.left.length;
              total += list.bottom.length;
              total += list.right.length;
            }
          })(listsForElement, endpoint.id);
          if (total === 0) {
            this.anchorLists["delete"](endpoint.elementId);
          }
          this.anchorLocations["delete"](endpoint._anchor.id);
        }
      }, {
        key: "computeAnchorLocation",
        value: function computeAnchorLocation(anchor, params) {
          var pos;
          if (isContinuous(anchor)) {
            pos = this.anchorLocations.get(anchor.id) || {
              curX: 0,
              curY: 0,
              x: 0,
              y: 0,
              ox: 0,
              oy: 0
            };
          } else if (_isFloating(anchor)) {
            pos = this._floatingAnchorCompute(anchor, params);
          } else {
            pos = this._defaultAnchorCompute(anchor, params);
          }
          anchor.timestamp = params.timestamp;
          return pos;
        }
      }, {
        key: "computePath",
        value: function computePath(connection, timestamp) {
          var sourceInfo = this.instance.viewport.getPosition(connection.sourceId),
              targetInfo = this.instance.viewport.getPosition(connection.targetId),
              sE = connection.endpoints[0],
              tE = connection.endpoints[1];
          var sAnchorP = this.getEndpointLocation(sE, {
            xy: sourceInfo,
            wh: sourceInfo,
            element: sE,
            timestamp: timestamp,
            rotation: this.instance._getRotations(connection.sourceId)
          }),
              tAnchorP = this.getEndpointLocation(tE, {
            xy: targetInfo,
            wh: targetInfo,
            element: tE,
            timestamp: timestamp,
            rotation: this.instance._getRotations(connection.targetId)
          });
          connection.connector.resetBounds();
          connection.connector.compute({
            sourcePos: sAnchorP,
            targetPos: tAnchorP,
            sourceEndpoint: connection.endpoints[0],
            targetEndpoint: connection.endpoints[1],
            strokeWidth: connection.paintStyleInUse.strokeWidth,
            sourceInfo: sourceInfo,
            targetInfo: targetInfo
          });
        }
      }, {
        key: "getEndpointLocation",
        value: function getEndpointLocation(endpoint, params) {
          params = params || {};
          var anchor = endpoint._anchor;
          var pos = this.anchorLocations.get(anchor.id);
          if (pos == null || params.timestamp != null && anchor.timestamp !== params.timestamp) {
            pos = this.computeAnchorLocation(anchor, params);
            this._setComputedPosition(anchor, pos, params.timestamp);
          }
          return pos;
        }
      }, {
        key: "getEndpointOrientation",
        value: function getEndpointOrientation(ep) {
          return ep._anchor ? this.getAnchorOrientation(ep._anchor) : [0, 0];
        }
      }, {
        key: "setAnchorOrientation",
        value: function setAnchorOrientation(anchor, orientation) {
          var anchorLoc = this.anchorLocations.get(anchor.id);
          if (anchorLoc != null) {
            anchorLoc.ox = orientation[0];
            anchorLoc.oy = orientation[1];
          }
        }
      }, {
        key: "isDynamicAnchor",
        value: function isDynamicAnchor(ep) {
          return ep._anchor ? !isContinuous(ep._anchor) && ep._anchor.locations.length > 1 : false;
        }
      }, {
        key: "isFloating",
        value: function isFloating(ep) {
          return ep._anchor ? _isFloating(ep._anchor) : false;
        }
      }, {
        key: "prepareAnchor",
        value: function prepareAnchor(endpoint, params) {
          return makeLightweightAnchorFromSpec(params);
        }
      }, {
        key: "redraw",
        value: function redraw(elementId, timestamp, offsetToUI) {
          var _this3 = this;
          var connectionsToPaint = new Set(),
              endpointsToPaint = new Set(),
              anchorsToUpdate = new Set();
          if (!this.instance._suspendDrawing) {
            var ep = this.instance.endpointsByElement[elementId] || [];
            timestamp = timestamp || uuid();
            var orientationCache = {},
                a,
                anEndpoint;
            for (var i = 0; i < ep.length; i++) {
              anEndpoint = ep[i];
              endpointsToPaint.add(anEndpoint);
              a = anEndpoint._anchor;
              if (anEndpoint.connections.length === 0) {
                if (isContinuous(a)) {
                  if (!this.anchorLists.has(elementId)) {
                    this.anchorLists.set(elementId, {
                      top: [],
                      right: [],
                      bottom: [],
                      left: []
                    });
                  }
                  this._updateAnchorList(this.anchorLists.get(elementId), -Math.PI / 2, 0, {
                    endpoints: [anEndpoint, anEndpoint],
                    placeholder: true
                  }, false, elementId, 0, false, getDefaultFace(a), connectionsToPaint, endpointsToPaint);
                  anchorsToUpdate.add(elementId);
                }
              } else {
                for (var _i2 = 0; _i2 < anEndpoint.connections.length; _i2++) {
                  var conn = anEndpoint.connections[_i2],
                      sourceId = conn.sourceId,
                      targetId = conn.targetId,
                      sourceContinuous = isContinuous(conn.endpoints[0]._anchor),
                      targetContinuous = isContinuous(conn.endpoints[1]._anchor);
                  if (sourceContinuous || targetContinuous) {
                    var oKey = sourceId + "_" + targetId,
                        o = orientationCache[oKey],
                        oIdx = conn.sourceId === elementId ? 1 : 0;
                    if (sourceContinuous && !this.anchorLists.has(sourceId)) {
                      this.anchorLists.set(sourceId, {
                        top: [],
                        right: [],
                        bottom: [],
                        left: []
                      });
                    }
                    if (targetContinuous && !this.anchorLists.has(targetId)) {
                      this.anchorLists.set(targetId, {
                        top: [],
                        right: [],
                        bottom: [],
                        left: []
                      });
                    }
                    var td = this.instance.viewport.getPosition(targetId),
                        sd = this.instance.viewport.getPosition(sourceId);
                    if (targetId === sourceId && (sourceContinuous || targetContinuous)) {
                      this._updateAnchorList(this.anchorLists.get(sourceId), -Math.PI / 2, 0, conn, false, targetId, 0, false, TOP, connectionsToPaint, endpointsToPaint);
                      this._updateAnchorList(this.anchorLists.get(targetId), -Math.PI / 2, 0, conn, false, sourceId, 1, false, TOP, connectionsToPaint, endpointsToPaint);
                    } else {
                      var sourceRotation = this.instance._getRotations(sourceId);
                      var targetRotation = this.instance._getRotations(targetId);
                      if (!o) {
                        o = this._calculateOrientation(sourceId, targetId, sd, td, conn.endpoints[0]._anchor, conn.endpoints[1]._anchor, sourceRotation, targetRotation);
                        orientationCache[oKey] = o;
                      }
                      if (sourceContinuous) {
                        this._updateAnchorList(this.anchorLists.get(sourceId), o.theta, 0, conn, false, targetId, 0, false, o.a[0], connectionsToPaint, endpointsToPaint);
                      }
                      if (targetContinuous) {
                        this._updateAnchorList(this.anchorLists.get(targetId), o.theta2, -1, conn, true, sourceId, 1, true, o.a[1], connectionsToPaint, endpointsToPaint);
                      }
                    }
                    if (sourceContinuous) {
                      anchorsToUpdate.add(sourceId);
                    }
                    if (targetContinuous) {
                      anchorsToUpdate.add(targetId);
                    }
                    connectionsToPaint.add(conn);
                    if (sourceContinuous && oIdx === 0 || targetContinuous && oIdx === 1) {
                      endpointsToPaint.add(conn.endpoints[oIdx]);
                    }
                  } else {
                    var otherEndpoint = anEndpoint.connections[_i2].endpoints[conn.sourceId === elementId ? 1 : 0],
                        otherAnchor = otherEndpoint._anchor;
                    if (isDynamic(otherAnchor)) {
                      this.instance.paintEndpoint(otherEndpoint, {
                        elementWithPrecedence: elementId,
                        timestamp: timestamp
                      });
                      connectionsToPaint.add(anEndpoint.connections[_i2]);
                      for (var k = 0; k < otherEndpoint.connections.length; k++) {
                        if (otherEndpoint.connections[k] !== anEndpoint.connections[_i2]) {
                          connectionsToPaint.add(otherEndpoint.connections[k]);
                        }
                      }
                    } else {
                      connectionsToPaint.add(anEndpoint.connections[_i2]);
                    }
                  }
                }
              }
            }
            anchorsToUpdate.forEach(function (anchor) {
              _this3._placeAnchors(anchor, _this3.anchorLists.get(anchor));
            });
            endpointsToPaint.forEach(function (ep) {
              var cd = _this3.instance.viewport.getPosition(ep.elementId);
              _this3.instance.paintEndpoint(ep, {
                timestamp: timestamp,
                offset: cd
              });
            });
            connectionsToPaint.forEach(function (c) {
              _this3.instance.paintConnection(c, {
                timestamp: timestamp
              });
            });
          }
          return {
            c: connectionsToPaint,
            e: endpointsToPaint
          };
        }
      }, {
        key: "reset",
        value: function reset() {
          this.anchorLocations.clear();
          this.anchorLists.clear();
        }
      }, {
        key: "setAnchor",
        value: function setAnchor(endpoint, anchor) {
          if (anchor != null) {
            endpoint._anchor = anchor;
          }
        }
      }, {
        key: "setConnectionAnchors",
        value: function setConnectionAnchors(conn, anchors) {
          conn.endpoints[0]._anchor = anchors[0];
          conn.endpoints[1]._anchor = anchors[1];
        }
      }, {
        key: "_calculateOrientation",
        value: function _calculateOrientation(sourceId, targetId, sd, td, sourceAnchor, targetAnchor, sourceRotation, targetRotation) {
          var _this4 = this;
          var Orientation = {
            HORIZONTAL: "horizontal",
            VERTICAL: "vertical",
            DIAGONAL: "diagonal",
            IDENTITY: "identity"
          };
          if (sourceId === targetId) {
            return {
              orientation: Orientation.IDENTITY,
              a: [TOP, TOP]
            };
          }
          var theta = Math.atan2(td.c.y - sd.c.y, td.c.x - sd.c.x),
              theta2 = Math.atan2(sd.c.y - td.c.y, sd.c.x - td.c.x);
          var candidates = [],
              midpoints = {};
          (function (types, dim) {
            for (var i = 0; i < types.length; i++) {
              var _midpoints$types$i;
              midpoints[types[i]] = (_midpoints$types$i = {}, _defineProperty$1(_midpoints$types$i, LEFT, {
                x: dim[i][0].x,
                y: dim[i][0].c.y
              }), _defineProperty$1(_midpoints$types$i, RIGHT, {
                x: dim[i][0].x + dim[i][0].w,
                y: dim[i][0].c.y
              }), _defineProperty$1(_midpoints$types$i, TOP, {
                x: dim[i][0].c.x,
                y: dim[i][0].y
              }), _defineProperty$1(_midpoints$types$i, BOTTOM, {
                x: dim[i][0].c.x,
                y: dim[i][0].y + dim[i][0].h
              }), _midpoints$types$i);
              if (dim[i][1] != null && dim[i][1].length > 0) {
                for (var axis in midpoints[types[i]]) {
                  midpoints[types[i]][axis] = _this4.instance._applyRotationsXY(midpoints[types[i]][axis], dim[i][1]);
                }
              }
            }
          })([SOURCE, TARGET], [[sd, sourceRotation], [td, targetRotation]]);
          var FACES = [TOP, LEFT, RIGHT, BOTTOM];
          for (var sf = 0; sf < FACES.length; sf++) {
            for (var tf = 0; tf < FACES.length; tf++) {
              candidates.push({
                source: FACES[sf],
                target: FACES[tf],
                dist: lineLength(midpoints.source[FACES[sf]], midpoints.target[FACES[tf]])
              });
            }
          }
          candidates.sort(function (a, b) {
            if (a.dist < b.dist) {
              return -1;
            } else if (b.dist < a.dist) {
              return 1;
            } else {
              var _axisIndices;
              var axisIndices = (_axisIndices = {}, _defineProperty$1(_axisIndices, LEFT, 0), _defineProperty$1(_axisIndices, TOP, 1), _defineProperty$1(_axisIndices, RIGHT, 2), _defineProperty$1(_axisIndices, BOTTOM, 3), _axisIndices),
                  ais = axisIndices[a.source],
                  bis = axisIndices[b.source],
                  ait = axisIndices[a.target],
                  bit = axisIndices[b.target];
              return ais < bis ? -1 : bis < ais ? 1 : ait < bit ? -1 : bit < ait ? 1 : 0;
            }
          });
          var sourceEdge = candidates[0].source,
              targetEdge = candidates[0].target;
          for (var i = 0; i < candidates.length; i++) {
            if (isContinuous(sourceAnchor) && sourceAnchor.locked) {
              sourceEdge = sourceAnchor.currentFace;
            } else if (!sourceAnchor.isContinuous || isEdgeSupported(sourceAnchor, candidates[i].source)) {
              sourceEdge = candidates[i].source;
            } else {
              sourceEdge = null;
            }
            if (targetAnchor.isContinuous && targetAnchor.locked) {
              targetEdge = targetAnchor.currentFace;
            } else if (!targetAnchor.isContinuous || isEdgeSupported(targetAnchor, candidates[i].target)) {
              targetEdge = candidates[i].target;
            } else {
              targetEdge = null;
            }
            if (sourceEdge != null && targetEdge != null) {
              break;
            }
          }
          if (sourceAnchor.isContinuous) {
            this.setCurrentFace(sourceAnchor, sourceEdge);
          }
          if (targetAnchor.isContinuous) {
            this.setCurrentFace(targetAnchor, targetEdge);
          }
          return {
            a: [sourceEdge, targetEdge],
            theta: theta,
            theta2: theta2
          };
        }
      }, {
        key: "setCurrentFace",
        value: function setCurrentFace(a, face, overrideLock) {
          a.currentFace = face;
          if (overrideLock && a.lockedFace != null) {
            a.lockedFace = a.currentFace;
          }
        }
      }, {
        key: "lock",
        value: function lock(a) {
          a.locked = true;
          if (isContinuous(a)) {
            a.lockedFace = a.currentFace;
          }
        }
      }, {
        key: "unlock",
        value: function unlock(a) {
          a.locked = false;
          if (isContinuous(a)) {
            a.lockedFace = null;
          }
        }
      }, {
        key: "selectAnchorLocation",
        value: function selectAnchorLocation(a, coords) {
          var idx = findWithFunction(a.locations, function (loc) {
            return loc.x === coords.x && loc.y === coords.y;
          });
          if (idx !== -1) {
            a.currentLocation = idx;
            return true;
          } else {
            return false;
          }
        }
      }, {
        key: "lockCurrentAxis",
        value: function lockCurrentAxis(a) {
          if (a.currentFace != null) {
            a.lockedAxis = a.currentFace === LEFT || a.currentFace === RIGHT ? X_AXIS_FACES : Y_AXIS_FACES;
          }
        }
      }, {
        key: "unlockCurrentAxis",
        value: function unlockCurrentAxis(a) {
          a.lockedAxis = null;
        }
      }, {
        key: "anchorsEqual",
        value: function anchorsEqual(a1, a2) {
          if (!a1 || !a2) {
            return false;
          }
          var l1 = a1.locations[a1.currentLocation],
              l2 = a2.locations[a2.currentLocation];
          return l1.x === l2.x && l1.y === l2.y && l1.offx === l2.offx && l1.offy === l2.offy && l1.ox === l2.ox && l1.oy === l2.oy;
        }
      }]);
      return LightweightRouter;
    }();

    function _scopeMatch(e1, e2) {
      var s1 = e1.scope.split(/\s/),
          s2 = e2.scope.split(/\s/);
      for (var i = 0; i < s1.length; i++) {
        for (var j = 0; j < s2.length; j++) {
          if (s2[j] === s1[i]) {
            return true;
          }
        }
      }
      return false;
    }
    function prepareList(instance, input, doNotGetIds) {
      var r = [];
      var _resolveId = function _resolveId(i) {
        if (isString(i)) {
          return i;
        } else {
          return instance.getId(i);
        }
      };
      if (input) {
        if (typeof input === 'string') {
          if (input === "*") {
            return input;
          }
          r.push(input);
        } else {
          if (doNotGetIds) {
            r = input;
          } else {
            if (input.length != null) {
              var _r;
              (_r = r).push.apply(_r, _toConsumableArray(_toConsumableArray(input).map(_resolveId)));
            } else {
              r.push(_resolveId(input));
            }
          }
        }
      }
      return r;
    }
    function addManagedEndpoint(managedElement, ep) {
      if (managedElement != null) {
        managedElement.endpoints.push(ep);
      }
    }
    function removeManagedEndpoint(managedElement, endpoint) {
      if (managedElement != null) {
        removeWithFunction(managedElement.endpoints, function (ep) {
          return ep === endpoint;
        });
      }
    }
    function addManagedConnection(connection, sourceEl, targetEl) {
      if (sourceEl != null) {
        sourceEl.connections.push(connection);
        if (sourceEl.connections.length === 1) {
          connection.instance.addClass(connection.source, connection.instance.connectedClass);
        }
      }
      if (targetEl != null) {
        if (sourceEl == null || connection.sourceId !== connection.targetId) {
          targetEl.connections.push(connection);
          if (targetEl.connections.length === 1) {
            connection.instance.addClass(connection.target, connection.instance.connectedClass);
          }
        }
      }
    }
    function removeManagedConnection(connection, sourceEl, targetEl) {
      if (sourceEl != null) {
        var sourceCount = sourceEl.connections.length;
        removeWithFunction(sourceEl.connections, function (_c) {
          return connection.id === _c.id;
        });
        if (sourceCount > 0 && sourceEl.connections.length === 0) {
          connection.instance.removeClass(connection.source, connection.instance.connectedClass);
        }
      }
      if (targetEl != null) {
        var targetCount = targetEl.connections.length;
        if (sourceEl == null || connection.sourceId !== connection.targetId) {
          removeWithFunction(targetEl.connections, function (_c) {
            return connection.id === _c.id;
          });
        }
        if (targetCount > 0 && targetEl.connections.length === 0) {
          connection.instance.removeClass(connection.target, connection.instance.connectedClass);
        }
      }
    }
    var JsPlumbInstance = function (_EventGenerator) {
      _inherits$1(JsPlumbInstance, _EventGenerator);
      var _super = _createSuper$1(JsPlumbInstance);
      function JsPlumbInstance(_instanceIndex, defaults) {
        var _this;
        _classCallCheck$1(this, JsPlumbInstance);
        _this = _super.call(this);
        _this._instanceIndex = _instanceIndex;
        _defineProperty$1(_assertThisInitialized$1(_this), "defaults", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "_initialDefaults", {});
        _defineProperty$1(_assertThisInitialized$1(_this), "isConnectionBeingDragged", false);
        _defineProperty$1(_assertThisInitialized$1(_this), "currentlyDragging", false);
        _defineProperty$1(_assertThisInitialized$1(_this), "hoverSuspended", false);
        _defineProperty$1(_assertThisInitialized$1(_this), "_suspendDrawing", false);
        _defineProperty$1(_assertThisInitialized$1(_this), "_suspendedAt", null);
        _defineProperty$1(_assertThisInitialized$1(_this), "connectorClass", CLASS_CONNECTOR);
        _defineProperty$1(_assertThisInitialized$1(_this), "connectorOutlineClass", CLASS_CONNECTOR_OUTLINE);
        _defineProperty$1(_assertThisInitialized$1(_this), "connectedClass", CLASS_CONNECTED);
        _defineProperty$1(_assertThisInitialized$1(_this), "endpointClass", CLASS_ENDPOINT);
        _defineProperty$1(_assertThisInitialized$1(_this), "endpointConnectedClass", CLASS_ENDPOINT_CONNECTED);
        _defineProperty$1(_assertThisInitialized$1(_this), "endpointFullClass", CLASS_ENDPOINT_FULL);
        _defineProperty$1(_assertThisInitialized$1(_this), "endpointDropAllowedClass", CLASS_ENDPOINT_DROP_ALLOWED);
        _defineProperty$1(_assertThisInitialized$1(_this), "endpointDropForbiddenClass", CLASS_ENDPOINT_DROP_FORBIDDEN);
        _defineProperty$1(_assertThisInitialized$1(_this), "endpointAnchorClassPrefix", CLASS_ENDPOINT_ANCHOR_PREFIX);
        _defineProperty$1(_assertThisInitialized$1(_this), "overlayClass", CLASS_OVERLAY);
        _defineProperty$1(_assertThisInitialized$1(_this), "connections", []);
        _defineProperty$1(_assertThisInitialized$1(_this), "endpointsByElement", {});
        _defineProperty$1(_assertThisInitialized$1(_this), "endpointsByUUID", new Map());
        _defineProperty$1(_assertThisInitialized$1(_this), "sourceSelectors", []);
        _defineProperty$1(_assertThisInitialized$1(_this), "targetSelectors", []);
        _defineProperty$1(_assertThisInitialized$1(_this), "allowNestedGroups", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "_curIdStamp", 1);
        _defineProperty$1(_assertThisInitialized$1(_this), "viewport", new Viewport(_assertThisInitialized$1(_this)));
        _defineProperty$1(_assertThisInitialized$1(_this), "router", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "groupManager", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "_connectionTypes", new Map());
        _defineProperty$1(_assertThisInitialized$1(_this), "_endpointTypes", new Map());
        _defineProperty$1(_assertThisInitialized$1(_this), "_container", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "_managedElements", {});
        _defineProperty$1(_assertThisInitialized$1(_this), "DEFAULT_SCOPE", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "_zoom", 1);
        _this.defaults = {
          anchor: AnchorLocations.Bottom,
          anchors: [null, null],
          connectionsDetachable: true,
          connectionOverlays: [],
          connector: StraightConnector.type,
          container: null,
          endpoint: DotEndpoint.type,
          endpointOverlays: [],
          endpoints: [null, null],
          endpointStyle: {
            fill: "#456"
          },
          endpointStyles: [null, null],
          endpointHoverStyle: null,
          endpointHoverStyles: [null, null],
          hoverPaintStyle: null,
          listStyle: {},
          maxConnections: 1,
          paintStyle: {
            strokeWidth: 2,
            stroke: "#456"
          },
          reattachConnections: false,
          scope: "jsplumb_defaultscope",
          allowNestedGroups: true
        };
        if (defaults) {
          extend(_this.defaults, defaults);
        }
        extend(_this._initialDefaults, _this.defaults);
        _this.DEFAULT_SCOPE = _this.defaults.scope;
        _this.allowNestedGroups = _this._initialDefaults.allowNestedGroups !== false;
        _this.router = new LightweightRouter(_assertThisInitialized$1(_this));
        _this.groupManager = new GroupManager(_assertThisInitialized$1(_this));
        _this.setContainer(_this._initialDefaults.container);
        return _this;
      }
      _createClass$1(JsPlumbInstance, [{
        key: "defaultScope",
        get: function get() {
          return this.DEFAULT_SCOPE;
        }
      }, {
        key: "currentZoom",
        get: function get() {
          return this._zoom;
        }
      }, {
        key: "areDefaultAnchorsSet",
        value: function areDefaultAnchorsSet() {
          return this.validAnchorsSpec(this.defaults.anchors);
        }
      }, {
        key: "validAnchorsSpec",
        value: function validAnchorsSpec(anchors) {
          return anchors != null && anchors[0] != null && anchors[1] != null;
        }
      }, {
        key: "getContainer",
        value: function getContainer() {
          return this._container;
        }
      }, {
        key: "setZoom",
        value: function setZoom(z, repaintEverything) {
          this._zoom = z;
          this.fire(EVENT_ZOOM, this._zoom);
          if (repaintEverything) {
            this.repaintEverything();
          }
          return true;
        }
      }, {
        key: "_idstamp",
        value: function _idstamp() {
          return "" + this._curIdStamp++;
        }
      }, {
        key: "checkCondition",
        value: function checkCondition(conditionName, args) {
          var l = this.getListener(conditionName),
              r = true;
          if (l && l.length > 0) {
            var values = Array.prototype.slice.call(arguments, 1);
            try {
              for (var i = 0, j = l.length; i < j; i++) {
                r = r && l[i].apply(l[i], values);
              }
            } catch (e) {
              log("cannot check condition [" + conditionName + "]" + e);
            }
          }
          return r;
        }
      }, {
        key: "getId",
        value: function getId(element, uuid) {
          if (element == null) {
            return null;
          }
          var id = this.getAttribute(element, ATTRIBUTE_MANAGED);
          if (!id || id === "undefined") {
            if (arguments.length === 2 && arguments[1] !== undefined) {
              id = uuid;
            } else if (arguments.length === 1 || arguments.length === 3 && !arguments[2]) {
              id = "jsplumb-" + this._instanceIndex + "-" + this._idstamp();
            }
            this.setAttribute(element, ATTRIBUTE_MANAGED, id);
          }
          return id;
        }
      }, {
        key: "getConnections",
        value: function getConnections(options, flat) {
          if (!options) {
            options = {};
          } else if (options.constructor === String) {
            options = {
              "scope": options
            };
          }
          var scope = options.scope || this.defaultScope,
              scopes = prepareList(this, scope, true),
              sources = prepareList(this, options.source),
              targets = prepareList(this, options.target),
              results = !flat && scopes.length > 1 ? {} : [],
              _addOne = function _addOne(scope, obj) {
            if (!flat && scopes.length > 1) {
              var ss = results[scope];
              if (ss == null) {
                ss = results[scope] = [];
              }
              ss.push(obj);
            } else {
              results.push(obj);
            }
          };
          for (var j = 0, jj = this.connections.length; j < jj; j++) {
            var _c2 = this.connections[j],
                sourceId = _c2.proxies && _c2.proxies[0] ? _c2.proxies[0].originalEp.elementId : _c2.sourceId,
                targetId = _c2.proxies && _c2.proxies[1] ? _c2.proxies[1].originalEp.elementId : _c2.targetId;
            if (filterList(scopes, _c2.scope) && filterList(sources, sourceId) && filterList(targets, targetId)) {
              _addOne(_c2.scope, _c2);
            }
          }
          return results;
        }
      }, {
        key: "select",
        value: function select(params) {
          params = params || {};
          params.scope = params.scope || "*";
          return new ConnectionSelection(this, params.connections || this.getConnections(params, true));
        }
      }, {
        key: "selectEndpoints",
        value: function selectEndpoints(params) {
          params = params || {};
          params.scope = params.scope || WILDCARD;
          var noElementFilters = !params.element && !params.source && !params.target,
              elements = noElementFilters ? WILDCARD : prepareList(this, params.element),
              sources = noElementFilters ? WILDCARD : prepareList(this, params.source),
              targets = noElementFilters ? WILDCARD : prepareList(this, params.target),
              scopes = prepareList(this, params.scope, true);
          var ep = [];
          for (var _el2 in this.endpointsByElement) {
            var either = filterList(elements, _el2, true),
                source = filterList(sources, _el2, true),
                sourceMatchExact = sources !== "*",
                target = filterList(targets, _el2, true),
                targetMatchExact = targets !== "*";
            if (either || source || target) {
              inner: for (var i = 0, ii = this.endpointsByElement[_el2].length; i < ii; i++) {
                var _ep = this.endpointsByElement[_el2][i];
                if (filterList(scopes, _ep.scope, true)) {
                  var noMatchSource = sourceMatchExact && sources.length > 0 && !_ep.isSource,
                      noMatchTarget = targetMatchExact && targets.length > 0 && !_ep.isTarget;
                  if (noMatchSource || noMatchTarget) {
                    continue inner;
                  }
                  ep.push(_ep);
                }
              }
            }
          }
          return new EndpointSelection(this, ep);
        }
      }, {
        key: "setContainer",
        value: function setContainer(c) {
          this._container = c;
          this.fire(EVENT_CONTAINER_CHANGE, this._container);
        }
      }, {
        key: "_set",
        value: function _set(c, el, idx) {
          var stTypes = [{
            el: "source",
            elId: "sourceId"
          }, {
            el: "target",
            elId: "targetId"
          }];
          var ep,
              _st = stTypes[idx],
              cId = c[_st.elId],
              sid,
              oldEndpoint = c.endpoints[idx];
          var evtParams = {
            index: idx,
            originalEndpoint: oldEndpoint,
            originalSourceId: idx === 0 ? cId : c.sourceId,
            newSourceId: c.sourceId,
            originalTargetId: idx === 1 ? cId : c.targetId,
            newTargetId: c.targetId,
            connection: c,
            newEndpoint: oldEndpoint
          };
          if (el instanceof Endpoint) {
            ep = el;
            ep.addConnection(c);
          } else {
            sid = this.getId(el);
            if (sid === c[_st.elId]) {
              ep = null;
            } else {
              ep = c.makeEndpoint(idx === 0, el, sid);
            }
          }
          if (ep != null) {
            evtParams.newEndpoint = ep;
            oldEndpoint.detachFromConnection(c);
            c.endpoints[idx] = ep;
            c[_st.el] = ep.element;
            c[_st.elId] = ep.elementId;
            evtParams[idx === 0 ? "newSourceId" : "newTargetId"] = ep.elementId;
            this.fireMoveEvent(evtParams);
            this.paintConnection(c);
          }
          return evtParams;
        }
      }, {
        key: "setSource",
        value: function setSource(connection, el) {
          removeManagedConnection(connection, this._managedElements[connection.sourceId]);
          var p = this._set(connection, el, 0);
          addManagedConnection(connection, this._managedElements[p.newSourceId]);
        }
      }, {
        key: "setTarget",
        value: function setTarget(connection, el) {
          removeManagedConnection(connection, this._managedElements[connection.targetId]);
          var p = this._set(connection, el, 1);
          addManagedConnection(connection, this._managedElements[p.newTargetId]);
        }
      }, {
        key: "isHoverSuspended",
        value: function isHoverSuspended() {
          return this.hoverSuspended;
        }
      }, {
        key: "setSuspendDrawing",
        value: function setSuspendDrawing(val, repaintAfterwards) {
          var curVal = this._suspendDrawing;
          this._suspendDrawing = val;
          if (val) {
            this._suspendedAt = "" + new Date().getTime();
          } else {
            this._suspendedAt = null;
            this.viewport.recomputeBounds();
          }
          if (repaintAfterwards) {
            this.repaintEverything();
          }
          return curVal;
        }
      }, {
        key: "getSuspendedAt",
        value: function getSuspendedAt() {
          return this._suspendedAt;
        }
      }, {
        key: "batch",
        value: function batch(fn, doNotRepaintAfterwards) {
          var _wasSuspended = this._suspendDrawing === true;
          if (!_wasSuspended) {
            this.setSuspendDrawing(true);
          }
          fn();
          if (!_wasSuspended) {
            this.setSuspendDrawing(false, !doNotRepaintAfterwards);
          }
        }
      }, {
        key: "each",
        value: function each(spec, fn) {
          if (spec == null) {
            return;
          }
          if (spec.length != null) {
            for (var i = 0; i < spec.length; i++) {
              fn(spec[i]);
            }
          } else {
            fn(spec);
          }
          return this;
        }
      }, {
        key: "updateOffset",
        value: function updateOffset(params) {
          var elId = params.elId;
          if (params.recalc) {
            return this.viewport.refreshElement(elId);
          } else {
            return this.viewport.getPosition(elId);
          }
        }
      }, {
        key: "deleteConnection",
        value: function deleteConnection(connection, params) {
          if (connection != null && connection.deleted !== true) {
            params = params || {};
            if (params.force || functionChain(true, false, [[connection.endpoints[0], IS_DETACH_ALLOWED, [connection]], [connection.endpoints[1], IS_DETACH_ALLOWED, [connection]], [connection, IS_DETACH_ALLOWED, [connection]], [this, CHECK_CONDITION, [INTERCEPT_BEFORE_DETACH, connection]]])) {
              removeManagedConnection(connection, this._managedElements[connection.sourceId], this._managedElements[connection.targetId]);
              this.fireDetachEvent(connection, !connection.pending && params.fireEvent !== false, params.originalEvent);
              var sourceEndpoint = connection.endpoints[0];
              var targetEndpoint = connection.endpoints[1];
              if (sourceEndpoint !== params.endpointToIgnore) {
                sourceEndpoint.detachFromConnection(connection, null, true);
              }
              if (targetEndpoint !== params.endpointToIgnore) {
                targetEndpoint.detachFromConnection(connection, null, true);
              }
              removeWithFunction(this.connections, function (_c) {
                return connection.id === _c.id;
              });
              connection.destroy();
              if (sourceEndpoint !== params.endpointToIgnore && sourceEndpoint.deleteOnEmpty && sourceEndpoint.connections.length === 0) {
                this.deleteEndpoint(sourceEndpoint);
              }
              if (targetEndpoint !== params.endpointToIgnore && targetEndpoint.deleteOnEmpty && targetEndpoint.connections.length === 0) {
                this.deleteEndpoint(targetEndpoint);
              }
              return true;
            }
          }
          return false;
        }
      }, {
        key: "deleteEveryConnection",
        value: function deleteEveryConnection(params) {
          var _this2 = this;
          params = params || {};
          var count = this.connections.length,
              deletedCount = 0;
          this.batch(function () {
            for (var i = 0; i < count; i++) {
              deletedCount += _this2.deleteConnection(_this2.connections[0], params) ? 1 : 0;
            }
          });
          return deletedCount;
        }
      }, {
        key: "deleteConnectionsForElement",
        value: function deleteConnectionsForElement(el, params) {
          var id = this.getId(el),
              m = this._managedElements[id];
          if (m) {
            var l = m.connections.length;
            for (var i = 0; i < l; i++) {
              this.deleteConnection(m.connections[0], params);
            }
          }
          return this;
        }
      }, {
        key: "fireDetachEvent",
        value: function fireDetachEvent(jpc, doFireEvent, originalEvent) {
          var argIsConnection = jpc.id != null,
              params = argIsConnection ? {
            connection: jpc,
            source: jpc.source,
            target: jpc.target,
            sourceId: jpc.sourceId,
            targetId: jpc.targetId,
            sourceEndpoint: jpc.endpoints[0],
            targetEndpoint: jpc.endpoints[1]
          } : jpc;
          if (doFireEvent) {
            this.fire(EVENT_CONNECTION_DETACHED, params, originalEvent);
          }
          this.fire(EVENT_INTERNAL_CONNECTION_DETACHED, params, originalEvent);
        }
      }, {
        key: "fireMoveEvent",
        value: function fireMoveEvent(params, evt) {
          this.fire(EVENT_CONNECTION_MOVED, params, evt);
        }
      }, {
        key: "manageAll",
        value: function manageAll(elements, recalc) {
          var nl = isString(elements) ? this.getSelector(this.getContainer(), elements) : elements;
          for (var i = 0; i < nl.length; i++) {
            this.manage(nl[i], null, recalc);
          }
        }
      }, {
        key: "manage",
        value: function manage(element, internalId, _recalc) {
          if (this.getAttribute(element, ATTRIBUTE_MANAGED) == null) {
            internalId = internalId || this.getAttribute(element, "id") || uuid();
            this.setAttribute(element, ATTRIBUTE_MANAGED, internalId);
          }
          var elId = this.getId(element);
          if (!this._managedElements[elId]) {
            var obj = {
              el: element,
              endpoints: [],
              connections: [],
              rotation: 0,
              data: {}
            };
            this._managedElements[elId] = obj;
            if (this._suspendDrawing) {
              obj.viewportElement = this.viewport.registerElement(elId, true);
            } else {
              obj.viewportElement = this.updateOffset({
                elId: elId,
                recalc: true
              });
            }
            this.fire(EVENT_MANAGE_ELEMENT, {
              el: element
            });
          } else {
            if (_recalc) {
              this._managedElements[elId].viewportElement = this.updateOffset({
                elId: elId,
                timestamp: null,
                recalc: true
              });
            }
          }
          return this._managedElements[elId];
        }
      }, {
        key: "getManagedData",
        value: function getManagedData(elementId, dataIdentifier, key) {
          if (this._managedElements[elementId]) {
            var data = this._managedElements[elementId].data[dataIdentifier];
            return data != null ? data[key] : null;
          }
        }
      }, {
        key: "setManagedData",
        value: function setManagedData(elementId, dataIdentifier, key, data) {
          if (this._managedElements[elementId]) {
            this._managedElements[elementId].data[dataIdentifier] = this._managedElements[elementId].data[dataIdentifier] || {};
            this._managedElements[elementId].data[dataIdentifier][key] = data;
          }
        }
      }, {
        key: "getManagedElement",
        value: function getManagedElement(id) {
          return this._managedElements[id] ? this._managedElements[id].el : null;
        }
      }, {
        key: "unmanage",
        value: function unmanage(el, removeElement) {
          var _this3 = this;
          this.removeAllEndpoints(el, true);
          var _one = function _one(_el) {
            var id = _this3.getId(_el);
            _this3.removeAttribute(_el, ATTRIBUTE_MANAGED);
            delete _this3._managedElements[id];
            _this3.viewport.remove(id);
            _this3.fire(EVENT_UNMANAGE_ELEMENT, {
              el: _el
            });
            if (_el && removeElement) {
              _this3._removeElement(_el);
            }
          };
          this._getAssociatedElements(el).map(_one);
          _one(el);
        }
      }, {
        key: "rotate",
        value: function rotate(element, rotation, _doNotRepaint) {
          var elementId = this.getId(element);
          if (this._managedElements[elementId]) {
            this._managedElements[elementId].rotation = rotation;
            this.viewport.rotateElement(elementId, rotation);
            if (_doNotRepaint !== true) {
              return this.revalidate(element);
            }
          }
          return {
            c: new Set(),
            e: new Set()
          };
        }
      }, {
        key: "_getRotation",
        value: function _getRotation(elementId) {
          var entry = this._managedElements[elementId];
          if (entry != null) {
            return entry.rotation || 0;
          } else {
            return 0;
          }
        }
      }, {
        key: "_getRotations",
        value: function _getRotations(elementId) {
          var _this4 = this;
          var rotations = [];
          var entry = this._managedElements[elementId];
          var _oneLevel = function _oneLevel(e) {
            if (e.group != null) {
              var gEntry = _this4._managedElements[e.group];
              if (gEntry != null) {
                rotations.push({
                  r: gEntry.viewportElement.r,
                  c: gEntry.viewportElement.c
                });
                _oneLevel(gEntry);
              }
            }
          };
          if (entry != null) {
            rotations.push({
              r: entry.viewportElement.r || 0,
              c: entry.viewportElement.c
            });
            _oneLevel(entry);
          }
          return rotations;
        }
      }, {
        key: "_applyRotations",
        value: function _applyRotations(point, rotations) {
          var sl = point.slice();
          var current = {
            x: sl[0],
            y: sl[1],
            cr: 0,
            sr: 0
          };
          forEach(rotations, function (rotation) {
            current = rotatePoint(current, rotation.c, rotation.r);
          });
          return current;
        }
      }, {
        key: "_applyRotationsXY",
        value: function _applyRotationsXY(point, rotations) {
          forEach(rotations, function (rotation) {
            point = rotatePoint(point, rotation.c, rotation.r);
          });
          return point;
        }
      }, {
        key: "_internal_newEndpoint",
        value: function _internal_newEndpoint(params) {
          var _p = extend({}, params);
          var managedElement = this.manage(_p.element);
          _p.elementId = this.getId(_p.element);
          _p.id = "ep_" + this._idstamp();
          var ep = new Endpoint(this, _p);
          addManagedEndpoint(managedElement, ep);
          if (params.uuid) {
            this.endpointsByUUID.set(params.uuid, ep);
          }
          addToDictionary(this.endpointsByElement, ep.elementId, ep);
          if (!this._suspendDrawing) {
            this.paintEndpoint(ep, {
              timestamp: this._suspendedAt
            });
          }
          return ep;
        }
      }, {
        key: "_deriveEndpointAndAnchorSpec",
        value: function _deriveEndpointAndAnchorSpec(type, dontPrependDefault) {
          var bits = ((dontPrependDefault ? "" : "default ") + type).split(/[\s]/),
              eps = null,
              ep = null,
              a = null,
              as = null;
          for (var i = 0; i < bits.length; i++) {
            var _t = this.getConnectionType(bits[i]);
            if (_t) {
              if (_t.endpoints) {
                eps = _t.endpoints;
              }
              if (_t.endpoint) {
                ep = _t.endpoint;
              }
              if (_t.anchors) {
                as = _t.anchors;
              }
              if (_t.anchor) {
                a = _t.anchor;
              }
            }
          }
          return {
            endpoints: eps ? eps : [ep, ep],
            anchors: as ? as : [a, a]
          };
        }
      }, {
        key: "revalidate",
        value: function revalidate(el, timestamp) {
          var elId = this.getId(el);
          this.updateOffset({
            elId: elId,
            recalc: true,
            timestamp: timestamp
          });
          return this.repaint(el);
        }
      }, {
        key: "repaintEverything",
        value: function repaintEverything() {
          var timestamp = uuid(),
              elId;
          for (elId in this._managedElements) {
            this.viewport.refreshElement(elId, true);
          }
          this.viewport.recomputeBounds();
          for (elId in this._managedElements) {
            this.repaint(this._managedElements[elId].el, timestamp, true);
          }
          return this;
        }
      }, {
        key: "setElementPosition",
        value: function setElementPosition(el, x, y) {
          var id = this.getId(el);
          this.viewport.setPosition(id, x, y);
          return this.repaint(el);
        }
      }, {
        key: "repaint",
        value: function repaint(el, timestamp, offsetsWereJustCalculated) {
          var r = {
            c: new Set(),
            e: new Set()
          };
          var _mergeRedraw = function _mergeRedraw(r2) {
            r2.c.forEach(function (c) {
              return r.c.add(c);
            });
            r2.e.forEach(function (e) {
              return r.e.add(e);
            });
          };
          if (!this._suspendDrawing) {
            var id = this.getId(el);
            if (el != null) {
              var repaintEls = this._getAssociatedElements(el);
              if (timestamp == null) {
                timestamp = uuid();
              }
              if (!offsetsWereJustCalculated) {
                for (var i = 0; i < repaintEls.length; i++) {
                  this.updateOffset({
                    elId: this.getId(repaintEls[i]),
                    recalc: true,
                    timestamp: timestamp
                  });
                }
              }
              _mergeRedraw(this.router.redraw(id, timestamp, null));
              if (repaintEls.length > 0) {
                for (var j = 0; j < repaintEls.length; j++) {
                  _mergeRedraw(this.router.redraw(this.getId(repaintEls[j]), timestamp, null));
                }
              }
            }
          }
          return r;
        }
      }, {
        key: "unregisterEndpoint",
        value: function unregisterEndpoint(endpoint) {
          var uuid = endpoint.getUuid();
          if (uuid) {
            this.endpointsByUUID["delete"](uuid);
          }
          removeManagedEndpoint(this._managedElements[endpoint.elementId], endpoint);
          for (var _e in this.endpointsByElement) {
            var endpoints = this.endpointsByElement[_e];
            if (endpoints) {
              var newEndpoints = [];
              for (var i = 0, j = endpoints.length; i < j; i++) {
                if (endpoints[i] !== endpoint) {
                  newEndpoints.push(endpoints[i]);
                }
              }
              this.endpointsByElement[_e] = newEndpoints;
            }
            if (this.endpointsByElement[_e].length < 1) {
              delete this.endpointsByElement[_e];
            }
          }
          this.fire(EVENT_INTERNAL_ENDPOINT_UNREGISTERED, endpoint);
        }
      }, {
        key: "_maybePruneEndpoint",
        value: function _maybePruneEndpoint(endpoint) {
          if (endpoint.deleteOnEmpty && endpoint.connections.length === 0) {
            this.deleteEndpoint(endpoint);
            return true;
          } else {
            return false;
          }
        }
      }, {
        key: "deleteEndpoint",
        value: function deleteEndpoint(object) {
          var _this5 = this;
          var endpoint = typeof object === "string" ? this.endpointsByUUID.get(object) : object;
          if (endpoint) {
            var proxy = endpoint.proxiedBy;
            var connectionsToDelete = endpoint.connections.slice();
            forEach(connectionsToDelete, function (connection) {
              endpoint.detachFromConnection(connection, null, true);
            });
            this.unregisterEndpoint(endpoint);
            endpoint.destroy();
            forEach(connectionsToDelete, function (connection) {
              _this5.deleteConnection(connection, {
                force: true,
                endpointToIgnore: endpoint
              });
            });
            if (proxy != null) {
              this.deleteEndpoint(proxy);
            }
          }
          return this;
        }
      }, {
        key: "addEndpoint",
        value: function addEndpoint(el, params, referenceParams) {
          referenceParams = referenceParams || {};
          var p = extend({}, referenceParams);
          extend(p, params || {});
          var _p = extend({
            element: el
          }, p);
          return this._internal_newEndpoint(_p);
        }
      }, {
        key: "addEndpoints",
        value: function addEndpoints(el, endpoints, referenceParams) {
          var results = [];
          for (var i = 0, j = endpoints.length; i < j; i++) {
            results.push(this.addEndpoint(el, endpoints[i], referenceParams));
          }
          return results;
        }
      }, {
        key: "reset",
        value: function reset() {
          var _this6 = this;
          this.silently(function () {
            _this6.endpointsByElement = {};
            _this6._managedElements = {};
            _this6.endpointsByUUID.clear();
            _this6.viewport.reset();
            _this6.router.reset();
            _this6.groupManager.reset();
            _this6.connections.length = 0;
          });
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.reset();
          this.unbind();
          this.sourceSelectors.length = 0;
          this.targetSelectors.length = 0;
          this._connectionTypes.clear();
          this._endpointTypes.clear();
        }
      }, {
        key: "getEndpoints",
        value: function getEndpoints(el) {
          return this.endpointsByElement[this.getId(el)] || [];
        }
      }, {
        key: "getEndpoint",
        value: function getEndpoint(uuid) {
          return this.endpointsByUUID.get(uuid);
        }
      }, {
        key: "setEndpointUuid",
        value: function setEndpointUuid(endpoint, uuid) {
          if (endpoint.uuid) {
            this.endpointsByUUID["delete"](endpoint.uuid);
          }
          endpoint.uuid = uuid;
          this.endpointsByUUID.set(uuid, endpoint);
        }
      }, {
        key: "connect",
        value: function connect(params, referenceParams) {
          try {
            var _p = this._prepareConnectionParams(params, referenceParams),
                jpc = this._newConnection(_p);
            this._finaliseConnection(jpc, _p);
            return jpc;
          } catch (errorMessage) {
            log(errorMessage);
            return;
          }
        }
      }, {
        key: "_prepareConnectionParams",
        value: function _prepareConnectionParams(params, referenceParams) {
          var temp = extend({}, params);
          if (referenceParams) {
            extend(temp, referenceParams);
          }
          var _p = temp;
          if (_p.source) {
            if (_p.source.endpoint) {
              _p.sourceEndpoint = _p.source;
            }
          }
          if (_p.target) {
            if (_p.target.endpoint) {
              _p.targetEndpoint = _p.target;
            }
          }
          if (params.uuids) {
            _p.sourceEndpoint = this.getEndpoint(params.uuids[0]);
            _p.targetEndpoint = this.getEndpoint(params.uuids[1]);
          }
          if (_p.sourceEndpoint != null) {
            if (_p.sourceEndpoint.isFull()) {
              throw ERROR_SOURCE_ENDPOINT_FULL;
            }
            if (!_p.type) {
              _p.type = _p.sourceEndpoint.edgeType;
            }
            if (_p.sourceEndpoint.connectorOverlays) {
              _p.overlays = _p.overlays || [];
              for (var i = 0, j = _p.sourceEndpoint.connectorOverlays.length; i < j; i++) {
                _p.overlays.push(_p.sourceEndpoint.connectorOverlays[i]);
              }
            }
            if (_p.sourceEndpoint.scope) {
              _p.scope = _p.sourceEndpoint.scope;
            }
          } else {
            if (_p.source == null) {
              throw ERROR_SOURCE_DOES_NOT_EXIST;
            }
          }
          if (_p.targetEndpoint != null) {
            if (_p.targetEndpoint.isFull()) {
              throw ERROR_TARGET_ENDPOINT_FULL;
            }
          } else {
            if (_p.target == null) {
              throw ERROR_TARGET_DOES_NOT_EXIST;
            }
          }
          if (_p.sourceEndpoint && _p.targetEndpoint) {
            if (!_scopeMatch(_p.sourceEndpoint, _p.targetEndpoint)) {
              throw "Cannot establish connection: scopes do not match";
            }
          }
          return _p;
        }
      }, {
        key: "_newConnection",
        value: function _newConnection(params) {
          params.id = "con_" + this._idstamp();
          var c = new Connection(this, params);
          addManagedConnection(c, this._managedElements[c.sourceId], this._managedElements[c.targetId]);
          this.paintConnection(c);
          return c;
        }
      }, {
        key: "_finaliseConnection",
        value: function _finaliseConnection(jpc, params, originalEvent) {
          params = params || {};
          if (!jpc.suspendedEndpoint) {
            this.connections.push(jpc);
          }
          jpc.pending = null;
          jpc.endpoints[0].isTemporarySource = false;
          this.repaint(jpc.source);
          var payload = {
            connection: jpc,
            source: jpc.source,
            target: jpc.target,
            sourceId: jpc.sourceId,
            targetId: jpc.targetId,
            sourceEndpoint: jpc.endpoints[0],
            targetEndpoint: jpc.endpoints[1]
          };
          this.fire(EVENT_INTERNAL_CONNECTION, payload, originalEvent);
          if (!params.doNotFireConnectionEvent && params.fireEvent !== false) {
            this.fire(EVENT_CONNECTION, payload, originalEvent);
          }
        }
      }, {
        key: "removeAllEndpoints",
        value: function removeAllEndpoints(el, recurse) {
          var _this7 = this;
          var _one = function _one(_el) {
            var id = _this7.getId(_el),
                ebe = _this7.endpointsByElement[id],
                i,
                ii;
            if (ebe) {
              for (i = 0, ii = ebe.length; i < ii; i++) {
                _this7.deleteEndpoint(ebe[i]);
              }
            }
            delete _this7.endpointsByElement[id];
          };
          if (recurse) {
            this._getAssociatedElements(el).map(_one);
          }
          _one(el);
          return this;
        }
      }, {
        key: "_createSourceDefinition",
        value: function _createSourceDefinition(params, referenceParams) {
          var p = extend({}, referenceParams);
          extend(p, params);
          p.edgeType = p.edgeType || DEFAULT;
          var aae = this._deriveEndpointAndAnchorSpec(p.edgeType);
          p.endpoint = p.endpoint || aae.endpoints[0];
          p.anchor = p.anchor || aae.anchors[0];
          var maxConnections = p.maxConnections || -1;
          var _def = {
            def: extend({}, p),
            uniqueEndpoint: p.uniqueEndpoint,
            maxConnections: maxConnections,
            enabled: true,
            endpoint: null
          };
          return _def;
        }
      }, {
        key: "addSourceSelector",
        value: function addSourceSelector(selector, params) {
          var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var _def = this._createSourceDefinition(params);
          var sel = new SourceSelector(selector, _def, exclude);
          this.sourceSelectors.push(sel);
          return sel;
        }
      }, {
        key: "removeSourceSelector",
        value: function removeSourceSelector(selector) {
          removeWithFunction(this.sourceSelectors, function (s) {
            return s === selector;
          });
        }
      }, {
        key: "removeTargetSelector",
        value: function removeTargetSelector(selector) {
          removeWithFunction(this.targetSelectors, function (s) {
            return s === selector;
          });
        }
      }, {
        key: "addTargetSelector",
        value: function addTargetSelector(selector, params) {
          var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var _def = this._createTargetDefinition(params);
          var sel = new TargetSelector(selector, _def, exclude);
          this.targetSelectors.push(sel);
          return sel;
        }
      }, {
        key: "_createTargetDefinition",
        value: function _createTargetDefinition(params, referenceParams) {
          var p = extend({}, referenceParams);
          extend(p, params);
          p.edgeType = p.edgeType || DEFAULT;
          var maxConnections = p.maxConnections || -1;
          var _def = {
            def: extend({}, p),
            uniqueEndpoint: p.uniqueEndpoint,
            maxConnections: maxConnections,
            enabled: true,
            endpoint: null
          };
          return _def;
        }
      }, {
        key: "show",
        value: function show(el, changeEndpoints) {
          return this._setVisible(el, BLOCK, changeEndpoints);
        }
      }, {
        key: "hide",
        value: function hide(el, changeEndpoints) {
          return this._setVisible(el, NONE, changeEndpoints);
        }
      }, {
        key: "_setVisible",
        value: function _setVisible(el, state, alsoChangeEndpoints) {
          var visible = state === BLOCK;
          var endpointFunc = null;
          if (alsoChangeEndpoints) {
            endpointFunc = function endpointFunc(ep) {
              ep.setVisible(visible, true, true);
            };
          }
          var id = this.getId(el);
          this._operation(el, function (jpc) {
            if (visible && alsoChangeEndpoints) {
              var oidx = jpc.sourceId === id ? 1 : 0;
              if (jpc.endpoints[oidx].isVisible()) {
                jpc.setVisible(true);
              }
            } else {
              jpc.setVisible(visible);
            }
          }, endpointFunc);
          return this;
        }
      }, {
        key: "toggleVisible",
        value: function toggleVisible(el, changeEndpoints) {
          var endpointFunc = null;
          if (changeEndpoints) {
            endpointFunc = function endpointFunc(ep) {
              var state = ep.isVisible();
              ep.setVisible(!state);
            };
          }
          this._operation(el, function (jpc) {
            var state = jpc.isVisible();
            jpc.setVisible(!state);
          }, endpointFunc);
        }
      }, {
        key: "_operation",
        value: function _operation(el, func, endpointFunc) {
          var elId = this.getId(el);
          var endpoints = this.endpointsByElement[elId];
          if (endpoints && endpoints.length) {
            for (var i = 0, ii = endpoints.length; i < ii; i++) {
              for (var j = 0, jj = endpoints[i].connections.length; j < jj; j++) {
                var retVal = func(endpoints[i].connections[j]);
                if (retVal) {
                  return;
                }
              }
              if (endpointFunc) {
                endpointFunc(endpoints[i]);
              }
            }
          }
        }
      }, {
        key: "registerConnectionType",
        value: function registerConnectionType(id, type) {
          this._connectionTypes.set(id, extend({}, type));
          if (type.overlays) {
            var to = {};
            for (var i = 0; i < type.overlays.length; i++) {
              var fo = convertToFullOverlaySpec(type.overlays[i]);
              to[fo.options.id] = fo;
            }
            this._connectionTypes.get(id).overlays = to;
          }
        }
      }, {
        key: "registerConnectionTypes",
        value: function registerConnectionTypes(types) {
          for (var i in types) {
            this.registerConnectionType(i, types[i]);
          }
        }
      }, {
        key: "registerEndpointType",
        value: function registerEndpointType(id, type) {
          this._endpointTypes.set(id, extend({}, type));
          if (type.overlays) {
            var to = {};
            for (var i = 0; i < type.overlays.length; i++) {
              var fo = convertToFullOverlaySpec(type.overlays[i]);
              to[fo.options.id] = fo;
            }
            this._endpointTypes.get(id).overlays = to;
          }
        }
      }, {
        key: "registerEndpointTypes",
        value: function registerEndpointTypes(types) {
          for (var i in types) {
            this.registerEndpointType(i, types[i]);
          }
        }
      }, {
        key: "getType",
        value: function getType(id, typeDescriptor) {
          return typeDescriptor === "connection" ? this.getConnectionType(id) : this.getEndpointType(id);
        }
      }, {
        key: "getConnectionType",
        value: function getConnectionType(id) {
          return this._connectionTypes.get(id);
        }
      }, {
        key: "getEndpointType",
        value: function getEndpointType(id) {
          return this._endpointTypes.get(id);
        }
      }, {
        key: "importDefaults",
        value: function importDefaults(d) {
          for (var i in d) {
            this.defaults[i] = d[i];
          }
          if (d.container) {
            this.setContainer(d.container);
          }
          return this;
        }
      }, {
        key: "restoreDefaults",
        value: function restoreDefaults() {
          this.defaults = extend({}, this._initialDefaults);
          return this;
        }
      }, {
        key: "getManagedElements",
        value: function getManagedElements() {
          return this._managedElements;
        }
      }, {
        key: "proxyConnection",
        value: function proxyConnection(connection, index, proxyEl, endpointGenerator, anchorGenerator) {
          var alreadyProxied = connection.proxies[index] != null,
              proxyEp,
              originalElementId = alreadyProxied ? connection.proxies[index].originalEp.elementId : connection.endpoints[index].elementId,
              originalEndpoint = alreadyProxied ? connection.proxies[index].originalEp : connection.endpoints[index],
              proxyElId = this.getId(proxyEl);
          if (connection.proxies[index]) {
            if (connection.proxies[index].ep.elementId === proxyElId) {
              proxyEp = connection.proxies[index].ep;
            } else {
              connection.proxies[index].ep.detachFromConnection(connection, index);
              proxyEp = this._internal_newEndpoint({
                element: proxyEl,
                endpoint: endpointGenerator(connection, index),
                anchor: anchorGenerator(connection, index),
                parameters: {
                  isProxyEndpoint: true
                }
              });
            }
          } else {
            proxyEp = this._internal_newEndpoint({
              element: proxyEl,
              endpoint: endpointGenerator(connection, index),
              anchor: anchorGenerator(connection, index),
              parameters: {
                isProxyEndpoint: true
              }
            });
          }
          proxyEp.deleteOnEmpty = true;
          connection.proxies[index] = {
            ep: proxyEp,
            originalEp: originalEndpoint
          };
          this.sourceOrTargetChanged(originalElementId, proxyElId, connection, proxyEl, index);
          originalEndpoint.detachFromConnection(connection, null, true);
          proxyEp.connections = [connection];
          connection.endpoints[index] = proxyEp;
          originalEndpoint.proxiedBy = proxyEp;
          originalEndpoint.setVisible(false);
          connection.setVisible(true);
          this.revalidate(proxyEl);
        }
      }, {
        key: "unproxyConnection",
        value: function unproxyConnection(connection, index) {
          if (connection.proxies == null || connection.proxies[index] == null) {
            return;
          }
          var originalElement = connection.proxies[index].originalEp.element,
              originalElementId = connection.proxies[index].originalEp.elementId,
              proxyElId = connection.proxies[index].ep.elementId;
          connection.endpoints[index] = connection.proxies[index].originalEp;
          delete connection.proxies[index].originalEp.proxiedBy;
          this.sourceOrTargetChanged(proxyElId, originalElementId, connection, originalElement, index);
          connection.proxies[index].ep.detachFromConnection(connection, null);
          connection.proxies[index].originalEp.addConnection(connection);
          if (connection.isVisible()) {
            connection.proxies[index].originalEp.setVisible(true);
          }
          connection.proxies[index] = null;
          if (findWithFunction(connection.proxies, function (p) {
            return p != null;
          }) === -1) {
            connection.proxies.length = 0;
          }
        }
      }, {
        key: "sourceOrTargetChanged",
        value: function sourceOrTargetChanged(originalId, newId, connection, newElement, index) {
          if (originalId !== newId) {
            if (index === 0) {
              connection.sourceId = newId;
              connection.source = newElement;
            } else if (index === 1) {
              connection.targetId = newId;
              connection.target = newElement;
            }
            removeManagedConnection(connection, this._managedElements[originalId]);
            addManagedConnection(connection, this._managedElements[newId]);
          }
        }
      }, {
        key: "getGroup",
        value: function getGroup(groupId) {
          return this.groupManager.getGroup(groupId);
        }
      }, {
        key: "getGroupFor",
        value: function getGroupFor(el) {
          return this.groupManager.getGroupFor(el);
        }
      }, {
        key: "addGroup",
        value: function addGroup(params) {
          return this.groupManager.addGroup(params);
        }
      }, {
        key: "addToGroup",
        value: function addToGroup(group) {
          var _this$groupManager;
          for (var _len = arguments.length, el = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            el[_key - 1] = arguments[_key];
          }
          return (_this$groupManager = this.groupManager).addToGroup.apply(_this$groupManager, [group, false].concat(el));
        }
      }, {
        key: "collapseGroup",
        value: function collapseGroup(group) {
          this.groupManager.collapseGroup(group);
        }
      }, {
        key: "expandGroup",
        value: function expandGroup(group) {
          this.groupManager.expandGroup(group);
        }
      }, {
        key: "toggleGroup",
        value: function toggleGroup(group) {
          this.groupManager.toggleGroup(group);
        }
      }, {
        key: "removeGroup",
        value: function removeGroup(group, deleteMembers, manipulateView, doNotFireEvent) {
          return this.groupManager.removeGroup(group, deleteMembers, manipulateView, doNotFireEvent);
        }
      }, {
        key: "removeAllGroups",
        value: function removeAllGroups(deleteMembers, manipulateView) {
          this.groupManager.removeAllGroups(deleteMembers, manipulateView, false);
        }
      }, {
        key: "removeFromGroup",
        value: function removeFromGroup(group, el, doNotFireEvent) {
          this.groupManager.removeFromGroup(group, doNotFireEvent, el);
          this._appendElement(el, this.getContainer());
          this.updateOffset({
            recalc: true,
            elId: this.getId(el)
          });
        }
      }, {
        key: "paintEndpoint",
        value: function paintEndpoint(endpoint, params) {
          function findConnectionToUseForDynamicAnchor(ep) {
            var idx = 0;
            if (params.elementWithPrecedence != null) {
              for (var i = 0; i < ep.connections.length; i++) {
                if (ep.connections[i].sourceId === params.elementWithPrecedence || ep.connections[i].targetId === params.elementWithPrecedence) {
                  idx = i;
                  break;
                }
              }
            }
            return ep.connections[idx];
          }
          params = params || {};
          var timestamp = params.timestamp,
              recalc = !(params.recalc === false);
          if (!timestamp || endpoint.timestamp !== timestamp) {
            var info = this.viewport.getPosition(endpoint.elementId);
            var xy = params.offset ? {
              x: params.offset.x,
              y: params.offset.y
            } : {
              x: info.x,
              y: info.y
            };
            if (xy != null) {
              var ap = params.anchorLoc;
              if (ap == null) {
                var anchorParams = {
                  xy: xy,
                  wh: info,
                  element: endpoint,
                  timestamp: timestamp
                };
                if (recalc && this.router.isDynamicAnchor(endpoint) && endpoint.connections.length > 0) {
                  var _c3 = findConnectionToUseForDynamicAnchor(endpoint),
                      oIdx = _c3.endpoints[0] === endpoint ? 1 : 0,
                      oId = oIdx === 0 ? _c3.sourceId : _c3.targetId,
                      oInfo = this.viewport.getPosition(oId);
                  anchorParams.index = oIdx === 0 ? 1 : 0;
                  anchorParams.connection = _c3;
                  anchorParams.txy = oInfo;
                  anchorParams.twh = oInfo;
                  anchorParams.tElement = _c3.endpoints[oIdx];
                  anchorParams.tRotation = this._getRotations(oId);
                } else if (endpoint.connections.length > 0) {
                  anchorParams.connection = endpoint.connections[0];
                }
                anchorParams.rotation = this._getRotations(endpoint.elementId);
                ap = this.router.computeAnchorLocation(endpoint._anchor, anchorParams);
              }
              endpoint.endpoint.compute(ap, this.router.getEndpointOrientation(endpoint), endpoint.paintStyleInUse);
              this.renderEndpoint(endpoint, endpoint.paintStyleInUse);
              endpoint.timestamp = timestamp;
              for (var i in endpoint.overlays) {
                if (endpoint.overlays.hasOwnProperty(i)) {
                  var _o = endpoint.overlays[i];
                  if (_o.isVisible()) {
                    endpoint.overlayPlacements[i] = this.drawOverlay(_o, endpoint.endpoint, endpoint.paintStyleInUse, endpoint.getAbsoluteOverlayPosition(_o));
                    this.paintOverlay(_o, endpoint.overlayPlacements[i], {
                      xmin: 0,
                      ymin: 0
                    });
                  }
                }
              }
            }
          }
        }
      }, {
        key: "paintConnection",
        value: function paintConnection(connection, params) {
          if (!this._suspendDrawing && connection.visible !== false) {
            params = params || {};
            var timestamp = params.timestamp;
            if (timestamp != null && timestamp === connection.lastPaintedAt) {
              return;
            }
            if (timestamp == null || timestamp !== connection.lastPaintedAt) {
              this.router.computePath(connection, timestamp);
              var overlayExtents = {
                xmin: Infinity,
                ymin: Infinity,
                xmax: -Infinity,
                ymax: -Infinity
              };
              for (var i in connection.overlays) {
                if (connection.overlays.hasOwnProperty(i)) {
                  var _o2 = connection.overlays[i];
                  if (_o2.isVisible()) {
                    connection.overlayPlacements[i] = this.drawOverlay(_o2, connection.connector, connection.paintStyleInUse, connection.getAbsoluteOverlayPosition(_o2));
                    overlayExtents.xmin = Math.min(overlayExtents.xmin, connection.overlayPlacements[i].xmin);
                    overlayExtents.xmax = Math.max(overlayExtents.xmax, connection.overlayPlacements[i].xmax);
                    overlayExtents.ymin = Math.min(overlayExtents.ymin, connection.overlayPlacements[i].ymin);
                    overlayExtents.ymax = Math.max(overlayExtents.ymax, connection.overlayPlacements[i].ymax);
                  }
                }
              }
              var lineWidth = parseFloat("" + connection.paintStyleInUse.strokeWidth || "1") / 2,
                  outlineWidth = parseFloat("" + connection.paintStyleInUse.strokeWidth || "0"),
                  _extents = {
                xmin: Math.min(connection.connector.bounds.xmin - (lineWidth + outlineWidth), overlayExtents.xmin),
                ymin: Math.min(connection.connector.bounds.ymin - (lineWidth + outlineWidth), overlayExtents.ymin),
                xmax: Math.max(connection.connector.bounds.xmax + (lineWidth + outlineWidth), overlayExtents.xmax),
                ymax: Math.max(connection.connector.bounds.ymax + (lineWidth + outlineWidth), overlayExtents.ymax)
              };
              this.paintConnector(connection.connector, connection.paintStyleInUse, _extents);
              for (var j in connection.overlays) {
                if (connection.overlays.hasOwnProperty(j)) {
                  var _p2 = connection.overlays[j];
                  if (_p2.isVisible()) {
                    this.paintOverlay(_p2, connection.overlayPlacements[j], _extents);
                  }
                }
              }
            }
            connection.lastPaintedAt = timestamp;
          }
        }
      }, {
        key: "refreshEndpoint",
        value: function refreshEndpoint(endpoint) {
          if (endpoint.connections.length > 0) {
            this.addEndpointClass(endpoint, this.endpointConnectedClass);
          } else {
            this.removeEndpointClass(endpoint, this.endpointConnectedClass);
          }
          if (endpoint.isFull()) {
            this.addEndpointClass(endpoint, this.endpointFullClass);
          } else {
            this.removeEndpointClass(endpoint, this.endpointFullClass);
          }
        }
      }, {
        key: "makeConnector",
        value: function makeConnector(connection, name, args) {
          return Connectors.get(connection, name, args);
        }
      }, {
        key: "getPathData",
        value: function getPathData(connector) {
          var p = "";
          for (var i = 0; i < connector.segments.length; i++) {
            p += connector.segments[i].getPath(i === 0);
            p += " ";
          }
          return p;
        }
      }]);
      return JsPlumbInstance;
    }(EventGenerator);

    var VERY_SMALL_VALUE = 0.0000000001;
    function gentleRound(n) {
      var f = Math.floor(n),
          r = Math.ceil(n);
      if (n - f < VERY_SMALL_VALUE) {
        return f;
      } else if (r - n < VERY_SMALL_VALUE) {
        return r;
      }
      return n;
    }
    var ArcSegment = function (_AbstractSegment) {
      _inherits$1(ArcSegment, _AbstractSegment);
      var _super = _createSuper$1(ArcSegment);
      function ArcSegment(params) {
        var _this;
        _classCallCheck$1(this, ArcSegment);
        _this = _super.call(this, params);
        _defineProperty$1(_assertThisInitialized$1(_this), "type", ArcSegment.segmentType);
        _defineProperty$1(_assertThisInitialized$1(_this), "cx", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "cy", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "radius", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "anticlockwise", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "startAngle", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "endAngle", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "sweep", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "length", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "circumference", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "frac", void 0);
        _this.cx = params.cx;
        _this.cy = params.cy;
        _this.radius = params.r;
        _this.anticlockwise = params.ac;
        if (params.startAngle && params.endAngle) {
          _this.startAngle = params.startAngle;
          _this.endAngle = params.endAngle;
          _this.x1 = _this.cx + _this.radius * Math.cos(_this.startAngle);
          _this.y1 = _this.cy + _this.radius * Math.sin(_this.startAngle);
          _this.x2 = _this.cx + _this.radius * Math.cos(_this.endAngle);
          _this.y2 = _this.cy + _this.radius * Math.sin(_this.endAngle);
        } else {
          _this.startAngle = _this._calcAngle(_this.x1, _this.y1);
          _this.endAngle = _this._calcAngle(_this.x2, _this.y2);
        }
        if (_this.endAngle < 0) {
          _this.endAngle += TWO_PI;
        }
        if (_this.startAngle < 0) {
          _this.startAngle += TWO_PI;
        }
        var ea = _this.endAngle < _this.startAngle ? _this.endAngle + TWO_PI : _this.endAngle;
        _this.sweep = Math.abs(ea - _this.startAngle);
        if (_this.anticlockwise) {
          _this.sweep = TWO_PI - _this.sweep;
        }
        _this.circumference = 2 * Math.PI * _this.radius;
        _this.frac = _this.sweep / TWO_PI;
        _this.length = _this.circumference * _this.frac;
        _this.extents = {
          xmin: _this.cx - _this.radius,
          xmax: _this.cx + _this.radius,
          ymin: _this.cy - _this.radius,
          ymax: _this.cy + _this.radius
        };
        return _this;
      }
      _createClass$1(ArcSegment, [{
        key: "_calcAngle",
        value: function _calcAngle(_x, _y) {
          return theta({
            x: this.cx,
            y: this.cy
          }, {
            x: _x,
            y: _y
          });
        }
      }, {
        key: "_calcAngleForLocation",
        value: function _calcAngleForLocation(segment, location) {
          if (segment.anticlockwise) {
            var sa = segment.startAngle < segment.endAngle ? segment.startAngle + TWO_PI : segment.startAngle,
                s = Math.abs(sa - segment.endAngle);
            return sa - s * location;
          } else {
            var ea = segment.endAngle < segment.startAngle ? segment.endAngle + TWO_PI : segment.endAngle,
                ss = Math.abs(ea - segment.startAngle);
            return segment.startAngle + ss * location;
          }
        }
      }, {
        key: "getPath",
        value: function getPath(isFirstSegment) {
          var laf = this.sweep > Math.PI ? 1 : 0,
              sf = this.anticlockwise ? 0 : 1;
          return (isFirstSegment ? "M" + this.x1 + " " + this.y1 + " " : "") + "A " + this.radius + " " + this.radius + " 0 " + laf + "," + sf + " " + this.x2 + " " + this.y2;
        }
      }, {
        key: "getLength",
        value: function getLength() {
          return this.length;
        }
      }, {
        key: "pointOnPath",
        value: function pointOnPath(location, absolute) {
          if (location === 0) {
            return {
              x: this.x1,
              y: this.y1,
              theta: this.startAngle
            };
          } else if (location === 1) {
            return {
              x: this.x2,
              y: this.y2,
              theta: this.endAngle
            };
          }
          if (absolute) {
            location = location / length;
          }
          var angle = this._calcAngleForLocation(this, location),
              _x = this.cx + this.radius * Math.cos(angle),
              _y = this.cy + this.radius * Math.sin(angle);
          return {
            x: gentleRound(_x),
            y: gentleRound(_y),
            theta: angle
          };
        }
      }, {
        key: "gradientAtPoint",
        value: function gradientAtPoint(location, absolute) {
          var p = this.pointOnPath(location, absolute);
          var m = normal({
            x: this.cx,
            y: this.cy
          }, p);
          if (!this.anticlockwise && (m === Infinity || m === -Infinity)) {
            m *= -1;
          }
          return m;
        }
      }, {
        key: "pointAlongPathFrom",
        value: function pointAlongPathFrom(location, distance, absolute) {
          var p = this.pointOnPath(location, absolute),
              arcSpan = distance / this.circumference * 2 * Math.PI,
              dir = this.anticlockwise ? -1 : 1,
              startAngle = p.theta + dir * arcSpan,
              startX = this.cx + this.radius * Math.cos(startAngle),
              startY = this.cy + this.radius * Math.sin(startAngle);
          return {
            x: startX,
            y: startY
          };
        }
      }]);
      return ArcSegment;
    }(AbstractSegment);
    _defineProperty$1(ArcSegment, "segmentType", "Arc");

    var DEFAULT_WIDTH = 20;
    var DEFAULT_LENGTH = 20;
    var ArrowOverlay = function (_Overlay) {
      _inherits$1(ArrowOverlay, _Overlay);
      var _super = _createSuper$1(ArrowOverlay);
      function ArrowOverlay(instance, component, p) {
        var _this;
        _classCallCheck$1(this, ArrowOverlay);
        _this = _super.call(this, instance, component, p);
        _this.instance = instance;
        _this.component = component;
        _defineProperty$1(_assertThisInitialized$1(_this), "width", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "length", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "foldback", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "direction", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "location", 0.5);
        _defineProperty$1(_assertThisInitialized$1(_this), "paintStyle", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "type", ArrowOverlay.type);
        _defineProperty$1(_assertThisInitialized$1(_this), "cachedDimensions", void 0);
        p = p || {};
        _this.width = p.width || DEFAULT_WIDTH;
        _this.length = p.length || DEFAULT_LENGTH;
        _this.direction = (p.direction || 1) < 0 ? -1 : 1;
        _this.foldback = p.foldback || 0.623;
        _this.paintStyle = p.paintStyle || {
          "strokeWidth": 1
        };
        _this.location = p.location == null ? _this.location : Array.isArray(p.location) ? p.location[0] : p.location;
        return _this;
      }
      _createClass$1(ArrowOverlay, [{
        key: "draw",
        value: function draw(component, currentConnectionPaintStyle, absolutePosition) {
          if (component instanceof AbstractConnector) {
            var connector = component;
            var hxy, mid, txy, tail, cxy;
            if (this.location > 1 || this.location < 0) {
              var fromLoc = this.location < 0 ? 1 : 0;
              hxy = connector.pointAlongPathFrom(fromLoc, this.location, false);
              mid = connector.pointAlongPathFrom(fromLoc, this.location - this.direction * this.length / 2, false);
              txy = pointOnLine(hxy, mid, this.length);
            } else if (this.location === 1) {
              hxy = connector.pointOnPath(this.location);
              mid = connector.pointAlongPathFrom(this.location, -this.length);
              txy = pointOnLine(hxy, mid, this.length);
              if (this.direction === -1) {
                var _ = txy;
                txy = hxy;
                hxy = _;
              }
            } else if (this.location === 0) {
              txy = connector.pointOnPath(this.location);
              mid = connector.pointAlongPathFrom(this.location, this.length);
              hxy = pointOnLine(txy, mid, this.length);
              if (this.direction === -1) {
                var __ = txy;
                txy = hxy;
                hxy = __;
              }
            } else {
              hxy = connector.pointAlongPathFrom(this.location, this.direction * this.length / 2);
              mid = connector.pointOnPath(this.location);
              txy = pointOnLine(hxy, mid, this.length);
            }
            tail = perpendicularLineTo(hxy, txy, this.width);
            cxy = pointOnLine(hxy, txy, this.foldback * this.length);
            var d = {
              hxy: hxy,
              tail: tail,
              cxy: cxy
            },
                stroke = this.paintStyle.stroke || currentConnectionPaintStyle.stroke,
                fill = this.paintStyle.fill || currentConnectionPaintStyle.stroke,
                lineWidth = this.paintStyle.strokeWidth || currentConnectionPaintStyle.strokeWidth;
            return {
              component: component,
              d: d,
              "stroke-width": lineWidth,
              stroke: stroke,
              fill: fill,
              xmin: Math.min(hxy.x, tail[0].x, tail[1].x),
              xmax: Math.max(hxy.x, tail[0].x, tail[1].x),
              ymin: Math.min(hxy.y, tail[0].y, tail[1].y),
              ymax: Math.max(hxy.y, tail[0].y, tail[1].y)
            };
          }
        }
      }, {
        key: "updateFrom",
        value: function updateFrom(d) {}
      }]);
      return ArrowOverlay;
    }(Overlay);
    _defineProperty$1(ArrowOverlay, "type", "Arrow");
    function isArrowOverlay(o) {
      return o.type === ArrowOverlay.type;
    }
    OverlayFactory.register(ArrowOverlay.type, ArrowOverlay);

    var PlainArrowOverlay = function (_ArrowOverlay) {
      _inherits$1(PlainArrowOverlay, _ArrowOverlay);
      var _super = _createSuper$1(PlainArrowOverlay);
      function PlainArrowOverlay(instance, component, p) {
        var _this;
        _classCallCheck$1(this, PlainArrowOverlay);
        _this = _super.call(this, instance, component, p);
        _this.instance = instance;
        _defineProperty$1(_assertThisInitialized$1(_this), "type", PlainArrowOverlay.type);
        _this.foldback = 1;
        return _this;
      }
      return PlainArrowOverlay;
    }(ArrowOverlay);
    _defineProperty$1(PlainArrowOverlay, "type", "PlainArrow");
    function isPlainArrowOverlay(o) {
      return o.type === PlainArrowOverlay.type;
    }
    OverlayFactory.register("PlainArrow", PlainArrowOverlay);

    var DiamondOverlay = function (_ArrowOverlay) {
      _inherits$1(DiamondOverlay, _ArrowOverlay);
      var _super = _createSuper$1(DiamondOverlay);
      function DiamondOverlay(instance, component, p) {
        var _this;
        _classCallCheck$1(this, DiamondOverlay);
        _this = _super.call(this, instance, component, p);
        _this.instance = instance;
        _defineProperty$1(_assertThisInitialized$1(_this), "type", DiamondOverlay.type);
        _this.length = _this.length / 2;
        _this.foldback = 2;
        return _this;
      }
      return DiamondOverlay;
    }(ArrowOverlay);
    _defineProperty$1(DiamondOverlay, "type", "Diamond");
    function isDiamondOverlay(o) {
      return o.type === DiamondOverlay.type;
    }
    OverlayFactory.register(DiamondOverlay.type, DiamondOverlay);

    var CustomOverlay = function (_Overlay) {
      _inherits$1(CustomOverlay, _Overlay);
      var _super = _createSuper$1(CustomOverlay);
      function CustomOverlay(instance, component, p) {
        var _this;
        _classCallCheck$1(this, CustomOverlay);
        _this = _super.call(this, instance, component, p);
        _this.instance = instance;
        _this.component = component;
        _defineProperty$1(_assertThisInitialized$1(_this), "create", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "type", CustomOverlay.type);
        _this.create = p.create;
        return _this;
      }
      _createClass$1(CustomOverlay, [{
        key: "updateFrom",
        value: function updateFrom(d) {}
      }]);
      return CustomOverlay;
    }(Overlay);
    _defineProperty$1(CustomOverlay, "type", "Custom");
    function isCustomOverlay(o) {
      return o.type === CustomOverlay.type;
    }
    OverlayFactory.register("Custom", CustomOverlay);

    EndpointFactory.registerHandler(DotEndpointHandler);
    EndpointFactory.registerHandler(RectangleEndpointHandler);
    EndpointFactory.registerHandler(BlankEndpointHandler);
    Connectors.register(StraightConnector.type, StraightConnector);

    function _typeof(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized(self);
    }

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;

          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return _possibleConstructorReturn(this, result);
      };
    }

    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
      }

      return object;
    }

    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get(target, property, receiver) {
          var base = _superPropBase(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get(target, property, receiver || target);
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;

      var _s, _e;

      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function matchesSelector$1(el, selector, ctx) {
      ctx = ctx || el.parentNode;
      var possibles = ctx.querySelectorAll(selector);
      for (var i = 0; i < possibles.length; i++) {
        if (possibles[i] === el) {
          return true;
        }
      }
      return false;
    }
    function consume(e, doNotPreventDefault) {
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.returnValue = false;
      }
      if (!doNotPreventDefault && e.preventDefault) {
        e.preventDefault();
      }
    }
    function findParent(el, selector, container, matchOnElementAlso) {
      if (matchOnElementAlso && matchesSelector$1(el, selector, container)) {
        return el;
      } else {
        el = el.parentNode;
      }
      while (el != null && el !== container) {
        if (matchesSelector$1(el, selector)) {
          return el;
        } else {
          el = el.parentNode;
        }
      }
    }
    function getEventSource(e) {
      return e.srcElement || e.target;
    }
    function _setClassName(el, cn, classList) {
      cn = fastTrim(cn);
      if (typeof el.className.baseVal !== "undefined") {
        el.className.baseVal = cn;
      } else {
        el.className = cn;
      }
      try {
        var cl = el.classList;
        if (cl != null) {
          while (cl.length > 0) {
            cl.remove(cl.item(0));
          }
          for (var i = 0; i < classList.length; i++) {
            if (classList[i]) {
              cl.add(classList[i]);
            }
          }
        }
      } catch (e) {
        log("JSPLUMB: cannot set class list", e);
      }
    }
    function _getClassName(el) {
      return el.className != null ? typeof el.className.baseVal === "undefined" ? el.className : el.className.baseVal : "";
    }
    function _classManip(el, classesToAdd, classesToRemove) {
      var cta = classesToAdd == null ? [] : Array.isArray(classesToAdd) ? classesToAdd : classesToAdd.split(/\s+/);
      var ctr = classesToRemove == null ? [] : Array.isArray(classesToRemove) ? classesToRemove : classesToRemove.split(/\s+/);
      var className = _getClassName(el),
          curClasses = className.split(/\s+/);
      var _oneSet = function _oneSet(add, classes) {
        for (var i = 0; i < classes.length; i++) {
          if (add) {
            if (curClasses.indexOf(classes[i]) === -1) {
              curClasses.push(classes[i]);
            }
          } else {
            var idx = curClasses.indexOf(classes[i]);
            if (idx !== -1) {
              curClasses.splice(idx, 1);
            }
          }
        }
      };
      _oneSet(true, cta);
      _oneSet(false, ctr);
      _setClassName(el, curClasses.join(" "), curClasses);
    }
    function isNodeList(el) {
      return !isString(el) && !Array.isArray(el) && el.length != null && el.documentElement == null && el.nodeType == null;
    }
    function getClass(el) {
      return _getClassName(el);
    }
    function addClass(el, clazz) {
      var _one = function _one(el, clazz) {
        if (el != null && clazz != null && clazz.length > 0) {
          if (el.classList) {
            var parts = fastTrim(clazz).split(/\s+/);
            forEach(parts, function (part) {
              el.classList.add(part);
            });
          } else {
            _classManip(el, clazz);
          }
        }
      };
      if (isNodeList(el)) {
        forEach(el, function (el) {
          return _one(el, clazz);
        });
      } else {
        _one(el, clazz);
      }
    }
    function hasClass(el, clazz) {
      if (el.classList) {
        return el.classList.contains(clazz);
      } else {
        return _getClassName(el).indexOf(clazz) !== -1;
      }
    }
    function removeClass(el, clazz) {
      var _one = function _one(el, clazz) {
        if (el != null && clazz != null && clazz.length > 0) {
          if (el.classList) {
            var parts = fastTrim(clazz).split(/\s+/);
            parts.forEach(function (part) {
              el.classList.remove(part);
            });
          } else {
            _classManip(el, null, clazz);
          }
        }
      };
      if (isNodeList(el)) {
        forEach(el, function (el) {
          return _one(el, clazz);
        });
      } else {
        _one(el, clazz);
      }
    }
    function toggleClass(el, clazz) {
      var _this = this;
      var _one = function _one(el, clazz) {
        if (el != null && clazz != null && clazz.length > 0) {
          if (el.classList) {
            el.classList.toggle(clazz);
          } else {
            if (_this.hasClass(el, clazz)) {
              _this.removeClass(el, clazz);
            } else {
              _this.addClass(el, clazz);
            }
          }
        }
      };
      if (isNodeList(el)) {
        forEach(el, function (el) {
          return _one(el, clazz);
        });
      } else {
        _one(el, clazz);
      }
    }
    function createElement(tag, style, clazz, atts) {
      return createElementNS(null, tag, style, clazz, atts);
    }
    function createElementNS(ns, tag, style, clazz, atts) {
      var e = ns == null ? document.createElement(tag) : document.createElementNS(ns, tag);
      var i;
      style = style || {};
      for (i in style) {
        e.style[i] = style[i];
      }
      if (clazz) {
        e.className = clazz;
      }
      atts = atts || {};
      for (i in atts) {
        e.setAttribute(i, "" + atts[i]);
      }
      return e;
    }
    function offsetRelativeToRoot(el) {
      var box = el.getBoundingClientRect(),
          body = document.body,
          docElem = document.documentElement,
      scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
          scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
      clientTop = docElem.clientTop || body.clientTop || 0,
          clientLeft = docElem.clientLeft || body.clientLeft || 0,
      top = box.top + scrollTop - clientTop,
          left = box.left + scrollLeft - clientLeft;
      return {
        x: Math.round(left),
        y: Math.round(top)
      };
    }
    function size(el) {
      return {
        w: el.offsetWidth,
        h: el.offsetHeight
      };
    }

    var svgAttributeMap = {
      "stroke-linejoin": "stroke-linejoin",
      "stroke-dashoffset": "stroke-dashoffset",
      "stroke-linecap": "stroke-linecap"
    };
    var STROKE_DASHARRAY = "stroke-dasharray";
    var DASHSTYLE = "dashstyle";
    var FILL = "fill";
    var STROKE = "stroke";
    var STROKE_WIDTH = "stroke-width";
    var LINE_WIDTH = "strokeWidth";
    var ELEMENT_SVG = "svg";
    var ELEMENT_PATH = "path";
    var ns = {
      svg: "http://www.w3.org/2000/svg"
    };
    function _attr(node, attributes) {
      for (var i in attributes) {
        node.setAttribute(i, "" + attributes[i]);
      }
    }
    function _node(name, attributes) {
      attributes = attributes || {};
      attributes.version = "1.1";
      attributes.xmlns = ns.svg;
      return createElementNS(ns.svg, name, null, null, attributes);
    }
    function _pos(d) {
      return "position:absolute;left:" + d[0] + "px;top:" + d[1] + "px";
    }
    function _applyStyles(parent, node, style) {
      node.setAttribute(FILL, style.fill ? style.fill : NONE);
      node.setAttribute(STROKE, style.stroke ? style.stroke : NONE);
      if (style.strokeWidth) {
        node.setAttribute(STROKE_WIDTH, style.strokeWidth);
      }
      if (style[DASHSTYLE] && style[LINE_WIDTH] && !style[STROKE_DASHARRAY]) {
        var sep = style[DASHSTYLE].indexOf(",") === -1 ? " " : ",",
            parts = style[DASHSTYLE].split(sep),
            styleToUse = "";
        forEach(parts, function (p) {
          styleToUse += Math.floor(p * style.strokeWidth) + sep;
        });
        node.setAttribute(STROKE_DASHARRAY, styleToUse);
      } else if (style[STROKE_DASHARRAY]) {
        node.setAttribute(STROKE_DASHARRAY, style[STROKE_DASHARRAY]);
      }
      for (var i in svgAttributeMap) {
        if (style[i]) {
          node.setAttribute(svgAttributeMap[i], style[i]);
        }
      }
    }
    function _appendAtIndex(svg, path, idx) {
      if (svg.childNodes.length > idx) {
        svg.insertBefore(path, svg.childNodes[idx]);
      } else {
        svg.appendChild(path);
      }
    }
    function _size(svg, x, y, w, h) {
      svg.style.width = w + "px";
      svg.style.height = h + "px";
      svg.style.left = x + "px";
      svg.style.top = y + "px";
      svg.height = h;
      svg.width = w;
    }

    function compoundEvent(stem, event, subevent) {
      var a = [stem, event];
      if (subevent) {
        a.push(subevent);
      }
      return a.join(":");
    }
    var ATTRIBUTE_CONTAINER = "data-jtk-container";
    var ATTRIBUTE_GROUP_CONTENT = "data-jtk-group-content";
    var ATTRIBUTE_JTK_ENABLED = "data-jtk-enabled";
    var ATTRIBUTE_JTK_SCOPE = "data-jtk-scope";
    var ENDPOINT = "endpoint";
    var ELEMENT = "element";
    var CONNECTION = "connection";
    var ELEMENT_DIV = "div";
    var EVENT_CLICK = "click";
    var EVENT_CONTEXTMENU = "contextmenu";
    var EVENT_DBL_CLICK = "dblclick";
    var EVENT_DBL_TAP = "dbltap";
    var EVENT_FOCUS = "focus";
    var EVENT_MOUSEDOWN = "mousedown";
    var EVENT_MOUSEENTER = "mouseenter";
    var EVENT_MOUSEEXIT = "mouseexit";
    var EVENT_MOUSEMOVE = "mousemove";
    var EVENT_MOUSEUP = "mouseup";
    var EVENT_MOUSEOUT = "mouseout";
    var EVENT_MOUSEOVER = "mouseover";
    var EVENT_TAP = "tap";
    var EVENT_DRAG_MOVE = "drag:move";
    var EVENT_DRAG_STOP = "drag:stop";
    var EVENT_DRAG_START = "drag:start";
    var EVENT_REVERT = "revert";
    var EVENT_CONNECTION_ABORT = "connection:abort";
    var EVENT_CONNECTION_DRAG = "connection:drag";
    var EVENT_ELEMENT_CLICK = compoundEvent(ELEMENT, EVENT_CLICK);
    var EVENT_ELEMENT_DBL_CLICK = compoundEvent(ELEMENT, EVENT_DBL_CLICK);
    var EVENT_ELEMENT_DBL_TAP = compoundEvent(ELEMENT, EVENT_DBL_TAP);
    var EVENT_ELEMENT_MOUSE_OUT = compoundEvent(ELEMENT, EVENT_MOUSEOUT);
    var EVENT_ELEMENT_MOUSE_OVER = compoundEvent(ELEMENT, EVENT_MOUSEOVER);
    var EVENT_ELEMENT_MOUSE_MOVE = compoundEvent(ELEMENT, EVENT_MOUSEMOVE);
    var EVENT_ELEMENT_MOUSE_UP = compoundEvent(ELEMENT, EVENT_MOUSEUP);
    var EVENT_ELEMENT_MOUSE_DOWN = compoundEvent(ELEMENT, EVENT_MOUSEDOWN);
    var EVENT_ELEMENT_CONTEXTMENU = compoundEvent(ELEMENT, EVENT_CONTEXTMENU);
    var EVENT_ELEMENT_TAP = compoundEvent(ELEMENT, EVENT_TAP);
    var EVENT_ENDPOINT_CLICK = compoundEvent(ENDPOINT, EVENT_CLICK);
    var EVENT_ENDPOINT_DBL_CLICK = compoundEvent(ENDPOINT, EVENT_DBL_CLICK);
    compoundEvent(ENDPOINT, EVENT_DBL_TAP);
    var EVENT_ENDPOINT_MOUSEOUT = compoundEvent(ENDPOINT, EVENT_MOUSEOUT);
    var EVENT_ENDPOINT_MOUSEOVER = compoundEvent(ENDPOINT, EVENT_MOUSEOVER);
    var EVENT_ENDPOINT_MOUSEUP = compoundEvent(ENDPOINT, EVENT_MOUSEUP);
    var EVENT_ENDPOINT_MOUSEDOWN = compoundEvent(ENDPOINT, EVENT_MOUSEDOWN);
    compoundEvent(ENDPOINT, EVENT_TAP);
    var EVENT_CONNECTION_CLICK = compoundEvent(CONNECTION, EVENT_CLICK);
    var EVENT_CONNECTION_DBL_CLICK = compoundEvent(CONNECTION, EVENT_DBL_CLICK);
    var EVENT_CONNECTION_DBL_TAP = compoundEvent(CONNECTION, EVENT_DBL_TAP);
    var EVENT_CONNECTION_MOUSEOUT = compoundEvent(CONNECTION, EVENT_MOUSEOUT);
    var EVENT_CONNECTION_MOUSEOVER = compoundEvent(CONNECTION, EVENT_MOUSEOVER);
    var EVENT_CONNECTION_MOUSEUP = compoundEvent(CONNECTION, EVENT_MOUSEUP);
    var EVENT_CONNECTION_MOUSEDOWN = compoundEvent(CONNECTION, EVENT_MOUSEDOWN);
    var EVENT_CONNECTION_CONTEXTMENU = compoundEvent(CONNECTION, EVENT_CONTEXTMENU);
    var EVENT_CONNECTION_TAP = compoundEvent(CONNECTION, EVENT_TAP);
    var PROPERTY_POSITION = "position";
    var SELECTOR_CONNECTOR = cls(CLASS_CONNECTOR);
    var SELECTOR_ENDPOINT = cls(CLASS_ENDPOINT);
    var SELECTOR_GROUP = att(ATTRIBUTE_GROUP);
    var SELECTOR_GROUP_CONTAINER = att(ATTRIBUTE_GROUP_CONTENT);
    var SELECTOR_OVERLAY = cls(CLASS_OVERLAY);

    function _touch(target, pageX, pageY, screenX, screenY, clientX, clientY) {
      return new Touch({
        target: target,
        identifier: uuid(),
        pageX: pageX,
        pageY: pageY,
        screenX: screenX,
        screenY: screenY,
        clientX: clientX || screenX,
        clientY: clientY || screenY
      });
    }
    function _touchList() {
      var list = [];
      list.push.apply(list, arguments);
      list.item = function (index) {
        return this[index];
      };
      return list;
    }
    function _touchAndList(target, pageX, pageY, screenX, screenY, clientX, clientY) {
      return _touchList(_touch(target, pageX, pageY, screenX, screenY, clientX, clientY));
    }
    function matchesSelector(el, selector, ctx) {
      ctx = ctx || el.parentNode;
      var possibles = ctx.querySelectorAll(selector);
      for (var i = 0; i < possibles.length; i++) {
        if (possibles[i] === el) {
          return true;
        }
      }
      return false;
    }
    function _t(e) {
      return e.srcElement || e.target;
    }
    function _pi(e, target, obj, doCompute) {
      if (!doCompute) return {
        path: [target],
        end: 1
      };else if (typeof e.path !== "undefined" && e.path.indexOf) {
        return {
          path: e.path,
          end: e.path.indexOf(obj)
        };
      } else {
        var out = {
          path: [],
          end: -1
        },
            _one = function _one(el) {
          out.path.push(el);
          if (el === obj) {
            out.end = out.path.length - 1;
          } else if (el.parentNode != null) {
            _one(el.parentNode);
          }
        };
        _one(target);
        return out;
      }
    }
    function _d(l, fn) {
      var i = 0,
          j;
      for (i = 0, j = l.length; i < j; i++) {
        if (l[i][0] === fn) {
          break;
        }
      }
      if (i < l.length) {
        l.splice(i, 1);
      }
    }
    var guid = 1;
    var isTouchDevice = "ontouchstart" in document.documentElement || navigator.maxTouchPoints != null && navigator.maxTouchPoints > 0;
    var isMouseDevice = ("onmousedown" in document.documentElement);
    var touchMap = {
      "mousedown": "touchstart",
      "mouseup": "touchend",
      "mousemove": "touchmove"
    };
    var PAGE = "page";
    var SCREEN = "screen";
    var CLIENT = "client";
    function _genLoc(e, prefix) {
      if (e == null) return {
        x: 0,
        y: 0
      };
      var ts = touches(e),
          t = getTouch(ts, 0);
      return {
        x: t[prefix + "X"],
        y: t[prefix + "Y"]
      };
    }
    function pageLocation(e) {
      return _genLoc(e, PAGE);
    }
    function screenLocation(e) {
      return _genLoc(e, SCREEN);
    }
    function clientLocation(e) {
      return _genLoc(e, CLIENT);
    }
    function getTouch(touches, idx) {
      return touches.item ? touches.item(idx) : touches[idx];
    }
    function touches(e) {
      return e.touches && e.touches.length > 0 ? e.touches : e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches : e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches : [e];
    }
    function touchCount(e) {
      return touches(e).length;
    }
    function _bind(obj, type, fn, originalFn, options) {
      _store(obj, type, fn);
      originalFn.__tauid = fn.__tauid;
      if (obj.addEventListener) {
        obj.addEventListener(type, fn, false, options);
      } else if (obj.attachEvent) {
        var key = type + fn.__tauid;
        obj["e" + key] = fn;
        obj[key] = function () {
          obj["e" + key] && obj["e" + key](window.event);
        };
        obj.attachEvent("on" + type, obj[key]);
      }
    }
    function _unbind(obj, type, fn) {
      var _this = this;
      if (fn == null) return;
      _each$1(obj, function (_el) {
        _unstore(_el, type, fn);
        if (fn.__tauid != null) {
          if (_el.removeEventListener) {
            _el.removeEventListener(type, fn, false);
            if (isTouchDevice && touchMap[type]) _el.removeEventListener(touchMap[type], fn, false);
          } else if (_this.detachEvent) {
            var key = type + fn.__tauid;
            _el[key] && _el.detachEvent("on" + type, _el[key]);
            _el[key] = null;
            _el["e" + key] = null;
          }
        }
        if (fn.__taTouchProxy) {
          _unbind(obj, fn.__taTouchProxy[1], fn.__taTouchProxy[0]);
        }
      });
    }
    function _each$1(obj, fn) {
      if (obj == null) return;
      var entries = typeof obj === "string" ? document.querySelectorAll(obj) : obj.length != null ? obj : [obj];
      for (var i = 0; i < entries.length; i++) {
        fn(entries[i]);
      }
    }
    function _store(obj, event, fn) {
      var g = guid++;
      obj.__ta = obj.__ta || {};
      obj.__ta[event] = obj.__ta[event] || {};
      obj.__ta[event][g] = fn;
      fn.__tauid = g;
      return g;
    }
    function _unstore(obj, event, fn) {
      obj.__ta && obj.__ta[event] && delete obj.__ta[event][fn.__tauid];
      if (fn.__taExtra) {
        for (var i = 0; i < fn.__taExtra.length; i++) {
          _unbind(obj, fn.__taExtra[i][0], fn.__taExtra[i][1]);
        }
        fn.__taExtra.length = 0;
      }
      fn.__taUnstore && fn.__taUnstore();
    }
    function _curryChildFilter(children, obj, fn, evt) {
      if (children == null) return fn;else {
        var c = children.split(","),
            _fn = function _fn(e) {
          _fn.__tauid = fn.__tauid;
          var t = _t(e);
          var done = false;
          var target = t;
          var pathInfo = _pi(e, t, obj, children != null);
          if (pathInfo.end != -1) {
            for (var p = 0; !done && p < pathInfo.end; p++) {
              target = pathInfo.path[p];
              for (var i = 0; !done && i < c.length; i++) {
                if (matchesSelector(target, c[i], obj)) {
                  fn.apply(target, [e, target]);
                  done = true;
                  break;
                }
              }
            }
          }
        };
        registerExtraFunction(fn, evt, _fn);
        return _fn;
      }
    }
    function registerExtraFunction(fn, evt, newFn) {
      fn.__taExtra = fn.__taExtra || [];
      fn.__taExtra.push([evt, newFn]);
    }
    var DefaultHandler = function DefaultHandler(obj, evt, fn, children, options) {
      if (isTouchDevice && touchMap[evt]) {
        var tfn = _curryChildFilter(children, obj, fn, touchMap[evt]);
        _bind(obj, touchMap[evt], tfn, fn, options);
      }
      if (evt === EVENT_FOCUS && obj.getAttribute(ATTRIBUTE_TABINDEX) == null) {
        obj.setAttribute(ATTRIBUTE_TABINDEX, "1");
      }
      _bind(obj, evt, _curryChildFilter(children, obj, fn, evt), fn, options);
    };
    var _tapProfiles = {
      "tap": {
        touches: 1,
        taps: 1
      },
      "dbltap": {
        touches: 1,
        taps: 2
      },
      "contextmenu": {
        touches: 2,
        taps: 1
      }
    };
    function meeHelper(type, evt, obj, target) {
      for (var i in obj.__tamee[type]) {
        if (obj.__tamee[type].hasOwnProperty(i)) {
          obj.__tamee[type][i].apply(target, [evt]);
        }
      }
    }
    var TapHandler = function () {
      function TapHandler() {
        _classCallCheck(this, TapHandler);
      }
      _createClass(TapHandler, null, [{
        key: "generate",
        value: function generate(clickThreshold, dblClickThreshold) {
          return function (obj, evt, fn, children) {
            if (evt == EVENT_CONTEXTMENU && isMouseDevice) DefaultHandler(obj, evt, fn, children);else {
              if (obj.__taTapHandler == null) {
                var tt = obj.__taTapHandler = {
                  tap: [],
                  dbltap: [],
                  down: false,
                  taps: 0,
                  downSelectors: []
                };
                var down = function down(e) {
                  var target = _t(e),
                      pathInfo = _pi(e, target, obj, children != null),
                      finished = false;
                  for (var p = 0; p < pathInfo.end; p++) {
                    if (finished) return;
                    target = pathInfo.path[p];
                    for (var i = 0; i < tt.downSelectors.length; i++) {
                      if (tt.downSelectors[i] == null || matchesSelector(target, tt.downSelectors[i], obj)) {
                        tt.down = true;
                        setTimeout(clearSingle, clickThreshold);
                        setTimeout(clearDouble, dblClickThreshold);
                        finished = true;
                        break;
                      }
                    }
                  }
                },
                    up = function up(e) {
                  if (tt.down) {
                    var target = _t(e),
                        currentTarget,
                        pathInfo;
                    tt.taps++;
                    var tc = touchCount(e);
                    for (var eventId in _tapProfiles) {
                      if (_tapProfiles.hasOwnProperty(eventId)) {
                        var p = _tapProfiles[eventId];
                        if (p.touches === tc && (p.taps === 1 || p.taps === tt.taps)) {
                          for (var i = 0; i < tt[eventId].length; i++) {
                            pathInfo = _pi(e, target, obj, tt[eventId][i][1] != null);
                            for (var pLoop = 0; pLoop < pathInfo.end; pLoop++) {
                              currentTarget = pathInfo.path[pLoop];
                              if (tt[eventId][i][1] == null || matchesSelector(currentTarget, tt[eventId][i][1], obj)) {
                                tt[eventId][i][0].apply(currentTarget, [e, currentTarget]);
                                break;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                    clearSingle = function clearSingle() {
                  tt.down = false;
                },
                    clearDouble = function clearDouble() {
                  tt.taps = 0;
                };
                obj.__taTapHandler.downHandler = down;
                obj.__taTapHandler.upHandler = up;
                DefaultHandler(obj, EVENT_MOUSEDOWN, down);
                DefaultHandler(obj, EVENT_MOUSEUP, up);
              }
              obj.__taTapHandler.downSelectors.push(children);
              obj.__taTapHandler[evt].push([fn, children]);
              fn.__taUnstore = function () {
                if (obj.__taTapHandler != null) {
                  removeWithFunction(obj.__taTapHandler.downSelectors, function (ds) {
                    return ds === children;
                  });
                  _d(obj.__taTapHandler[evt], fn);
                  if (obj.__taTapHandler.downSelectors.length === 0) {
                    _unbind(obj, EVENT_MOUSEDOWN, obj.__taTapHandler.downHandler);
                    _unbind(obj, EVENT_MOUSEUP, obj.__taTapHandler.upHandler);
                    delete obj.__taTapHandler;
                  }
                }
              };
            }
          };
        }
      }]);
      return TapHandler;
    }();
    var MouseEnterExitHandler = function () {
      function MouseEnterExitHandler() {
        _classCallCheck(this, MouseEnterExitHandler);
      }
      _createClass(MouseEnterExitHandler, null, [{
        key: "generate",
        value: function generate() {
          var activeElements = [];
          return function (obj, evt, fn, children) {
            if (!obj.__tamee) {
              obj.__tamee = {
                over: false,
                mouseenter: [],
                mouseexit: []
              };
              var over = function over(e) {
                var t = _t(e);
                if (children == null && t == obj && !obj.__tamee.over || matchesSelector(t, children, obj) && (t.__tamee == null || !t.__tamee.over)) {
                  meeHelper(EVENT_MOUSEENTER, e, obj, t);
                  t.__tamee = t.__tamee || {};
                  t.__tamee.over = true;
                  activeElements.push(t);
                }
              },
                  out = function out(e) {
                var t = _t(e);
                for (var i = 0; i < activeElements.length; i++) {
                  if (t == activeElements[i] && !matchesSelector(e.relatedTarget || e.toElement, "*", t)) {
                    t.__tamee.over = false;
                    activeElements.splice(i, 1);
                    meeHelper(EVENT_MOUSEEXIT, e, obj, t);
                  }
                }
              };
              _bind(obj, EVENT_MOUSEOVER, _curryChildFilter(children, obj, over, EVENT_MOUSEOVER), over);
              _bind(obj, EVENT_MOUSEOUT, _curryChildFilter(children, obj, out, EVENT_MOUSEOUT), out);
            }
            fn.__taUnstore = function () {
              delete obj.__tamee[evt][fn.__tauid];
            };
            _store(obj, evt, fn);
            obj.__tamee[evt][fn.__tauid] = fn;
          };
        }
      }]);
      return MouseEnterExitHandler;
    }();
    var EventManager = function () {
      function EventManager(params) {
        _classCallCheck(this, EventManager);
        _defineProperty(this, "clickThreshold", void 0);
        _defineProperty(this, "dblClickThreshold", void 0);
        _defineProperty(this, "tapHandler", void 0);
        _defineProperty(this, "mouseEnterExitHandler", void 0);
        params = params || {};
        this.clickThreshold = params.clickThreshold || 250;
        this.dblClickThreshold = params.dblClickThreshold || 450;
        this.mouseEnterExitHandler = MouseEnterExitHandler.generate();
        this.tapHandler = TapHandler.generate(this.clickThreshold, this.dblClickThreshold);
      }
      _createClass(EventManager, [{
        key: "_doBind",
        value: function _doBind(el, evt, fn, children, options) {
          if (fn == null) return;
          var jel = el;
          if (evt === EVENT_TAP || evt === EVENT_DBL_TAP || evt === EVENT_CONTEXTMENU) {
            this.tapHandler(jel, evt, fn, children, options);
          } else if (evt === EVENT_MOUSEENTER || evt == EVENT_MOUSEEXIT) this.mouseEnterExitHandler(jel, evt, fn, children, options);else {
            DefaultHandler(jel, evt, fn, children, options);
          }
        }
      }, {
        key: "on",
        value: function on(el, event, children, fn, options) {
          var _c = fn == null ? null : children,
              _f = fn == null ? children : fn;
          this._doBind(el, event, _f, _c, options);
          return this;
        }
      }, {
        key: "off",
        value: function off(el, event, fn) {
          _unbind(el, event, fn);
          return this;
        }
      }, {
        key: "trigger",
        value: function trigger(el, event, originalEvent, payload, detail) {
          var originalIsMouse = isMouseDevice && (typeof MouseEvent === "undefined" || originalEvent == null || originalEvent.constructor === MouseEvent);
          var eventToBind = isTouchDevice && !isMouseDevice && touchMap[event] ? touchMap[event] : event,
              bindingAMouseEvent = !(isTouchDevice && !isMouseDevice && touchMap[event]);
          var pl = pageLocation(originalEvent),
              sl = screenLocation(originalEvent),
              cl = clientLocation(originalEvent);
          _each$1(el, function (_el) {
            var evt;
            originalEvent = originalEvent || {
              screenX: sl.x,
              screenY: sl.y,
              clientX: cl.x,
              clientY: cl.y
            };
            var _decorate = function _decorate(_evt) {
              if (payload) {
                _evt.payload = payload;
              }
            };
            var eventGenerators = {
              "TouchEvent": function TouchEvent(evt) {
                var touchList = _touchAndList(_el, pl.x, pl.y, sl.x, sl.y, cl.x, cl.y),
                    init = evt.initTouchEvent || evt.initEvent;
                init(eventToBind, true, true, window, null, sl.x, sl.y, cl.x, cl.y, false, false, false, false, touchList, touchList, touchList, 1, 0);
              },
              "MouseEvents": function MouseEvents(evt) {
                evt.initMouseEvent(eventToBind, true, true, window, detail == null ? 1 : detail, sl.x, sl.y, cl.x, cl.y, false, false, false, false, 1, _el);
              }
            };
            var ite = !bindingAMouseEvent && !originalIsMouse && isTouchDevice && touchMap[event],
                evtName = ite ? "TouchEvent" : "MouseEvents";
            evt = document.createEvent(evtName);
            eventGenerators[evtName](evt);
            _decorate(evt);
            _el.dispatchEvent(evt);
          });
          return this;
        }
      }]);
      return EventManager;
    }();

    function findDelegateElement(parentElement, childElement, selector) {
      if (matchesSelector$1(childElement, selector, parentElement)) {
        return childElement;
      } else {
        var currentParent = childElement.parentNode;
        while (currentParent != null && currentParent !== parentElement) {
          if (matchesSelector$1(currentParent, selector, parentElement)) {
            return currentParent;
          } else {
            currentParent = currentParent.parentNode;
          }
        }
      }
    }
    function _getPosition(el) {
      return {
        x: el.offsetLeft,
        y: el.offsetTop
      };
    }
    function _getSize(el) {
      return {
        w: el.offsetWidth,
        h: el.offsetHeight
      };
    }
    function _setPosition(el, pos) {
      el.style.left = pos.x + "px";
      el.style.top = pos.y + "px";
    }
    function _assignId(obj) {
      if (typeof obj === "function") {
        obj._katavorioId = uuid();
        return obj._katavorioId;
      } else {
        return obj;
      }
    }
    function isInsideParent(instance, _el, pos) {
      var p = _el.parentNode,
          s = instance.getSize(p),
          ss = instance.getSize(_el),
          leftEdge = pos.x,
          rightEdge = leftEdge + ss.w,
          topEdge = pos.y,
          bottomEdge = topEdge + ss.h;
      return rightEdge > 0 && leftEdge < s.w && bottomEdge > 0 && topEdge < s.h;
    }
    function findMatchingSelector(availableSelectors, parentElement, childElement) {
      var el = null;
      var draggableId = parentElement.getAttribute("katavorio-draggable"),
          prefix = draggableId != null ? "[katavorio-draggable='" + draggableId + "'] " : "";
      for (var i = 0; i < availableSelectors.length; i++) {
        el = findDelegateElement(parentElement, childElement, prefix + availableSelectors[i].selector);
        if (el != null) {
          if (availableSelectors[i].filter) {
            var matches = matchesSelector$1(childElement, availableSelectors[i].filter, el),
                exclude = availableSelectors[i].filterExclude === true;
            if (exclude && !matches || matches) {
              return null;
            }
          }
          return [availableSelectors[i], el];
        }
      }
      return null;
    }
    var EVENT_START = "start";
    var EVENT_BEFORE_START = "beforeStart";
    var EVENT_DRAG = "drag";
    var EVENT_DROP = "drop";
    var EVENT_OVER = "over";
    var EVENT_OUT = "out";
    var EVENT_STOP = "stop";
    var ATTRIBUTE_DRAGGABLE = "katavorio-draggable";
    var CLASS_DRAGGABLE$1 = ATTRIBUTE_DRAGGABLE;
    var DEFAULT_GRID_X = 10;
    var DEFAULT_GRID_Y = 10;
    var TRUE = function TRUE() {
      return true;
    };
    var FALSE = function FALSE() {
      return false;
    };
    var _classes = {
      delegatedDraggable: "katavorio-delegated-draggable",
      draggable: CLASS_DRAGGABLE$1,
      drag: "katavorio-drag",
      selected: "katavorio-drag-selected",
      noSelect: "katavorio-drag-no-select",
      ghostProxy: "katavorio-ghost-proxy",
      clonedDrag: "katavorio-clone-drag"
    };
    var _events = [EVENT_STOP, EVENT_START, EVENT_DRAG, EVENT_DROP, EVENT_OVER, EVENT_OUT, EVENT_BEFORE_START];
    var _devNull = function _devNull() {};
    var _each = function _each(obj, fn) {
      if (obj == null) return;
      obj = !isString(obj) && obj.tagName == null && obj.length != null ? obj : [obj];
      for (var i = 0; i < obj.length; i++) {
        fn.apply(obj[i], [obj[i]]);
      }
    };
    var _inputFilter = function _inputFilter(e, el, collicat) {
      var t = e.srcElement || e.target;
      return !matchesSelector$1(t, collicat.getInputFilterSelector(), el);
    };
    var Base = function () {
      function Base(el, k) {
        _classCallCheck(this, Base);
        this.el = el;
        this.k = k;
        _defineProperty(this, "_class", void 0);
        _defineProperty(this, "uuid", uuid());
        _defineProperty(this, "enabled", true);
        _defineProperty(this, "scopes", []);
      }
      _createClass(Base, [{
        key: "setEnabled",
        value: function setEnabled(e) {
          this.enabled = e;
        }
      }, {
        key: "isEnabled",
        value: function isEnabled() {
          return this.enabled;
        }
      }, {
        key: "toggleEnabled",
        value: function toggleEnabled() {
          this.enabled = !this.enabled;
        }
      }, {
        key: "addScope",
        value: function addScope(scopes) {
          var m = {};
          _each(this.scopes, function (s) {
            m[s] = true;
          });
          _each(scopes ? scopes.split(/\s+/) : [], function (s) {
            m[s] = true;
          });
          this.scopes.length = 0;
          for (var i in m) {
            this.scopes.push(i);
          }
        }
      }, {
        key: "removeScope",
        value: function removeScope(scopes) {
          var m = {};
          _each(this.scopes, function (s) {
            m[s] = true;
          });
          _each(scopes ? scopes.split(/\s+/) : [], function (s) {
            delete m[s];
          });
          this.scopes.length = 0;
          for (var i in m) {
            this.scopes.push(i);
          }
        }
      }, {
        key: "toggleScope",
        value: function toggleScope(scopes) {
          var m = {};
          _each(this.scopes, function (s) {
            m[s] = true;
          });
          _each(scopes ? scopes.split(/\s+/) : [], function (s) {
            if (m[s]) delete m[s];else m[s] = true;
          });
          this.scopes.length = 0;
          for (var i in m) {
            this.scopes.push(i);
          }
        }
      }]);
      return Base;
    }();
    function getConstrainingRectangle(el) {
      return {
        w: el.parentNode.offsetWidth + el.parentNode.scrollLeft,
        h: el.parentNode.offsetHeight + el.parentNode.scrollTop
      };
    }
    var ContainmentType;
    (function (ContainmentType) {
      ContainmentType["notNegative"] = "notNegative";
      ContainmentType["parent"] = "parent";
      ContainmentType["parentEnclosed"] = "parentEnclosed";
    })(ContainmentType || (ContainmentType = {}));
    var Drag = function (_Base) {
      _inherits(Drag, _Base);
      var _super = _createSuper(Drag);
      function Drag(el, params, k) {
        var _this;
        _classCallCheck(this, Drag);
        _this = _super.call(this, el, k);
        _defineProperty(_assertThisInitialized(_this), "_class", void 0);
        _defineProperty(_assertThisInitialized(_this), "rightButtonCanDrag", void 0);
        _defineProperty(_assertThisInitialized(_this), "consumeStartEvent", void 0);
        _defineProperty(_assertThisInitialized(_this), "clone", void 0);
        _defineProperty(_assertThisInitialized(_this), "scroll", void 0);
        _defineProperty(_assertThisInitialized(_this), "trackScroll", void 0);
        _defineProperty(_assertThisInitialized(_this), "_downAt", void 0);
        _defineProperty(_assertThisInitialized(_this), "_posAtDown", void 0);
        _defineProperty(_assertThisInitialized(_this), "_pagePosAtDown", void 0);
        _defineProperty(_assertThisInitialized(_this), "_pageDelta", {
          x: 0,
          y: 0
        });
        _defineProperty(_assertThisInitialized(_this), "_moving", void 0);
        _defineProperty(_assertThisInitialized(_this), "_lastPosition", void 0);
        _defineProperty(_assertThisInitialized(_this), "_lastScrollValues", {
          x: 0,
          y: 0
        });
        _defineProperty(_assertThisInitialized(_this), "_initialScroll", {
          x: 0,
          y: 0
        });
        _defineProperty(_assertThisInitialized(_this), "_size", void 0);
        _defineProperty(_assertThisInitialized(_this), "_currentParentPosition", void 0);
        _defineProperty(_assertThisInitialized(_this), "_ghostParentPosition", void 0);
        _defineProperty(_assertThisInitialized(_this), "_dragEl", void 0);
        _defineProperty(_assertThisInitialized(_this), "_multipleDrop", void 0);
        _defineProperty(_assertThisInitialized(_this), "_ghostProxyOffsets", void 0);
        _defineProperty(_assertThisInitialized(_this), "_ghostDx", void 0);
        _defineProperty(_assertThisInitialized(_this), "_ghostDy", void 0);
        _defineProperty(_assertThisInitialized(_this), "_isConstrained", false);
        _defineProperty(_assertThisInitialized(_this), "_ghostProxyParent", void 0);
        _defineProperty(_assertThisInitialized(_this), "_useGhostProxy", void 0);
        _defineProperty(_assertThisInitialized(_this), "_ghostProxyFunction", void 0);
        _defineProperty(_assertThisInitialized(_this), "_activeSelectorParams", void 0);
        _defineProperty(_assertThisInitialized(_this), "_availableSelectors", []);
        _defineProperty(_assertThisInitialized(_this), "_canDrag", void 0);
        _defineProperty(_assertThisInitialized(_this), "_consumeFilteredEvents", void 0);
        _defineProperty(_assertThisInitialized(_this), "_parent", void 0);
        _defineProperty(_assertThisInitialized(_this), "_ignoreZoom", void 0);
        _defineProperty(_assertThisInitialized(_this), "_filters", {});
        _defineProperty(_assertThisInitialized(_this), "_constrainRect", void 0);
        _defineProperty(_assertThisInitialized(_this), "_elementToDrag", void 0);
        _defineProperty(_assertThisInitialized(_this), "downListener", void 0);
        _defineProperty(_assertThisInitialized(_this), "moveListener", void 0);
        _defineProperty(_assertThisInitialized(_this), "upListener", void 0);
        _defineProperty(_assertThisInitialized(_this), "listeners", {
          "start": [],
          "drag": [],
          "stop": [],
          "over": [],
          "out": [],
          "beforeStart": [],
          "revert": []
        });
        _this._class = _this.k.css.draggable;
        addClass(_this.el, _this._class);
        _this.downListener = _this._downListener.bind(_assertThisInitialized(_this));
        _this.upListener = _this._upListener.bind(_assertThisInitialized(_this));
        _this.moveListener = _this._moveListener.bind(_assertThisInitialized(_this));
        _this.rightButtonCanDrag = params.rightButtonCanDrag === true;
        _this.consumeStartEvent = params.consumeStartEvent !== false;
        _this._dragEl = _this.el;
        _this.clone = params.clone === true;
        _this.scroll = params.scroll === true;
        _this.trackScroll = params.trackScroll !== false;
        _this._multipleDrop = params.multipleDrop !== false;
        _this._canDrag = params.canDrag || TRUE;
        _this._consumeFilteredEvents = params.consumeFilteredEvents;
        _this._parent = params.parent;
        _this._ignoreZoom = params.ignoreZoom === true;
        _this._ghostProxyParent = params.ghostProxyParent;
        if (_this.trackScroll) {
          document.addEventListener("scroll", function (e) {
            if (_this._moving) {
              var currentScrollValues = {
                x: document.documentElement.scrollLeft,
                y: document.documentElement.scrollTop
              },
                  dsx = currentScrollValues.x - _this._lastScrollValues.x,
                  dsy = currentScrollValues.y - _this._lastScrollValues.y,
                  _pos = {
                x: dsx + _this._lastPosition.x,
                y: dsy + _this._lastPosition.y
              },
              dx = _pos.x - _this._downAt.x,
                  dy = _pos.y - _this._downAt.y,
                  _z = _this._ignoreZoom ? 1 : _this.k.getZoom();
              if (_this._dragEl && _this._dragEl.parentNode) {
                dx += _this._dragEl.parentNode.scrollLeft - _this._initialScroll.x;
                dy += _this._dragEl.parentNode.scrollTop - _this._initialScroll.y;
              }
              dx /= _z;
              dy /= _z;
              _this.moveBy(dx, dy, e);
              _this._lastPosition = _pos;
              _this._lastScrollValues = currentScrollValues;
            }
          });
        }
        if (params.ghostProxy === true) {
          _this._useGhostProxy = TRUE;
        } else {
          if (params.ghostProxy && typeof params.ghostProxy === "function") {
            _this._useGhostProxy = params.ghostProxy;
          } else {
            _this._useGhostProxy = function (container, dragEl) {
              if (_this._activeSelectorParams && _this._activeSelectorParams.useGhostProxy) {
                return _this._activeSelectorParams.useGhostProxy(container, dragEl);
              } else {
                return false;
              }
            };
          }
        }
        if (params.makeGhostProxy) {
          _this._ghostProxyFunction = params.makeGhostProxy;
        } else {
          _this._ghostProxyFunction = function (el) {
            if (_this._activeSelectorParams && _this._activeSelectorParams.makeGhostProxy) {
              return _this._activeSelectorParams.makeGhostProxy(el);
            } else {
              return el.cloneNode(true);
            }
          };
        }
        if (params.selector) {
          var draggableId = _this.el.getAttribute(ATTRIBUTE_DRAGGABLE);
          if (draggableId == null) {
            draggableId = "" + new Date().getTime();
            _this.el.setAttribute("katavorio-draggable", draggableId);
          }
          _this._availableSelectors.push(params);
        }
        _this.k.eventManager.on(_this.el, EVENT_MOUSEDOWN, _this.downListener);
        return _this;
      }
      _createClass(Drag, [{
        key: "on",
        value: function on(evt, fn) {
          if (this.listeners[evt]) {
            this.listeners[evt].push(fn);
          }
        }
      }, {
        key: "off",
        value: function off(evt, fn) {
          if (this.listeners[evt]) {
            var l = [];
            for (var i = 0; i < this.listeners[evt].length; i++) {
              if (this.listeners[evt][i] !== fn) {
                l.push(this.listeners[evt][i]);
              }
            }
            this.listeners[evt] = l;
          }
        }
      }, {
        key: "_upListener",
        value: function _upListener(e) {
          if (this._downAt) {
            this._downAt = null;
            this.k.eventManager.off(document, EVENT_MOUSEMOVE, this.moveListener);
            this.k.eventManager.off(document, EVENT_MOUSEUP, this.upListener);
            removeClass(document.body, _classes.noSelect);
            this.unmark(e);
            this.stop(e);
            this._moving = false;
            if (this.clone) {
              this._dragEl && this._dragEl.parentNode && this._dragEl.parentNode.removeChild(this._dragEl);
              this._dragEl = null;
            } else {
              if (this._activeSelectorParams && this._activeSelectorParams.revertFunction) {
                if (this._activeSelectorParams.revertFunction(this._dragEl, _getPosition(this._dragEl)) === true) {
                  _setPosition(this._dragEl, this._posAtDown);
                  this._dispatch(EVENT_REVERT, this._dragEl);
                }
              }
            }
          }
        }
      }, {
        key: "_downListener",
        value: function _downListener(e) {
          if (e.defaultPrevented) {
            return;
          }
          var isNotRightClick = this.rightButtonCanDrag || e.which !== 3 && e.button !== 2;
          if (isNotRightClick && this.isEnabled() && this._canDrag()) {
            var _f = this._testFilter(e) && _inputFilter(e, this.el, this.k);
            if (_f) {
              this._activeSelectorParams = null;
              this._elementToDrag = null;
              if (this._availableSelectors.length === 0) {
                console.log("JSPLUMB: no available drag selectors");
              }
              var eventTarget = e.target || e.srcElement;
              var match = findMatchingSelector(this._availableSelectors, this.el, eventTarget);
              if (match != null) {
                this._activeSelectorParams = match[0];
                this._elementToDrag = match[1];
              }
              if (this._activeSelectorParams == null || this._elementToDrag == null) {
                return;
              }
              var initial = this._activeSelectorParams.dragInit ? this._activeSelectorParams.dragInit(this._elementToDrag) : null;
              if (initial != null) {
                this._elementToDrag = initial;
              }
              if (this.clone) {
                this._dragEl = this._elementToDrag.cloneNode(true);
                addClass(this._dragEl, _classes.clonedDrag);
                this._dragEl.setAttribute("id", null);
                this._dragEl.style.position = "absolute";
                if (this._parent != null) {
                  var _p2 = _getPosition(this.el);
                  this._dragEl.style.left = _p2.x + "px";
                  this._dragEl.style.top = _p2.y + "px";
                  this._parent.appendChild(this._dragEl);
                } else {
                  var b = offsetRelativeToRoot(this._elementToDrag);
                  this._dragEl.style.left = b.x + "px";
                  this._dragEl.style.top = b.y + "px";
                  document.body.appendChild(this._dragEl);
                }
              } else {
                this._dragEl = this._elementToDrag;
              }
              if (this.consumeStartEvent) {
                consume(e);
              }
              this._downAt = pageLocation(e);
              if (this._dragEl && this._dragEl.parentNode) {
                this._initialScroll = {
                  x: this._dragEl.parentNode.scrollLeft,
                  y: this._dragEl.parentNode.scrollTop
                };
              }
              this._posAtDown = _getPosition(this._dragEl);
              this._pagePosAtDown = offsetRelativeToRoot(this._dragEl);
              this._pageDelta = {
                x: this._pagePosAtDown.x - this._posAtDown.x,
                y: this._pagePosAtDown.y - this._posAtDown.y
              };
              this._size = _getSize(this._dragEl);
              this.k.eventManager.on(document, EVENT_MOUSEMOVE, this.moveListener);
              this.k.eventManager.on(document, EVENT_MOUSEUP, this.upListener);
              addClass(document.body, _classes.noSelect);
              this._dispatch(EVENT_BEFORE_START, {
                el: this.el,
                pos: this._posAtDown,
                e: e,
                drag: this,
                size: this._size
              });
            } else if (this._consumeFilteredEvents) {
              consume(e);
            }
          }
        }
      }, {
        key: "_moveListener",
        value: function _moveListener(e) {
          if (this._downAt) {
            if (!this._moving) {
              var dispatchResult = this._dispatch(EVENT_START, {
                el: this.el,
                pos: this._posAtDown,
                e: e,
                drag: this,
                size: this._size
              });
              if (dispatchResult !== false) {
                if (!this._downAt) {
                  return;
                }
                this.mark(dispatchResult);
                this._moving = true;
              } else {
                this.abort();
              }
            }
            if (this._downAt) {
              var _pos2 = pageLocation(e),
                  dx = _pos2.x - this._downAt.x,
                  dy = _pos2.y - this._downAt.y,
                  _z2 = this._ignoreZoom ? 1 : this.k.getZoom();
              this._lastPosition = {
                x: _pos2.x,
                y: _pos2.y
              };
              this._lastScrollValues = {
                x: document.documentElement.scrollLeft,
                y: document.documentElement.scrollTop
              };
              if (this._dragEl && this._dragEl.parentNode) {
                dx += this._dragEl.parentNode.scrollLeft - this._initialScroll.x;
                dy += this._dragEl.parentNode.scrollTop - this._initialScroll.y;
              }
              dx /= _z2;
              dy /= _z2;
              this.moveBy(dx, dy, e);
            }
          }
        }
      }, {
        key: "mark",
        value: function mark(payload) {
          this._posAtDown = _getPosition(this._dragEl);
          this._pagePosAtDown = offsetRelativeToRoot(this._dragEl);
          this._pageDelta = {
            x: this._pagePosAtDown.x - this._posAtDown.x,
            y: this._pagePosAtDown.y - this._posAtDown.y
          };
          this._size = _getSize(this._dragEl);
          addClass(this._dragEl, this.k.css.drag);
          this._constrainRect = getConstrainingRectangle(this._dragEl);
          this._ghostDx = 0;
          this._ghostDy = 0;
        }
      }, {
        key: "unmark",
        value: function unmark(e) {
          if (this._isConstrained && this._useGhostProxy(this._elementToDrag, this._dragEl)) {
            this._ghostProxyOffsets = {
              x: this._dragEl.offsetLeft - this._ghostDx,
              y: this._dragEl.offsetTop - this._ghostDy
            };
            this._dragEl.parentNode.removeChild(this._dragEl);
            this._dragEl = this._elementToDrag;
          } else {
            this._ghostProxyOffsets = null;
          }
          removeClass(this._dragEl, this.k.css.drag);
          this._isConstrained = false;
        }
      }, {
        key: "moveBy",
        value: function moveBy(dx, dy, e) {
          var desiredLoc = this.toGrid({
            x: this._posAtDown.x + dx,
            y: this._posAtDown.y + dy
          }),
              cPos = this._doConstrain(desiredLoc, this._dragEl, this._constrainRect, this._size);
          if (this._useGhostProxy(this.el, this._dragEl)) {
            if (desiredLoc.x !== cPos.x || desiredLoc.y !== cPos.y) {
              if (!this._isConstrained) {
                var gp = this._ghostProxyFunction(this._elementToDrag);
                addClass(gp, _classes.ghostProxy);
                if (this._ghostProxyParent) {
                  this._ghostProxyParent.appendChild(gp);
                  this._currentParentPosition = offsetRelativeToRoot(this._elementToDrag.parentNode);
                  this._ghostParentPosition = offsetRelativeToRoot(this._ghostProxyParent);
                  this._ghostDx = this._currentParentPosition.x - this._ghostParentPosition.x;
                  this._ghostDy = this._currentParentPosition.y - this._ghostParentPosition.y;
                } else {
                  this._elementToDrag.parentNode.appendChild(gp);
                }
                this._dragEl = gp;
                this._isConstrained = true;
              }
              cPos = desiredLoc;
            } else {
              if (this._isConstrained) {
                this._dragEl.parentNode.removeChild(this._dragEl);
                this._dragEl = this._elementToDrag;
                this._isConstrained = false;
                this._currentParentPosition = null;
                this._ghostParentPosition = null;
                this._ghostDx = 0;
                this._ghostDy = 0;
              }
            }
          }
          _setPosition(this._dragEl, {
            x: cPos.x + this._ghostDx,
            y: cPos.y + this._ghostDy
          });
          this._dispatch(EVENT_DRAG, {
            el: this.el,
            pos: cPos,
            e: e,
            drag: this,
            size: this._size,
            originalPos: this._posAtDown
          });
        }
      }, {
        key: "abort",
        value: function abort() {
          if (this._downAt != null) {
            this._upListener();
          }
        }
      }, {
        key: "getDragElement",
        value: function getDragElement(retrieveOriginalElement) {
          return retrieveOriginalElement ? this._elementToDrag || this.el : this._dragEl || this.el;
        }
      }, {
        key: "stop",
        value: function stop(e, force) {
          if (force || this._moving) {
            var positions = [],
                dPos = _getPosition(this._dragEl);
            positions.push([this._dragEl, dPos, this, this._size]);
            this._dispatch(EVENT_STOP, {
              el: this._dragEl,
              pos: this._ghostProxyOffsets || dPos,
              finalPos: dPos,
              e: e,
              drag: this,
              selection: positions,
              size: this._size,
              originalPos: {
                x: this._posAtDown.x,
                y: this._posAtDown.y
              }
            });
          } else if (!this._moving) {
            this._activeSelectorParams.dragAbort ? this._activeSelectorParams.dragAbort(this._elementToDrag) : null;
          }
        }
      }, {
        key: "_dispatch",
        value: function _dispatch(evt, value) {
          var result = null;
          if (this._activeSelectorParams && this._activeSelectorParams[evt]) {
            result = this._activeSelectorParams[evt](value);
          } else if (this.listeners[evt]) {
            for (var i = 0; i < this.listeners[evt].length; i++) {
              try {
                var v = this.listeners[evt][i](value);
                if (v != null) {
                  result = v;
                }
              } catch (e) {}
            }
          }
          return result;
        }
      }, {
        key: "resolveGrid",
        value: function resolveGrid() {
          var out = {
            grid: null,
            thresholdX: DEFAULT_GRID_X / 2,
            thresholdY: DEFAULT_GRID_Y / 2
          };
          if (this._activeSelectorParams != null && this._activeSelectorParams.grid != null) {
            out.grid = this._activeSelectorParams.grid;
            if (this._activeSelectorParams.snapThreshold != null) {
              out.thresholdX = this._activeSelectorParams.snapThreshold;
              out.thresholdY = this._activeSelectorParams.snapThreshold;
            }
          }
          return out;
        }
      }, {
        key: "toGrid",
        value: function toGrid(pos) {
          var _this$resolveGrid = this.resolveGrid(),
              grid = _this$resolveGrid.grid,
              thresholdX = _this$resolveGrid.thresholdX,
              thresholdY = _this$resolveGrid.thresholdY;
          if (grid == null) {
            return pos;
          } else {
            var tx = grid ? grid.w / 2 : thresholdX,
                ty = grid ? grid.h / 2 : thresholdY;
            return snapToGrid(pos, grid, tx, ty);
          }
        }
      }, {
        key: "setUseGhostProxy",
        value: function setUseGhostProxy(val) {
          this._useGhostProxy = val ? TRUE : FALSE;
        }
      }, {
        key: "_doConstrain",
        value: function _doConstrain(pos, dragEl, _constrainRect, _size) {
          if (this._activeSelectorParams != null && this._activeSelectorParams.constrainFunction && typeof this._activeSelectorParams.constrainFunction === "function") {
            return this._activeSelectorParams.constrainFunction(pos, dragEl, _constrainRect, _size);
          } else {
            return pos;
          }
        }
      }, {
        key: "_testFilter",
        value: function _testFilter(e) {
          for (var key in this._filters) {
            var f = this._filters[key];
            var rv = f[0](e);
            if (f[1]) {
              rv = !rv;
            }
            if (!rv) {
              return false;
            }
          }
          return true;
        }
      }, {
        key: "addFilter",
        value: function addFilter(f, _exclude) {
          var _this2 = this;
          if (f) {
            var key = _assignId(f);
            this._filters[key] = [function (e) {
              var t = e.srcElement || e.target;
              var m;
              if (isString(f)) {
                m = matchesSelector$1(t, f, _this2.el);
              } else if (typeof f === "function") {
                m = f(e, _this2.el);
              }
              return m;
            }, _exclude !== false];
          }
        }
      }, {
        key: "removeFilter",
        value: function removeFilter(f) {
          var key = typeof f === "function" ? f._katavorioId : f;
          delete this._filters[key];
        }
      }, {
        key: "clearAllFilters",
        value: function clearAllFilters() {
          this._filters = {};
        }
      }, {
        key: "addSelector",
        value: function addSelector(params, atStart) {
          if (params.selector) {
            if (atStart) {
              this._availableSelectors.unshift(params);
            } else {
              this._availableSelectors.push(params);
            }
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.k.eventManager.off(this.el, EVENT_MOUSEDOWN, this.downListener);
          this.k.eventManager.off(document, EVENT_MOUSEMOVE, this.moveListener);
          this.k.eventManager.off(document, EVENT_MOUSEUP, this.upListener);
          this.downListener = null;
          this.upListener = null;
          this.moveListener = null;
        }
      }]);
      return Drag;
    }(Base);
    var DEFAULT_INPUTS = ["input", "textarea", "select", "button", "option"];
    var DEFAULT_INPUT_FILTER_SELECTOR = DEFAULT_INPUTS.join(",");
    var Collicat = function () {
      function Collicat(options) {
        _classCallCheck(this, Collicat);
        _defineProperty(this, "eventManager", void 0);
        _defineProperty(this, "zoom", 1);
        _defineProperty(this, "css", {});
        _defineProperty(this, "inputFilterSelector", void 0);
        options = options || {};
        this.inputFilterSelector = options.inputFilterSelector || DEFAULT_INPUT_FILTER_SELECTOR;
        this.eventManager = new EventManager();
        this.zoom = options.zoom || 1;
        var _c = options.css || {};
        extend(this.css, _c);
      }
      _createClass(Collicat, [{
        key: "getZoom",
        value: function getZoom() {
          return this.zoom;
        }
      }, {
        key: "setZoom",
        value: function setZoom(z) {
          this.zoom = z;
        }
      }, {
        key: "_prepareParams",
        value: function _prepareParams(p) {
          p = p || {};
          var _p = {
            events: {}
          },
              i;
          for (i in p) {
            _p[i] = p[i];
          }
          for (i = 0; i < _events.length; i++) {
            _p.events[_events[i]] = p[_events[i]] || _devNull;
          }
          return _p;
        }
      }, {
        key: "getInputFilterSelector",
        value: function getInputFilterSelector() {
          return this.inputFilterSelector;
        }
      }, {
        key: "setInputFilterSelector",
        value: function setInputFilterSelector(selector) {
          this.inputFilterSelector = selector;
          return this;
        }
      }, {
        key: "draggable",
        value: function draggable(el, params) {
          if (el._katavorioDrag == null) {
            var _p3 = this._prepareParams(params);
            var d = new Drag(el, _p3, this);
            addClass(el, _classes.delegatedDraggable);
            el._katavorioDrag = d;
            return d;
          } else {
            return el._katavorioDrag;
          }
        }
      }, {
        key: "destroyDraggable",
        value: function destroyDraggable(el) {
          if (el._katavorioDrag) {
            el._katavorioDrag.destroy();
            delete el._katavorioDrag;
          }
        }
      }]);
      return Collicat;
    }();

    var CLASS_DRAG_SELECTED = "jtk-drag-selected";
    var DragSelection = function () {
      function DragSelection(instance) {
        _classCallCheck(this, DragSelection);
        this.instance = instance;
        _defineProperty(this, "_dragSelection", []);
        _defineProperty(this, "_dragSizes", new Map());
        _defineProperty(this, "_dragElements", new Map());
        _defineProperty(this, "_dragElementStartPositions", new Map());
        _defineProperty(this, "_dragElementPositions", new Map());
        _defineProperty(this, "__activeSet", void 0);
      }
      _createClass(DragSelection, [{
        key: "_activeSet",
        get: function get() {
          if (this.__activeSet == null) {
            return this._dragSelection;
          } else {
            return this.__activeSet;
          }
        }
      }, {
        key: "length",
        get: function get() {
          return this._dragSelection.length;
        }
      }, {
        key: "filterActiveSet",
        value: function filterActiveSet(fn) {
          var _this = this;
          this.__activeSet = [];
          forEach(this._dragSelection, function (p) {
            if (fn(p)) {
              _this.__activeSet.push(p);
            }
          });
        }
      }, {
        key: "clear",
        value: function clear() {
          var _this2 = this;
          this.reset();
          forEach(this._dragSelection, function (p) {
            return _this2.instance.removeClass(p.jel, CLASS_DRAG_SELECTED);
          });
          this._dragSelection.length = 0;
        }
      }, {
        key: "reset",
        value: function reset() {
          this._dragElementStartPositions.clear();
          this._dragElementPositions.clear();
          this._dragSizes.clear();
          this._dragElements.clear();
          this.__activeSet = null;
        }
      }, {
        key: "initialisePositions",
        value: function initialisePositions() {
          var _this3 = this;
          forEach(this._activeSet, function (p) {
            var off = {
              x: parseInt("" + p.jel.offsetLeft, 10),
              y: parseInt("" + p.jel.offsetTop, 10)
            };
            _this3._dragElementStartPositions.set(p.id, off);
            _this3._dragElementPositions.set(p.id, off);
            _this3._dragSizes.set(p.id, _this3.instance.getSize(p.jel));
          });
        }
      }, {
        key: "updatePositions",
        value: function updatePositions(currentPosition, originalPosition, callback) {
          var _this4 = this;
          var dx = currentPosition.x - originalPosition.x,
              dy = currentPosition.y - originalPosition.y;
          forEach(this._activeSet, function (p) {
            var op = _this4._dragElementStartPositions.get(p.id);
            if (op) {
              var x = op.x + dx,
                  y = op.y + dy;
              var _s = _this4._dragSizes.get(p.id);
              var _b = {
                x: x,
                y: y,
                w: _s.w,
                h: _s.h
              };
              if (p.jel._jsPlumbParentGroup && p.jel._jsPlumbParentGroup.constrain) {
                var constrainRect = {
                  w: p.jel.parentNode.offsetWidth + p.jel.parentNode.scrollLeft,
                  h: p.jel.parentNode.offsetHeight + p.jel.parentNode.scrollTop
                };
                _b.x = Math.max(_b.x, 0);
                _b.y = Math.max(_b.y, 0);
                _b.x = Math.min(_b.x, constrainRect.w - _s.w);
                _b.y = Math.min(_b.y, constrainRect.h - _s.h);
              }
              _this4._dragElementPositions.set(p.id, {
                x: x,
                y: y
              });
              p.jel.style.left = _b.x + "px";
              p.jel.style.top = _b.y + "px";
              callback(p.jel, p.id, _s, _b);
            }
          });
        }
      }, {
        key: "each",
        value: function each(f) {
          var _this5 = this;
          forEach(this._activeSet, function (p) {
            var s = _this5._dragSizes.get(p.id);
            var o = _this5._dragElementPositions.get(p.id);
            var orig = _this5._dragElementStartPositions.get(p.id);
            f(p.jel, p.id, o, s, orig);
          });
        }
      }, {
        key: "add",
        value: function add(el, id) {
          var jel = el;
          id = id || this.instance.getId(jel);
          var idx = findWithFunction(this._dragSelection, function (p) {
            return p.id === id;
          });
          if (idx === -1) {
            this.instance.addClass(el, CLASS_DRAG_SELECTED);
            this._dragSelection.push({
              id: id,
              jel: jel
            });
          }
        }
      }, {
        key: "remove",
        value: function remove(el) {
          var _this6 = this;
          var jel = el;
          this._dragSelection = this._dragSelection.filter(function (p) {
            var out = p.jel !== jel;
            if (!out) {
              _this6.instance.removeClass(p.jel, CLASS_DRAG_SELECTED);
            }
            return out;
          });
        }
      }, {
        key: "toggle",
        value: function toggle(el) {
          var jel = el;
          var idx = findWithFunction(this._dragSelection, function (p) {
            return p.jel === jel;
          });
          if (idx !== -1) {
            this.remove(jel);
          } else {
            this.add(el);
          }
        }
      }]);
      return DragSelection;
    }();

    var CLASS_DELEGATED_DRAGGABLE = "jtk-delegated-draggable";
    var CLASS_DRAGGABLE = "jtk-draggable";
    var CLASS_DRAG_CONTAINER = "jtk-drag";
    var CLASS_GHOST_PROXY = "jtk-ghost-proxy";
    var CLASS_DRAG_ACTIVE = "jtk-drag-active";
    var CLASS_DRAGGED = "jtk-dragged";
    var CLASS_DRAG_HOVER = "jtk-drag-hover";
    var DragManager = function () {
      function DragManager(instance, dragSelection, options) {
        var _this = this;
        _classCallCheck(this, DragManager);
        this.instance = instance;
        this.dragSelection = dragSelection;
        _defineProperty(this, "collicat", void 0);
        _defineProperty(this, "drag", void 0);
        _defineProperty(this, "_draggables", {});
        _defineProperty(this, "_dlist", []);
        _defineProperty(this, "_elementsWithEndpoints", {});
        _defineProperty(this, "_draggablesForElements", {});
        _defineProperty(this, "handlers", []);
        _defineProperty(this, "_trackScroll", void 0);
        _defineProperty(this, "_filtersToAdd", []);
        this.collicat = new Collicat({
          zoom: this.instance.currentZoom,
          css: {
            noSelect: this.instance.dragSelectClass,
            delegatedDraggable: CLASS_DELEGATED_DRAGGABLE,
            draggable: CLASS_DRAGGABLE,
            drag: CLASS_DRAG_CONTAINER,
            selected: CLASS_DRAG_SELECTED,
            active: CLASS_DRAG_ACTIVE,
            hover: CLASS_DRAG_HOVER,
            ghostProxy: CLASS_GHOST_PROXY
          }
        });
        this.instance.bind(EVENT_ZOOM, function (z) {
          _this.collicat.setZoom(z);
        });
        options = options || {};
        this._trackScroll = options.trackScroll !== false;
      }
      _createClass(DragManager, [{
        key: "addHandler",
        value: function addHandler(handler, dragOptions) {
          var _this2 = this;
          var o = extend({
            selector: handler.selector
          }, dragOptions || {});
          o.start = wrap(o.start, function (p) {
            return handler.onStart(p);
          });
          o.drag = wrap(o.drag, function (p) {
            return handler.onDrag(p);
          });
          o.stop = wrap(o.stop, function (p) {
            return handler.onStop(p);
          });
          var handlerBeforeStart = (handler.onBeforeStart || function (p) {}).bind(handler);
          o.beforeStart = wrap(o.beforeStart, function (p) {
            return handlerBeforeStart(p);
          });
          o.dragInit = function (el) {
            return handler.onDragInit(el);
          };
          o.dragAbort = function (el) {
            return handler.onDragAbort(el);
          };
          if (handler.useGhostProxy) {
            o.useGhostProxy = handler.useGhostProxy;
            o.makeGhostProxy = handler.makeGhostProxy;
          }
          if (o.constrainFunction == null && o.containment != null) {
            switch (o.containment) {
              case ContainmentType.notNegative:
                {
                  o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {
                    return {
                      x: Math.max(0, Math.min(pos.x)),
                      y: Math.max(0, Math.min(pos.y))
                    };
                  };
                  break;
                }
              case ContainmentType.parent:
                {
                  var padding = o.containmentPadding || 5;
                  o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {
                    var x = pos.x < 0 ? 0 : pos.x > _constrainRect.w - padding ? _constrainRect.w - padding : pos.x;
                    var y = pos.y < 0 ? 0 : pos.y > _constrainRect.h - padding ? _constrainRect.h - padding : pos.y;
                    return {
                      x: x,
                      y: y
                    };
                  };
                  break;
                }
              case ContainmentType.parentEnclosed:
                {
                  o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {
                    var x = pos.x < 0 ? 0 : pos.x + _size.w > _constrainRect.w ? _constrainRect.w - _size.w : pos.x;
                    var y = pos.y < 0 ? 0 : pos.y + _size.h > _constrainRect.h ? _constrainRect.h - _size.h : pos.y;
                    return {
                      x: x,
                      y: y
                    };
                  };
                  break;
                }
            }
          }
          if (this.drag == null) {
            o.trackScroll = this._trackScroll;
            this.drag = this.collicat.draggable(this.instance.getContainer(), o);
            forEach(this._filtersToAdd, function (filterToAdd) {
              return _this2.drag.addFilter(filterToAdd[0], filterToAdd[1]);
            });
            this.drag.on(EVENT_REVERT, function (el) {
              _this2.instance.revalidate(el);
            });
          } else {
            this.drag.addSelector(o);
          }
          this.handlers.push({
            handler: handler,
            options: o
          });
          handler.init(this.drag);
        }
      }, {
        key: "addFilter",
        value: function addFilter(filter, exclude) {
          if (this.drag == null) {
            this._filtersToAdd.push([filter, exclude === true]);
          } else {
            this.drag.addFilter(filter, exclude);
          }
        }
      }, {
        key: "removeFilter",
        value: function removeFilter(filter) {
          if (this.drag != null) {
            this.drag.removeFilter(filter);
          }
        }
      }, {
        key: "setFilters",
        value: function setFilters(filters) {
          var _this3 = this;
          forEach(filters, function (f) {
            _this3.drag.addFilter(f[0], f[1]);
          });
        }
      }, {
        key: "reset",
        value: function reset() {
          var out = [];
          forEach(this.handlers, function (p) {
            p.handler.reset();
          });
          if (this.drag != null) {
            var currentFilters = this.drag._filters;
            for (var f in currentFilters) {
              out.push([f, currentFilters[f][1]]);
            }
            this.collicat.destroyDraggable(this.instance.getContainer());
          }
          delete this.drag;
          return out;
        }
      }, {
        key: "setOption",
        value: function setOption(handler, options) {
          var handlerAndOptions = getWithFunction(this.handlers, function (p) {
            return p.handler === handler;
          });
          if (handlerAndOptions != null) {
            extend(handlerAndOptions.options, options || {});
          }
        }
      }]);
      return DragManager;
    }();

    function decodeDragGroupSpec(instance, spec) {
      if (isString(spec)) {
        return {
          id: spec,
          active: true
        };
      } else {
        return {
          id: instance.getId(spec),
          active: spec.active
        };
      }
    }
    function isActiveDragGroupMember(dragGroup, el) {
      var details = getFromSetWithFunction(dragGroup.members, function (m) {
        return m.el === el;
      });
      if (details !== null) {
        return details.active === true;
      } else {
        return false;
      }
    }
    function getAncestors(el) {
      var ancestors = [];
      var p = el._jsPlumbParentGroup;
      while (p != null) {
        ancestors.push(p.el);
        p = p.group;
      }
      return ancestors;
    }
    var ElementDragHandler = function () {
      function ElementDragHandler(instance, _dragSelection) {
        _classCallCheck(this, ElementDragHandler);
        this.instance = instance;
        this._dragSelection = _dragSelection;
        _defineProperty(this, "selector", "> " + SELECTOR_MANAGED_ELEMENT + ":not(" + cls(CLASS_OVERLAY) + ")");
        _defineProperty(this, "_dragOffset", null);
        _defineProperty(this, "_groupLocations", []);
        _defineProperty(this, "_intersectingGroups", []);
        _defineProperty(this, "_currentDragParentGroup", null);
        _defineProperty(this, "_dragGroupByElementIdMap", {});
        _defineProperty(this, "_dragGroupMap", {});
        _defineProperty(this, "_currentDragGroup", null);
        _defineProperty(this, "_currentDragGroupOffsets", new Map());
        _defineProperty(this, "_currentDragGroupSizes", new Map());
        _defineProperty(this, "_dragPayload", null);
        _defineProperty(this, "drag", void 0);
        _defineProperty(this, "originalPosition", void 0);
      }
      _createClass(ElementDragHandler, [{
        key: "onDragInit",
        value: function onDragInit(el) {
          return null;
        }
      }, {
        key: "onDragAbort",
        value: function onDragAbort(el) {
          return null;
        }
      }, {
        key: "getDropGroup",
        value: function getDropGroup() {
          var dropGroup = null;
          if (this._intersectingGroups.length > 0) {
            var targetGroup = this._intersectingGroups[0].groupLoc.group;
            var intersectingElement = this._intersectingGroups[0].intersectingElement;
            var currentGroup = intersectingElement._jsPlumbParentGroup;
            if (currentGroup !== targetGroup) {
              if (currentGroup == null || !currentGroup.overrideDrop(intersectingElement, targetGroup)) {
                dropGroup = this._intersectingGroups[0];
              }
            }
          }
          return dropGroup;
        }
      }, {
        key: "onStop",
        value: function onStop(params) {
          var _this = this;
          var jel = params.drag.getDragElement();
          var dropGroup = this.getDropGroup();
          var elementsToProcess = [];
          elementsToProcess.push({
            el: jel,
            id: this.instance.getId(jel),
            pos: params.finalPos,
            originalGroup: jel._jsPlumbParentGroup,
            redrawResult: null,
            originalPos: params.originalPos,
            reverted: false,
            dropGroup: dropGroup != null ? dropGroup.groupLoc.group : null
          });
          this._dragSelection.each(function (el, id, o, s, orig) {
            if (el !== params.el) {
              var pp = {
                x: o.x,
                y: o.y
              };
              var x = pp.x,
                  y = pp.y;
              if (el._jsPlumbParentGroup && el._jsPlumbParentGroup.constrain) {
                var constrainRect = {
                  w: el.parentNode.offsetWidth + el.parentNode.scrollLeft,
                  h: el.parentNode.offsetHeight + el.parentNode.scrollTop
                };
                x = Math.max(x, 0);
                y = Math.max(y, 0);
                x = Math.min(x, constrainRect.w - s.w);
                y = Math.min(y, constrainRect.h - s.h);
                pp.x = x;
                pp.y = y;
              }
              elementsToProcess.push({
                el: el,
                id: id,
                pos: pp,
                originalPos: orig,
                originalGroup: el._jsPlumbParentGroup,
                redrawResult: null,
                reverted: false,
                dropGroup: dropGroup != null ? dropGroup.groupLoc.group : null
              });
            }
          });
          forEach(elementsToProcess, function (p) {
            var wasInGroup = p.originalGroup != null,
                isInOriginalGroup = wasInGroup && isInsideParent(_this.instance, p.el, p.pos),
                parentOffset = {
              x: 0,
              y: 0
            };
            if (wasInGroup && !isInOriginalGroup) {
              if (dropGroup == null) {
                var orphanedPosition = _this._pruneOrOrphan(p, true, true);
                if (orphanedPosition.pos != null) {
                  p.pos = orphanedPosition.pos.pos;
                } else {
                  if (!orphanedPosition.pruned && p.originalGroup.revert) {
                    p.pos = p.originalPos;
                    p.reverted = true;
                  }
                }
              }
            } else if (wasInGroup && isInOriginalGroup) {
              parentOffset = _this.instance.viewport.getPosition(p.originalGroup.elId);
            }
            if (dropGroup != null && !isInOriginalGroup) {
              _this.instance.groupManager.addToGroup(dropGroup.groupLoc.group, false, p.el);
            } else {
              p.dropGroup = null;
            }
            if (p.reverted) {
              _this.instance.setPosition(p.el, p.pos);
            }
            p.redrawResult = _this.instance.setElementPosition(p.el, p.pos.x + parentOffset.x, p.pos.y + parentOffset.y);
            _this.instance.removeClass(p.el, CLASS_DRAGGED);
            _this.instance.select({
              source: p.el
            }).removeClass(_this.instance.elementDraggingClass + " " + _this.instance.sourceElementDraggingClass, true);
            _this.instance.select({
              target: p.el
            }).removeClass(_this.instance.elementDraggingClass + " " + _this.instance.targetElementDraggingClass, true);
          });
          if (elementsToProcess[0].originalGroup != null) {
            var currentGroup = jel._jsPlumbParentGroup;
            if (currentGroup !== elementsToProcess[0].originalGroup) {
              var originalElement = params.drag.getDragElement(true);
              if (elementsToProcess[0].originalGroup.ghost) {
                var o1 = this.instance.getOffset(this.instance.getGroupContentArea(currentGroup));
                var o2 = this.instance.getOffset(this.instance.getGroupContentArea(elementsToProcess[0].originalGroup));
                var o = {
                  x: o2.x + params.pos.x - o1.x,
                  y: o2.y + params.pos.y - o1.y
                };
                originalElement.style.left = o.x + "px";
                originalElement.style.top = o.y + "px";
                this.instance.revalidate(originalElement);
              }
            }
          }
          this.instance.fire(EVENT_DRAG_STOP, {
            elements: elementsToProcess,
            e: params.e,
            el: jel,
            payload: this._dragPayload
          });
          this._cleanup();
        }
      }, {
        key: "_cleanup",
        value: function _cleanup() {
          var _this2 = this;
          forEach(this._groupLocations, function (groupLoc) {
            _this2.instance.removeClass(groupLoc.el, CLASS_DRAG_ACTIVE);
            _this2.instance.removeClass(groupLoc.el, CLASS_DRAG_HOVER);
          });
          this._currentDragParentGroup = null;
          this._groupLocations.length = 0;
          this.instance.hoverSuspended = false;
          this._dragOffset = null;
          this._dragSelection.reset();
          this._dragPayload = null;
          this._currentDragGroupOffsets.clear();
          this._currentDragGroupSizes.clear();
          this._currentDragGroup = null;
        }
      }, {
        key: "reset",
        value: function reset() {}
      }, {
        key: "init",
        value: function init(drag) {
          this.drag = drag;
        }
      }, {
        key: "onDrag",
        value: function onDrag(params) {
          var _this3 = this;
          var el = params.drag.getDragElement();
          var finalPos = params.pos;
          var elSize = this.instance.getSize(el);
          var ui = {
            x: finalPos.x,
            y: finalPos.y
          };
          this._intersectingGroups.length = 0;
          if (this._dragOffset != null) {
            ui.x += this._dragOffset.x;
            ui.y += this._dragOffset.y;
          }
          var _one = function _one(el, bounds, findIntersectingGroups) {
            if (findIntersectingGroups) {
              var ancestorsOfIntersectingGroups = new Set();
              forEach(_this3._groupLocations, function (groupLoc) {
                if (!ancestorsOfIntersectingGroups.has(groupLoc.group.id) && intersects(bounds, groupLoc.r)) {
                  if (groupLoc.group !== _this3._currentDragParentGroup) {
                    _this3.instance.addClass(groupLoc.el, CLASS_DRAG_HOVER);
                  }
                  _this3._intersectingGroups.push({
                    groupLoc: groupLoc,
                    intersectingElement: params.drag.getDragElement(true),
                    d: 0
                  });
                  forEach(_this3.instance.groupManager.getAncestors(groupLoc.group), function (g) {
                    return ancestorsOfIntersectingGroups.add(g.id);
                  });
                } else {
                  _this3.instance.removeClass(groupLoc.el, CLASS_DRAG_HOVER);
                }
              });
            }
            _this3.instance.setElementPosition(el, bounds.x, bounds.y);
            _this3.instance.fire(EVENT_DRAG_MOVE, {
              el: el,
              e: params.e,
              pos: {
                x: bounds.x,
                y: bounds.y
              },
              originalPosition: _this3.originalPosition,
              payload: _this3._dragPayload
            });
          };
          var elBounds = {
            x: ui.x,
            y: ui.y,
            w: elSize.w,
            h: elSize.h
          };
          _one(el, elBounds, true);
          this._dragSelection.updatePositions(finalPos, this.originalPosition, function (el, id, s, b) {
            _one(el, b, false);
          });
          this._currentDragGroupOffsets.forEach(function (v, k) {
            var s = _this3._currentDragGroupSizes.get(k);
            var _b = {
              x: elBounds.x + v[0].x,
              y: elBounds.y + v[0].y,
              w: s.w,
              h: s.h
            };
            v[1].style.left = _b.x + "px";
            v[1].style.top = _b.y + "px";
            _one(v[1], _b, false);
          });
        }
      }, {
        key: "onStart",
        value: function onStart(params) {
          var _this4 = this;
          var el = params.drag.getDragElement();
          var elOffset = this.instance.getOffset(el);
          this.originalPosition = {
            x: params.pos.x,
            y: params.pos.y
          };
          if (el._jsPlumbParentGroup) {
            this._dragOffset = this.instance.getOffset(el.offsetParent);
            this._currentDragParentGroup = el._jsPlumbParentGroup;
          }
          var cont = true;
          var nd = el.getAttribute(ATTRIBUTE_NOT_DRAGGABLE);
          if (this.instance.elementsDraggable === false || nd != null && nd !== FALSE$1) {
            cont = false;
          }
          if (cont) {
            this._groupLocations.length = 0;
            this._intersectingGroups.length = 0;
            this.instance.hoverSuspended = true;
            var originalElement = params.drag.getDragElement(true),
                descendants = originalElement.querySelectorAll(SELECTOR_MANAGED_ELEMENT),
                ancestors = getAncestors(originalElement),
                a = [];
            Array.prototype.push.apply(a, descendants);
            Array.prototype.push.apply(a, ancestors);
            this._dragSelection.filterActiveSet(function (p) {
              return a.indexOf(p.jel) === -1;
            });
            this._dragSelection.initialisePositions();
            var _one = function _one(_el) {
              if (!_el._isJsPlumbGroup || _this4.instance.allowNestedGroups) {
                var isNotInAGroup = !_el._jsPlumbParentGroup;
                var membersAreDroppable = isNotInAGroup || _el._jsPlumbParentGroup.dropOverride !== true;
                var isGhostOrNotConstrained = !isNotInAGroup && (_el._jsPlumbParentGroup.ghost || _el._jsPlumbParentGroup.constrain !== true);
                if (isNotInAGroup || membersAreDroppable && isGhostOrNotConstrained) {
                  forEach(_this4.instance.groupManager.getGroups(), function (group) {
                    var elementGroup = _el._jsPlumbGroup;
                    if (group.droppable !== false && group.enabled !== false && _el._jsPlumbGroup !== group && !_this4.instance.groupManager.isDescendant(group, elementGroup)) {
                      var groupEl = group.el,
                          s = _this4.instance.getSize(groupEl),
                          o = _this4.instance.getOffset(groupEl),
                          boundingRect = {
                        x: o.x,
                        y: o.y,
                        w: s.w,
                        h: s.h
                      };
                      var groupLocation = {
                        el: groupEl,
                        r: boundingRect,
                        group: group
                      };
                      _this4._groupLocations.push(groupLocation);
                      if (group !== _this4._currentDragParentGroup) {
                        _this4.instance.addClass(groupEl, CLASS_DRAG_ACTIVE);
                      }
                    }
                  });
                  _this4._groupLocations.sort(function (a, b) {
                    if (_this4.instance.groupManager.isDescendant(a.group, b.group)) {
                      return -1;
                    } else if (_this4.instance.groupManager.isAncestor(b.group, a.group)) {
                      return 1;
                    } else {
                      return 0;
                    }
                  });
                }
              }
              _this4.instance.select({
                source: _el
              }).addClass(_this4.instance.elementDraggingClass + " " + _this4.instance.sourceElementDraggingClass, true);
              _this4.instance.select({
                target: _el
              }).addClass(_this4.instance.elementDraggingClass + " " + _this4.instance.targetElementDraggingClass, true);
              return _this4.instance.fire(EVENT_DRAG_START, {
                el: _el,
                e: params.e,
                originalPosition: _this4.originalPosition,
                pos: _this4.originalPosition
              });
            };
            var elId = this.instance.getId(el);
            this._currentDragGroup = this._dragGroupByElementIdMap[elId];
            if (this._currentDragGroup && !isActiveDragGroupMember(this._currentDragGroup, el)) {
              this._currentDragGroup = null;
            }
            var dragStartReturn = _one(el);
            if (dragStartReturn === false) {
              this._cleanup();
              return false;
            } else {
              this._dragPayload = dragStartReturn;
            }
            if (this._currentDragGroup != null) {
              this._currentDragGroupOffsets.clear();
              this._currentDragGroupSizes.clear();
              this._currentDragGroup.members.forEach(function (jel) {
                var off = _this4.instance.getOffset(jel.el);
                _this4._currentDragGroupOffsets.set(jel.elId, [{
                  x: off.x - elOffset.x,
                  y: off.y - elOffset.y
                }, jel.el]);
                _this4._currentDragGroupSizes.set(jel.elId, _this4.instance.getSize(jel.el));
                _one(jel.el);
              });
            }
          }
          return cont;
        }
      }, {
        key: "addToDragGroup",
        value: function addToDragGroup(spec) {
          var _this5 = this;
          var details = decodeDragGroupSpec(this.instance, spec);
          var dragGroup = this._dragGroupMap[details.id];
          if (dragGroup == null) {
            dragGroup = {
              id: details.id,
              members: new Set()
            };
            this._dragGroupMap[details.id] = dragGroup;
          }
          for (var _len = arguments.length, els = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            els[_key - 1] = arguments[_key];
          }
          this.removeFromDragGroup.apply(this, els);
          forEach(els, function (el) {
            var elId = _this5.instance.getId(el);
            dragGroup.members.add({
              elId: elId,
              el: el,
              active: details.active
            });
            _this5._dragGroupByElementIdMap[elId] = dragGroup;
          });
        }
      }, {
        key: "removeFromDragGroup",
        value: function removeFromDragGroup() {
          var _this6 = this;
          for (var _len2 = arguments.length, els = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            els[_key2] = arguments[_key2];
          }
          forEach(els, function (el) {
            var id = _this6.instance.getId(el);
            var dragGroup = _this6._dragGroupByElementIdMap[id];
            if (dragGroup != null) {
              var s = new Set();
              dragGroup.members.forEach(function (member) {
                if (member.el !== el) {
                  s.add(member);
                }
              });
              dragGroup.members = s;
              delete _this6._dragGroupByElementIdMap[id];
            }
          });
        }
      }, {
        key: "setDragGroupState",
        value: function setDragGroupState(state) {
          var _this7 = this;
          for (var _len3 = arguments.length, els = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            els[_key3 - 1] = arguments[_key3];
          }
          var elementIds = els.map(function (el) {
            return _this7.instance.getId(el);
          });
          forEach(elementIds, function (id) {
            var dragGroup = _this7._dragGroupByElementIdMap[id];
            if (dragGroup != null) {
              var member = getFromSetWithFunction(dragGroup.members, function (m) {
                return m.elId === id;
              });
              if (member != null) {
                member.active = state;
              }
            }
          });
        }
      }, {
        key: "_pruneOrOrphan",
        value: function _pruneOrOrphan(params, doNotTransferToAncestor, isDefinitelyNotInsideParent) {
          var jel = params.el;
          var orphanedPosition = {
            pruned: false,
            pos: null
          };
          if (isDefinitelyNotInsideParent || !isInsideParent(this.instance, jel, params.pos)) {
            var group = jel._jsPlumbParentGroup;
            if (group.prune) {
              if (jel._isJsPlumbGroup) {
                this.instance.removeGroup(jel._jsPlumbGroup);
              } else {
                group.remove(params.el, true);
              }
              orphanedPosition.pruned = true;
            } else if (group.orphan) {
              orphanedPosition.pos = this.instance.groupManager.orphan(params.el, doNotTransferToAncestor);
              if (jel._isJsPlumbGroup) {
                group.removeGroup(jel._jsPlumbGroup);
              } else {
                group.remove(params.el);
              }
            }
          }
          return orphanedPosition;
        }
      }]);
      return ElementDragHandler;
    }();

    function _makeFloatingEndpoint(paintStyle, endpoint, referenceCanvas, sourceElement, instance, scope) {
      var floatingAnchor = createFloatingAnchor(instance, sourceElement);
      var p = {
        paintStyle: paintStyle,
        preparedAnchor: floatingAnchor,
        element: sourceElement,
        scope: scope
      };
      if (endpoint != null) {
        if (isAssignableFrom(endpoint, EndpointRepresentation)) {
          p.existingEndpoint = endpoint;
        } else {
          p.endpoint = endpoint;
        }
      }
      var ep = instance._internal_newEndpoint(p);
      instance.paintEndpoint(ep, {});
      return ep;
    }
    function selectorFilter(evt, _el, selector, _instance, negate) {
      var t = evt.target || evt.srcElement,
          ok = false,
          sel = _instance.getSelector(_el, selector);
      for (var j = 0; j < sel.length; j++) {
        if (sel[j] === t) {
          ok = true;
          break;
        }
      }
      return negate ? !ok : ok;
    }
    var SELECTOR_DRAG_ACTIVE_OR_HOVER = cls(CLASS_DRAG_ACTIVE, CLASS_DRAG_HOVER);
    var SOURCE_SELECTOR_UNIQUE_ENDPOINT_DATA = "sourceSelectorEndpoint";
    var EndpointDragHandler = function () {
      function EndpointDragHandler(instance) {
        _classCallCheck(this, EndpointDragHandler);
        this.instance = instance;
        _defineProperty(this, "jpc", void 0);
        _defineProperty(this, "existingJpc", void 0);
        _defineProperty(this, "_originalAnchor", void 0);
        _defineProperty(this, "ep", void 0);
        _defineProperty(this, "endpointRepresentation", void 0);
        _defineProperty(this, "canvasElement", void 0);
        _defineProperty(this, "_activeDefinition", void 0);
        _defineProperty(this, "placeholderInfo", {
          id: null,
          element: null
        });
        _defineProperty(this, "floatingIndex", void 0);
        _defineProperty(this, "floatingId", void 0);
        _defineProperty(this, "floatingElement", void 0);
        _defineProperty(this, "floatingEndpoint", void 0);
        _defineProperty(this, "floatingAnchor", void 0);
        _defineProperty(this, "_stopped", void 0);
        _defineProperty(this, "inPlaceCopy", void 0);
        _defineProperty(this, "endpointDropTargets", []);
        _defineProperty(this, "currentDropTarget", null);
        _defineProperty(this, "payload", void 0);
        _defineProperty(this, "floatingConnections", {});
        _defineProperty(this, "_forceReattach", void 0);
        _defineProperty(this, "_forceDetach", void 0);
        _defineProperty(this, "mousedownHandler", void 0);
        _defineProperty(this, "mouseupHandler", void 0);
        _defineProperty(this, "selector", cls(CLASS_ENDPOINT));
        var container = instance.getContainer();
        this.mousedownHandler = this._mousedownHandler.bind(this);
        this.mouseupHandler = this._mouseupHandler.bind(this);
        instance.on(container, EVENT_MOUSEDOWN, SELECTOR_MANAGED_ELEMENT, this.mousedownHandler);
        instance.on(container, EVENT_MOUSEUP, [SELECTOR_MANAGED_ELEMENT, cls(CLASS_ENDPOINT)].join(","), this.mouseupHandler);
      }
      _createClass(EndpointDragHandler, [{
        key: "_resolveDragParent",
        value: function _resolveDragParent(def, eventTarget) {
          var container = this.instance.getContainer();
          var parent = findParent(eventTarget, SELECTOR_MANAGED_ELEMENT, container, true);
          if (def.parentSelector != null) {
            var child = findParent(eventTarget, def.parentSelector, container, true);
            if (child != null) {
              parent = findParent(child.parentNode, SELECTOR_MANAGED_ELEMENT, container, false);
            }
            return child || parent;
          } else {
            return parent;
          }
        }
      }, {
        key: "_mousedownHandler",
        value: function _mousedownHandler(e) {
          var sourceEl;
          var sourceSelector;
          if (e.which === 3 || e.button === 2) {
            return;
          }
          var eventTarget = e.target || e.srcElement;
          sourceSelector = this._getSourceDefinition(e);
          if (sourceSelector != null) {
            sourceEl = this._resolveDragParent(sourceSelector.def.def, eventTarget);
            if (sourceEl == null || sourceEl.getAttribute(ATTRIBUTE_JTK_ENABLED) === FALSE$1) {
              return;
            }
          }
          if (sourceSelector) {
            var sourceElement = e.currentTarget,
                def;
            if (eventTarget.getAttribute(ATTRIBUTE_JTK_ENABLED) !== FALSE$1) {
              consume(e);
              this._activeDefinition = sourceSelector;
              def = sourceSelector.def.def;
              var elxy = getPositionOnElement(e, sourceEl, this.instance.currentZoom);
              var tempEndpointParams = {
                element: sourceEl
              };
              extend(tempEndpointParams, def);
              tempEndpointParams.isTemporarySource = true;
              if (def.scope) {
                tempEndpointParams.scope = def.scope;
              } else {
                var scopeFromElement = eventTarget.getAttribute(ATTRIBUTE_JTK_SCOPE);
                if (scopeFromElement != null) {
                  tempEndpointParams.scope = scopeFromElement;
                }
              }
              var extractedParameters = def.parameterExtractor ? def.parameterExtractor(sourceEl, eventTarget) : {};
              tempEndpointParams = merge(tempEndpointParams, extractedParameters);
              if (tempEndpointParams.maxConnections != null && tempEndpointParams.maxConnections >= 0) {
                var sourceCount = this.instance.select({
                  source: sourceEl
                }).length;
                if (sourceCount >= tempEndpointParams.maxConnections) {
                  consume(e);
                  if (def.onMaxConnections) {
                    def.onMaxConnections({
                      element: sourceEl,
                      maxConnections: tempEndpointParams.maxConnections
                    }, e);
                  }
                  e.stopImmediatePropagation && e.stopImmediatePropagation();
                  return false;
                }
              }
              this._originalAnchor = tempEndpointParams.anchor || (this.instance.areDefaultAnchorsSet() ? this.instance.defaults.anchors[0] : this.instance.defaults.anchor);
              tempEndpointParams.anchor = [elxy.x, elxy.y, 0, 0];
              tempEndpointParams.deleteOnEmpty = true;
              this.ep = this.instance._internal_newEndpoint(tempEndpointParams);
              var payload = {};
              if (def.extract) {
                for (var att in def.extract) {
                  var v = eventTarget.getAttribute(att);
                  if (v) {
                    payload[def.extract[att]] = v;
                  }
                }
                this.ep.mergeParameters(payload);
              }
              if (tempEndpointParams.uniqueEndpoint) {
                var elementId = this.ep.elementId;
                var existingUniqueEndpoint = this.instance.getManagedData(elementId, SOURCE_SELECTOR_UNIQUE_ENDPOINT_DATA, sourceSelector.id);
                if (existingUniqueEndpoint == null) {
                  this.instance.setManagedData(elementId, SOURCE_SELECTOR_UNIQUE_ENDPOINT_DATA, sourceSelector.id, this.ep);
                  this.ep.deleteOnEmpty = false;
                } else {
                  this.ep.finalEndpoint = existingUniqueEndpoint;
                }
              }
              sourceElement._jsPlumbOrphanedEndpoints = sourceElement._jsPlumbOrphanedEndpoints || [];
              sourceElement._jsPlumbOrphanedEndpoints.push(this.ep);
              this.instance.trigger(this.ep.endpoint.canvas, EVENT_MOUSEDOWN, e, payload);
            }
          }
        }
      }, {
        key: "_mouseupHandler",
        value: function _mouseupHandler(e) {
          var el = e.currentTarget || e.srcElement;
          if (el._jsPlumbOrphanedEndpoints) {
            each(el._jsPlumbOrphanedEndpoints, this.instance._maybePruneEndpoint.bind(this.instance));
            el._jsPlumbOrphanedEndpoints.length = 0;
          }
          this._activeDefinition = null;
        }
      }, {
        key: "onDragInit",
        value: function onDragInit(el) {
          var ipco = this.instance.getOffset(el),
              ips = this.instance.getSize(el);
          this._makeDraggablePlaceholder(ipco, ips);
          this.placeholderInfo.element.jtk = el.jtk;
          return this.placeholderInfo.element;
        }
      }, {
        key: "onDragAbort",
        value: function onDragAbort(el) {
          this._cleanupDraggablePlaceholder();
        }
      }, {
        key: "_makeDraggablePlaceholder",
        value: function _makeDraggablePlaceholder(ipco, ips) {
          this.placeholderInfo = this.placeholderInfo || {};
          var n = createElement(ELEMENT_DIV, {
            position: "absolute"
          });
          this.instance._appendElement(n, this.instance.getContainer());
          var id = this.instance.getId(n);
          this.instance.setPosition(n, ipco);
          n.style.width = ips.w + "px";
          n.style.height = ips.h + "px";
          this.instance.manage(n);
          this.placeholderInfo.id = id;
          this.placeholderInfo.element = n;
          return n;
        }
      }, {
        key: "_cleanupDraggablePlaceholder",
        value: function _cleanupDraggablePlaceholder() {
          if (this.placeholderInfo.element) {
            this.instance.unmanage(this.placeholderInfo.element, true);
            delete this.placeholderInfo.element;
            delete this.placeholderInfo.id;
          }
        }
      }, {
        key: "reset",
        value: function reset() {
          var c = this.instance.getContainer();
          this.instance.off(c, EVENT_MOUSEUP, this.mouseupHandler);
          this.instance.off(c, EVENT_MOUSEDOWN, this.mousedownHandler);
        }
      }, {
        key: "init",
        value: function init(drag) {}
      }, {
        key: "startNewConnectionDrag",
        value: function startNewConnectionDrag(scope, data) {
          this.jpc = this.instance._newConnection({
            sourceEndpoint: this.ep,
            targetEndpoint: this.floatingEndpoint,
            source: this.ep.element,
            target: this.placeholderInfo.element,
            paintStyle: this.ep.connectorStyle,
            hoverPaintStyle: this.ep.connectorHoverStyle,
            connector: this.ep.connector,
            overlays: this.ep.connectorOverlays,
            type: this.ep.edgeType,
            cssClass: this.ep.connectorClass,
            hoverClass: this.ep.connectorHoverClass,
            scope: scope,
            data: data
          });
          this.jpc.pending = true;
          this.jpc.addClass(this.instance.draggingClass);
          this.floatingEndpoint.addClass(this.instance.draggingClass);
          this.instance.fire(EVENT_CONNECTION_DRAG, this.jpc);
        }
      }, {
        key: "startExistingConnectionDrag",
        value: function startExistingConnectionDrag() {
          this.existingJpc = true;
          this.instance.setHover(this.jpc, false);
          var anchorIdx = this.jpc.endpoints[0].id === this.ep.id ? 0 : 1;
          this.ep.detachFromConnection(this.jpc, null, true);
          this.floatingEndpoint.addConnection(this.jpc);
          this.floatingEndpoint.addClass(this.instance.draggingClass);
          this.instance.fire(EVENT_CONNECTION_DRAG, this.jpc);
          this.instance.sourceOrTargetChanged(this.jpc.endpoints[anchorIdx].elementId, this.placeholderInfo.id, this.jpc, this.placeholderInfo.element, anchorIdx);
          this.jpc.suspendedEndpoint = this.jpc.endpoints[anchorIdx];
          this.jpc.suspendedElement = this.jpc.endpoints[anchorIdx].element;
          this.jpc.suspendedElementId = this.jpc.endpoints[anchorIdx].elementId;
          this.jpc.suspendedElementType = anchorIdx === 0 ? SOURCE : TARGET;
          this.instance.setHover(this.jpc.suspendedEndpoint, false);
          this.floatingEndpoint.referenceEndpoint = this.jpc.suspendedEndpoint;
          this.floatingEndpoint.mergeParameters(this.jpc.suspendedEndpoint.parameters);
          this.jpc.endpoints[anchorIdx] = this.floatingEndpoint;
          this.jpc.addClass(this.instance.draggingClass);
          this.floatingId = this.placeholderInfo.id;
          this.floatingIndex = anchorIdx;
        }
      }, {
        key: "_shouldStartDrag",
        value: function _shouldStartDrag() {
          var _continue = true;
          if (!this.ep.enabled) {
            _continue = false;
          }
          if (this.jpc == null && !this.ep.isSource && !this.ep.isTemporarySource) {
            _continue = false;
          }
          if (this.ep.isSource && this.ep.isFull() && !(this.jpc != null && this.ep.dragAllowedWhenFull)) {
            _continue = false;
          }
          if (this.jpc != null && !this.jpc.isDetachable(this.ep)) {
            if (this.ep.isFull()) {
              _continue = false;
            } else {
              this.jpc = null;
            }
          }
          var payload = {};
          var beforeDrag = this.instance.checkCondition(this.jpc == null ? INTERCEPT_BEFORE_DRAG : INTERCEPT_BEFORE_START_DETACH, {
            endpoint: this.ep,
            source: this.ep.element,
            sourceId: this.ep.elementId,
            connection: this.jpc
          });
          if (beforeDrag === false) {
            _continue = false;
          }
          else if (_typeof(beforeDrag) === "object") {
            payload = beforeDrag;
            extend(payload, this.payload || {});
          } else {
            payload = this.payload || {};
          }
          return [_continue, payload];
        }
      }, {
        key: "_createFloatingEndpoint",
        value: function _createFloatingEndpoint(canvasElement) {
          var endpointToFloat = this.ep.endpoint;
          if (this.ep.edgeType != null) {
            var aae = this.instance._deriveEndpointAndAnchorSpec(this.ep.edgeType);
            endpointToFloat = aae.endpoints[1];
          }
          this.floatingEndpoint = _makeFloatingEndpoint(this.ep.getPaintStyle(), endpointToFloat, canvasElement, this.placeholderInfo.element, this.instance, this.ep.scope);
          this.floatingAnchor = this.floatingEndpoint._anchor;
          this.floatingEndpoint.deleteOnEmpty = true;
          this.floatingElement = this.floatingEndpoint.endpoint.canvas;
          this.floatingId = this.instance.getId(this.floatingElement);
        }
      }, {
        key: "_populateTargets",
        value: function _populateTargets(canvasElement) {
          var _this = this;
          var isSourceDrag = this.jpc && this.jpc.endpoints[0] === this.ep;
          var boundingRect;
          var matchingEndpoints = this.instance.getContainer().querySelectorAll([".", CLASS_ENDPOINT, "[", ATTRIBUTE_SCOPE_PREFIX, this.ep.scope, "]"].join(""));
          forEach(matchingEndpoints, function (candidate) {
            if ((_this.jpc != null || candidate !== canvasElement) && candidate !== _this.floatingElement) {
              if (isSourceDrag && candidate.jtk.endpoint.isSource || !isSourceDrag && candidate.jtk.endpoint.isTarget) {
                var o = _this.instance.getOffset(candidate),
                    s = _this.instance.getSize(candidate);
                boundingRect = {
                  x: o.x,
                  y: o.y,
                  w: s.w,
                  h: s.h
                };
                _this.endpointDropTargets.push({
                  el: candidate,
                  targetEl: candidate,
                  r: boundingRect,
                  endpoint: candidate.jtk.endpoint,
                  def: null
                });
                _this.instance.addClass(candidate, CLASS_DRAG_ACTIVE);
              }
            }
          });
          if (isSourceDrag) {
            var sourceDef = getWithFunction(this.instance.sourceSelectors, function (sSel) {
              return sSel.isEnabled() && (sSel.def.def.scope == null || sSel.def.def.scope === _this.ep.scope);
            });
            if (sourceDef != null) {
              var targetZones = this.instance.getContainer().querySelectorAll(sourceDef.redrop === REDROP_POLICY_ANY ? SELECTOR_MANAGED_ELEMENT : sourceDef.selector);
              forEach(targetZones, function (el) {
                if (el.getAttribute(ATTRIBUTE_JTK_ENABLED) !== FALSE$1) {
                  var scopeFromElement = el.getAttribute(ATTRIBUTE_JTK_SCOPE);
                  if (scopeFromElement != null && scopeFromElement !== _this.ep.scope) {
                    return;
                  }
                  var d = {
                    r: null,
                    el: el
                  };
                  d.targetEl = findParent(el, SELECTOR_MANAGED_ELEMENT, _this.instance.getContainer(), true);
                  var o = _this.instance.getOffset(d.el),
                      s = _this.instance.getSize(d.el);
                  d.r = {
                    x: o.x,
                    y: o.y,
                    w: s.w,
                    h: s.h
                  };
                  if (sourceDef.def.def.rank != null) {
                    d.rank = sourceDef.def.def.rank;
                  }
                  d.def = sourceDef;
                  _this.endpointDropTargets.push(d);
                  _this.instance.addClass(d.targetEl, CLASS_DRAG_ACTIVE);
                }
              });
            }
          } else {
            var targetDefs = getAllWithFunction(this.instance.targetSelectors, function (tSel) {
              return tSel.isEnabled();
            });
            targetDefs.forEach(function (targetDef) {
              var targetZones = _this.instance.getContainer().querySelectorAll(targetDef.selector);
              forEach(targetZones, function (el) {
                if (el.getAttribute(ATTRIBUTE_JTK_ENABLED) !== FALSE$1) {
                  var scopeFromElement = el.getAttribute(ATTRIBUTE_JTK_SCOPE);
                  if (scopeFromElement != null && scopeFromElement !== _this.ep.scope) {
                    return;
                  }
                  var d = {
                    r: null,
                    el: el
                  };
                  if (targetDef.def.def.parentSelector != null) {
                    d.targetEl = findParent(el, targetDef.def.def.parentSelector, _this.instance.getContainer(), true);
                  }
                  if (d.targetEl == null) {
                    d.targetEl = findParent(el, SELECTOR_MANAGED_ELEMENT, _this.instance.getContainer(), true);
                  }
                  if (targetDef.def.def.allowLoopback === false || _this._activeDefinition && _this._activeDefinition.def.def.allowLoopback === false) {
                    if (d.targetEl === _this.ep.element) {
                      return;
                    }
                  }
                  var o = _this.instance.getOffset(el),
                      s = _this.instance.getSize(el);
                  d.r = {
                    x: o.x,
                    y: o.y,
                    w: s.w,
                    h: s.h
                  };
                  d.def = targetDef.def;
                  if (targetDef.def.def.rank != null) {
                    d.rank = targetDef.def.def.rank;
                  }
                  _this.endpointDropTargets.push(d);
                  _this.instance.addClass(d.targetEl, CLASS_DRAG_ACTIVE);
                }
              });
            });
          }
          this.endpointDropTargets.sort(function (a, b) {
            if (a.targetEl._isJsPlumbGroup && !b.targetEl._isJsPlumbGroup) {
              return 1;
            } else if (!a.targetEl._isJsPlumbGroup && b.targetEl._isJsPlumbGroup) {
              return -1;
            } else {
              if (a.targetEl._isJsPlumbGroup && b.targetEl._isJsPlumbGroup) {
                if (_this.instance.groupManager.isAncestor(a.targetEl._jsPlumbGroup, b.targetEl._jsPlumbGroup)) {
                  return -1;
                } else if (_this.instance.groupManager.isAncestor(b.targetEl._jsPlumbGroup, a.targetEl._jsPlumbGroup)) {
                  return 1;
                }
              } else {
                if (a.rank != null && b.rank != null) {
                  if (a.rank > b.rank) {
                    return -1;
                  } else if (a.rank < b.rank) {
                    return 1;
                  } else ;
                } else {
                  return 0;
                }
              }
            }
          });
        }
      }, {
        key: "onStart",
        value: function onStart(p) {
          this.endpointDropTargets.length = 0;
          this.currentDropTarget = null;
          this._stopped = false;
          var dragEl = p.drag.getDragElement();
          this.ep = dragEl.jtk.endpoint;
          if (!this.ep) {
            return false;
          }
          this.endpointRepresentation = this.ep.endpoint;
          this.canvasElement = this.endpointRepresentation.canvas;
          this.jpc = this.ep.connectorSelector();
          var _this$_shouldStartDra = this._shouldStartDrag(),
              _this$_shouldStartDra2 = _slicedToArray(_this$_shouldStartDra, 2),
              _continue = _this$_shouldStartDra2[0],
              payload = _this$_shouldStartDra2[1];
          if (_continue === false) {
            this._stopped = true;
            return false;
          }
          this.instance.setHover(this.ep, false);
          this.instance.isConnectionBeingDragged = true;
          if (this.jpc && !this.ep.isFull() && this.ep.isSource) {
            this.jpc = null;
          }
          this._createFloatingEndpoint(this.canvasElement);
          this._populateTargets(this.canvasElement);
          if (this.jpc == null) {
            this.startNewConnectionDrag(this.ep.scope, payload);
          } else {
            this.startExistingConnectionDrag();
          }
          this._registerFloatingConnection(this.placeholderInfo, this.jpc, this.floatingEndpoint);
          this.instance.currentlyDragging = true;
        }
      }, {
        key: "onBeforeStart",
        value: function onBeforeStart(beforeStartParams) {
          this.payload = beforeStartParams.e.payload || {};
        }
      }, {
        key: "onDrag",
        value: function onDrag(params) {
          if (this._stopped) {
            return true;
          }
          if (this.placeholderInfo.element) {
            var floatingElementSize = this.instance.getSize(this.floatingElement);
            this.instance.setElementPosition(this.placeholderInfo.element, params.pos.x, params.pos.y);
            var boundingRect = {
              x: params.pos.x,
              y: params.pos.y,
              w: floatingElementSize.w,
              h: floatingElementSize.h
            },
                newDropTarget,
                idx,
                _cont;
            for (var i = 0; i < this.endpointDropTargets.length; i++) {
              if (intersects(boundingRect, this.endpointDropTargets[i].r)) {
                newDropTarget = this.endpointDropTargets[i];
                break;
              }
            }
            if (newDropTarget !== this.currentDropTarget && this.currentDropTarget != null) {
              idx = this._getFloatingAnchorIndex();
              this.instance.removeClass(this.currentDropTarget.el, CLASS_DRAG_HOVER);
              if (this.currentDropTarget.endpoint) {
                this.currentDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropAllowedClass);
                this.currentDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropForbiddenClass);
              }
              this.floatingAnchor.out();
            }
            if (newDropTarget != null) {
              this.instance.addClass(newDropTarget.el, CLASS_DRAG_HOVER);
              idx = this._getFloatingAnchorIndex();
              if (newDropTarget.endpoint != null) {
                _cont = newDropTarget.endpoint.isSource && idx === 0 || newDropTarget.endpoint.isTarget && idx !== 0 || this.jpc.suspendedEndpoint && newDropTarget.endpoint.referenceEndpoint && newDropTarget.endpoint.referenceEndpoint.id === this.jpc.suspendedEndpoint.id;
                if (_cont) {
                  var bb = this.instance.checkCondition(CHECK_DROP_ALLOWED, {
                    sourceEndpoint: this.jpc.endpoints[idx],
                    targetEndpoint: newDropTarget.endpoint.endpoint,
                    connection: this.jpc
                  });
                  if (bb) {
                    newDropTarget.endpoint.endpoint.addClass(this.instance.endpointDropAllowedClass);
                    newDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropForbiddenClass);
                  } else {
                    newDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropAllowedClass);
                    newDropTarget.endpoint.endpoint.addClass(this.instance.endpointDropForbiddenClass);
                  }
                  this.floatingAnchor.over(newDropTarget.endpoint);
                  this.instance.paintConnection(this.jpc);
                } else {
                  newDropTarget = null;
                }
              }
            }
            this.currentDropTarget = newDropTarget;
          }
        }
      }, {
        key: "_maybeCleanup",
        value: function _maybeCleanup(ep) {
          if (ep._mtNew && ep.connections.length === 0) {
            this.instance.deleteEndpoint(ep);
          } else {
            delete ep._mtNew;
          }
        }
      }, {
        key: "_reattachOrDiscard",
        value: function _reattachOrDiscard(originalEvent) {
          var existingConnection = this.jpc.suspendedEndpoint != null;
          var idx = this._getFloatingAnchorIndex();
          if (existingConnection && this._shouldReattach(originalEvent)) {
            if (idx === 0) {
              this.jpc.source = this.jpc.suspendedElement;
              this.jpc.sourceId = this.jpc.suspendedElementId;
            } else {
              this.jpc.target = this.jpc.suspendedElement;
              this.jpc.targetId = this.jpc.suspendedElementId;
            }
            this._doForceReattach(idx);
            return true;
          } else {
            this._discard(idx, originalEvent);
            return false;
          }
        }
      }, {
        key: "onStop",
        value: function onStop(p) {
          var _this2 = this;
          var originalEvent = p.e;
          this.instance.isConnectionBeingDragged = false;
          this.instance.currentlyDragging = false;
          var classesToRemove = classList(CLASS_DRAG_HOVER, CLASS_DRAG_ACTIVE);
          var matchingSelectors = this.instance.getContainer().querySelectorAll(SELECTOR_DRAG_ACTIVE_OR_HOVER);
          forEach(matchingSelectors, function (el) {
            _this2.instance.removeClass(el, classesToRemove);
          });
          if (this.jpc && this.jpc.endpoints != null) {
            var existingConnection = this.jpc.suspendedEndpoint != null;
            var idx = this._getFloatingAnchorIndex();
            var suspendedEndpoint = this.jpc.suspendedEndpoint;
            var dropEndpoint;
            if (this.currentDropTarget != null) {
              dropEndpoint = this._getDropEndpoint(p, this.jpc);
              if (dropEndpoint == null) {
                !this._reattachOrDiscard(p.e);
              } else {
                if (suspendedEndpoint && suspendedEndpoint.id === dropEndpoint.id) {
                  this._doForceReattach(idx);
                } else {
                  if (!dropEndpoint.enabled) {
                    this._reattachOrDiscard(p.e);
                  } else if (dropEndpoint.isFull()) {
                    dropEndpoint.fire(EVENT_MAX_CONNECTIONS, {
                      endpoint: this,
                      connection: this.jpc,
                      maxConnections: this.instance.defaults.maxConnections
                    }, originalEvent);
                    this._reattachOrDiscard(p.e);
                  } else {
                    if (idx === 0) {
                      this.jpc.source = dropEndpoint.element;
                      this.jpc.sourceId = dropEndpoint.elementId;
                    } else {
                      this.jpc.target = dropEndpoint.element;
                      this.jpc.targetId = dropEndpoint.elementId;
                    }
                    var _doContinue = true;
                    if (existingConnection && this.jpc.suspendedEndpoint.id !== dropEndpoint.id) {
                      if (!this.jpc.isDetachAllowed(this.jpc) || !this.jpc.endpoints[idx].isDetachAllowed(this.jpc) || !this.jpc.suspendedEndpoint.isDetachAllowed(this.jpc) || !this.instance.checkCondition("beforeDetach", this.jpc)) {
                        _doContinue = false;
                      }
                    }
                    _doContinue = _doContinue && dropEndpoint.isDropAllowed(this.jpc.sourceId, this.jpc.targetId, this.jpc.scope, this.jpc, dropEndpoint);
                    if (_doContinue) {
                      this._drop(dropEndpoint, idx, originalEvent, _doContinue);
                    } else {
                      this._reattachOrDiscard(p.e);
                    }
                  }
                }
              }
            } else {
              this._reattachOrDiscard(p.e);
            }
            this.instance.refreshEndpoint(this.ep);
            this.ep.removeClass(this.instance.draggingClass);
            this._cleanupDraggablePlaceholder();
            this.jpc.removeClass(this.instance.draggingClass);
            delete this.jpc.suspendedEndpoint;
            delete this.jpc.suspendedElement;
            delete this.jpc.suspendedElementType;
            delete this.jpc.suspendedElementId;
            delete this.jpc.suspendedIndex;
            delete this.floatingId;
            delete this.floatingIndex;
            delete this.floatingElement;
            delete this.floatingEndpoint;
            delete this.floatingAnchor;
            delete this.jpc.pending;
            if (dropEndpoint != null) {
              this._maybeCleanup(dropEndpoint);
            }
          }
        }
      }, {
        key: "_getSourceDefinition",
        value: function _getSourceDefinition(evt) {
          var selector;
          for (var i = 0; i < this.instance.sourceSelectors.length; i++) {
            selector = this.instance.sourceSelectors[i];
            if (selector.isEnabled()) {
              var r = selectorFilter(evt, this.instance.getContainer(), selector.selector, this.instance, selector.exclude);
              if (r !== false) {
                return selector;
              }
            }
          }
        }
      }, {
        key: "_getDropEndpoint",
        value: function _getDropEndpoint(p, jpc) {
          var dropEndpoint;
          if (this.currentDropTarget.endpoint == null) {
            var targetDefinition = this.currentDropTarget.def;
            var eventTarget = p.e.target || p.e.srcElement;
            if (targetDefinition == null) {
              return null;
            }
            var eps = this.instance._deriveEndpointAndAnchorSpec(jpc.getType().join(" "), true);
            var pp = eps.endpoints ? extend(p, {
              endpoint: targetDefinition.def.endpoint || eps.endpoints[1]
            }) : p;
            var anchorsToUse = this.instance.validAnchorsSpec(eps.anchors) ? eps.anchors : this.instance.areDefaultAnchorsSet() ? this.instance.defaults.anchors : null;
            if (anchorsToUse) {
              pp = extend(pp, {
                anchor: targetDefinition.def.anchor || anchorsToUse[1]
              });
            }
            if (targetDefinition.def.portId != null) {
              pp.portId = targetDefinition.def.portId;
            }
            var extractedParameters = targetDefinition.def.parameterExtractor ? targetDefinition.def.parameterExtractor(this.currentDropTarget.el, eventTarget) : {};
            pp = merge(pp, extractedParameters);
            pp.element = this.currentDropTarget.targetEl;
            dropEndpoint = this.instance._internal_newEndpoint(pp);
            dropEndpoint._mtNew = true;
            dropEndpoint.deleteOnEmpty = true;
            if (targetDefinition.def.parameters) {
              dropEndpoint.mergeParameters(targetDefinition.def.parameters);
            }
            if (targetDefinition.def.extract) {
              var tpayload = {};
              for (var att in targetDefinition.def.extract) {
                var v = this.currentDropTarget.el.getAttribute(att);
                if (v) {
                  tpayload[targetDefinition.def.extract[att]] = v;
                }
              }
              dropEndpoint.mergeParameters(tpayload);
            }
          } else {
            dropEndpoint = this.currentDropTarget.endpoint;
          }
          if (dropEndpoint) {
            dropEndpoint.removeClass(this.instance.endpointDropAllowedClass);
            dropEndpoint.removeClass(this.instance.endpointDropForbiddenClass);
          }
          return dropEndpoint;
        }
      }, {
        key: "_doForceReattach",
        value: function _doForceReattach(idx) {
          this.floatingEndpoint.detachFromConnection(this.jpc, null, true);
          this.jpc.endpoints[idx] = this.jpc.suspendedEndpoint;
          this.instance.setHover(this.jpc, false);
          this.jpc._forceDetach = true;
          this.jpc.suspendedEndpoint.addConnection(this.jpc);
          this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.suspendedEndpoint.elementId, this.jpc, this.jpc.suspendedEndpoint.element, idx);
          this.instance.deleteEndpoint(this.floatingEndpoint);
          this.instance.repaint(this.jpc.source);
          delete this.jpc._forceDetach;
        }
      }, {
        key: "_shouldReattach",
        value: function _shouldReattach(originalEvent) {
          return this.jpc.isReattach() || this.jpc._forceReattach || !functionChain(true, false, [[this.jpc.endpoints[0], IS_DETACH_ALLOWED, [this.jpc]], [this.jpc.endpoints[1], IS_DETACH_ALLOWED, [this.jpc]], [this.jpc, IS_DETACH_ALLOWED, [this.jpc]], [this.instance, CHECK_CONDITION, [INTERCEPT_BEFORE_DETACH, this.jpc]]]);
        }
      }, {
        key: "_discard",
        value: function _discard(idx, originalEvent) {
          if (this.jpc.pending) {
            this.instance.fire(EVENT_CONNECTION_ABORT, this.jpc, originalEvent);
          } else {
            if (idx === 0) {
              this.jpc.source = this.jpc.suspendedEndpoint.element;
              this.jpc.sourceId = this.jpc.suspendedEndpoint.elementId;
            } else {
              this.jpc.target = this.jpc.suspendedEndpoint.element;
              this.jpc.targetId = this.jpc.suspendedEndpoint.elementId;
            }
            this.jpc.endpoints[idx] = this.jpc.suspendedEndpoint;
          }
          if (this.floatingEndpoint) {
            this.floatingEndpoint.detachFromConnection(this.jpc);
          }
          this.instance.deleteConnection(this.jpc, {
            originalEvent: originalEvent,
            force: true
          });
        }
      }, {
        key: "_drop",
        value: function _drop(dropEndpoint, idx, originalEvent, optionalData) {
          this.jpc.endpoints[idx].detachFromConnection(this.jpc);
          if (this.jpc.suspendedEndpoint) {
            this.jpc.suspendedEndpoint.detachFromConnection(this.jpc);
          }
          this.jpc.endpoints[idx] = dropEndpoint;
          dropEndpoint.addConnection(this.jpc);
          if (this.jpc.suspendedEndpoint) {
            var suspendedElementId = this.jpc.suspendedEndpoint.elementId;
            this.instance.fireMoveEvent({
              index: idx,
              originalSourceId: idx === 0 ? suspendedElementId : this.jpc.sourceId,
              newSourceId: idx === 0 ? dropEndpoint.elementId : this.jpc.sourceId,
              originalTargetId: idx === 1 ? suspendedElementId : this.jpc.targetId,
              newTargetId: idx === 1 ? dropEndpoint.elementId : this.jpc.targetId,
              originalEndpoint: this.jpc.suspendedEndpoint,
              connection: this.jpc,
              newEndpoint: dropEndpoint
            }, originalEvent);
          }
          if (idx === 1) {
            this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.targetId, this.jpc, this.jpc.target, 1);
          } else {
            this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.sourceId, this.jpc, this.jpc.source, 0);
          }
          if (this.jpc.endpoints[0].finalEndpoint) {
            var _toDelete = this.jpc.endpoints[0];
            _toDelete.detachFromConnection(this.jpc);
            this.jpc.endpoints[0] = this.jpc.endpoints[0].finalEndpoint;
            this.jpc.endpoints[0].addConnection(this.jpc);
          }
          if (isObject(optionalData)) {
            this.jpc.mergeData(optionalData);
          }
          if (this._originalAnchor) {
            this.jpc.endpoints[0].setAnchor(this._originalAnchor);
            this._originalAnchor = null;
          }
          this.instance._finaliseConnection(this.jpc, null, originalEvent);
          this.instance.setHover(this.jpc, false);
          this.instance.revalidate(this.jpc.endpoints[0].element);
        }
      }, {
        key: "_registerFloatingConnection",
        value: function _registerFloatingConnection(info, conn, ep) {
          this.floatingConnections[info.id] = conn;
          addToDictionary(this.instance.endpointsByElement, info.id, ep);
        }
      }, {
        key: "_getFloatingAnchorIndex",
        value: function _getFloatingAnchorIndex() {
          return this.floatingIndex == null ? 1 : this.floatingIndex;
        }
      }]);
      return EndpointDragHandler;
    }();

    var GroupDragHandler = function (_ElementDragHandler) {
      _inherits(GroupDragHandler, _ElementDragHandler);
      var _super = _createSuper(GroupDragHandler);
      function GroupDragHandler(instance, dragSelection) {
        var _this;
        _classCallCheck(this, GroupDragHandler);
        _this = _super.call(this, instance, dragSelection);
        _this.instance = instance;
        _this.dragSelection = dragSelection;
        _defineProperty(_assertThisInitialized(_this), "selector", [">", SELECTOR_GROUP, SELECTOR_MANAGED_ELEMENT].join(" "));
        _defineProperty(_assertThisInitialized(_this), "doRevalidate", void 0);
        _this.doRevalidate = _this._revalidate.bind(_assertThisInitialized(_this));
        return _this;
      }
      _createClass(GroupDragHandler, [{
        key: "reset",
        value: function reset() {
          this.drag.off(EVENT_REVERT, this.doRevalidate);
        }
      }, {
        key: "_revalidate",
        value: function _revalidate(el) {
          this.instance.revalidate(el);
        }
      }, {
        key: "init",
        value: function init(drag) {
          this.drag = drag;
          drag.on(EVENT_REVERT, this.doRevalidate);
        }
      }, {
        key: "useGhostProxy",
        value: function useGhostProxy(container, dragEl) {
          var group = dragEl._jsPlumbParentGroup;
          return group == null ? false : group.ghost === true;
        }
      }, {
        key: "makeGhostProxy",
        value: function makeGhostProxy(el) {
          var jel = el;
          var newEl = jel.cloneNode(true);
          newEl._jsPlumbParentGroup = jel._jsPlumbParentGroup;
          return newEl;
        }
      }]);
      return GroupDragHandler;
    }(ElementDragHandler);

    var HTMLElementOverlay = function () {
      function HTMLElementOverlay(instance, overlay) {
        _classCallCheck(this, HTMLElementOverlay);
        this.instance = instance;
        this.overlay = overlay;
        _defineProperty(this, "htmlElementOverlay", void 0);
        this.htmlElementOverlay = overlay;
      }
      _createClass(HTMLElementOverlay, null, [{
        key: "createElement",
        value: function createElement$1(o) {
          var el = createElement(ELEMENT_DIV, {}, o.instance.overlayClass + " " + (o.cssClass ? o.cssClass : ""));
          o.instance.setAttribute(el, "jtk-overlay-id", o.id);
          return el;
        }
      }, {
        key: "getElement",
        value: function getElement(o, component, elementCreator) {
          if (o.canvas == null) {
            if (elementCreator && component) {
              o.canvas = elementCreator(component);
            } else {
              o.canvas = HTMLElementOverlay.createElement(o);
            }
            o.canvas.style.position = ABSOLUTE;
            o.instance._appendElement(o.canvas, o.instance.getContainer());
            o.instance.getId(o.canvas);
            var ts = "translate(-50%, -50%)";
            o.canvas.style.webkitTransform = ts;
            o.canvas.style.mozTransform = ts;
            o.canvas.style.msTransform = ts;
            o.canvas.style.oTransform = ts;
            o.canvas.style.transform = ts;
            if (!o.isVisible()) {
              o.canvas.style.display = NONE;
            }
            o.canvas.jtk = {
              overlay: o
            };
          }
          return o.canvas;
        }
      }, {
        key: "destroy",
        value: function destroy(o) {
          o.canvas && o.canvas.parentNode && o.canvas.parentNode.removeChild(o.canvas);
          delete o.canvas;
          delete o.cachedDimensions;
        }
      }, {
        key: "_getDimensions",
        value: function _getDimensions(o, forceRefresh) {
          if (o.cachedDimensions == null || forceRefresh) {
            o.cachedDimensions = {
              w: 1,
              h: 1
            };
          }
          return o.cachedDimensions;
        }
      }]);
      return HTMLElementOverlay;
    }();

    var SVGElementOverlay = function (_Overlay) {
      _inherits(SVGElementOverlay, _Overlay);
      var _super = _createSuper(SVGElementOverlay);
      function SVGElementOverlay() {
        var _this;
        _classCallCheck(this, SVGElementOverlay);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "path", void 0);
        return _this;
      }
      _createClass(SVGElementOverlay, null, [{
        key: "ensurePath",
        value: function ensurePath(o) {
          if (o.path == null) {
            o.path = _node(ELEMENT_PATH, {
              "jtk-overlay-id": o.id
            });
            var parent = null;
            if (o.component instanceof Connection) {
              var connector = o.component.connector;
              parent = connector != null ? connector.canvas : null;
            } else if (o.component instanceof Endpoint) {
              var endpoint = o.component.endpoint;
              parent = endpoint != null ? endpoint.svg : endpoint;
            }
            if (parent != null) {
              _appendAtIndex(parent, o.path, 1);
            }
            o.instance.addClass(o.path, o.instance.overlayClass);
            o.path.jtk = {
              overlay: o
            };
          }
          return o.path;
        }
      }, {
        key: "paint",
        value: function paint(o, path, params, extents) {
          this.ensurePath(o);
          var offset = [0, 0];
          if (extents.xmin < 0) {
            offset[0] = -extents.xmin;
          }
          if (extents.ymin < 0) {
            offset[1] = -extents.ymin;
          }
          var a = {
            "d": path,
            stroke: params.stroke ? params.stroke : null,
            fill: params.fill ? params.fill : null,
            transform: "translate(" + offset[0] + "," + offset[1] + ")",
            "pointer-events": "visibleStroke"
          };
          _attr(o.path, a);
        }
      }, {
        key: "destroy",
        value: function destroy(o, force) {
          var _o = o;
          if (_o.path != null && _o.path.parentNode != null) {
            _o.path.parentNode.removeChild(_o.path);
          }
          if (_o.bgPath != null && _o.bgPath.parentNode != null) {
            _o.bgPath.parentNode.removeChild(_o.bgPath);
          }
          delete _o.path;
          delete _o.bgPath;
        }
      }]);
      return SVGElementOverlay;
    }(Overlay);

    var SvgComponent = function () {
      function SvgComponent() {
        _classCallCheck(this, SvgComponent);
      }
      _createClass(SvgComponent, null, [{
        key: "paint",
        value: function paint(connector, useDivWrapper, paintStyle, extents) {
          if (paintStyle != null) {
            var xy = [connector.x, connector.y],
                wh = [connector.w, connector.h],
                p;
            if (extents != null) {
              if (extents.xmin < 0) {
                xy[0] += extents.xmin;
              }
              if (extents.ymin < 0) {
                xy[1] += extents.ymin;
              }
              wh[0] = extents.xmax + (extents.xmin < 0 ? -extents.xmin : 0);
              wh[1] = extents.ymax + (extents.ymin < 0 ? -extents.ymin : 0);
            }
            if (isFinite(wh[0]) && isFinite(wh[1])) {
              if (useDivWrapper) {
                _size(connector.canvas, xy[0], xy[1], wh[0], wh[1]);
                xy[0] = 0;
                xy[1] = 0;
                p = _pos([0, 0]);
                _attr(connector.svg, {
                  "style": p,
                  "width": "" + (wh[0] || 0),
                  "height": "" + (wh[1] || 0)
                });
              } else {
                p = _pos([xy[0], xy[1]]);
                _attr(connector.canvas, {
                  "style": p,
                  "width": "" + (wh[0] || 0),
                  "height": "" + (wh[1] || 0)
                });
              }
            }
          }
        }
      }]);
      return SvgComponent;
    }();

    function paintSvgConnector(instance, connector, paintStyle, extents) {
      getConnectorElement(instance, connector);
      SvgComponent.paint(connector, false, paintStyle, extents);
      var p = "",
          offset = [0, 0];
      if (extents.xmin < 0) {
        offset[0] = -extents.xmin;
      }
      if (extents.ymin < 0) {
        offset[1] = -extents.ymin;
      }
      if (connector.segments.length > 0) {
        p = instance.getPathData(connector);
        var a = {
          d: p,
          transform: "translate(" + offset[0] + "," + offset[1] + ")",
          "pointer-events": "visibleStroke"
        },
            outlineStyle = null;
        if (paintStyle.outlineStroke) {
          var outlineWidth = paintStyle.outlineWidth || 1,
              outlineStrokeWidth = paintStyle.strokeWidth + 2 * outlineWidth;
          outlineStyle = extend({}, paintStyle);
          outlineStyle.stroke = paintStyle.outlineStroke;
          outlineStyle.strokeWidth = outlineStrokeWidth;
          if (connector.bgPath == null) {
            connector.bgPath = _node(ELEMENT_PATH, a);
            instance.addClass(connector.bgPath, instance.connectorOutlineClass);
            _appendAtIndex(connector.canvas, connector.bgPath, 0);
          } else {
            _attr(connector.bgPath, a);
          }
          _applyStyles(connector.canvas, connector.bgPath, outlineStyle);
        }
        var cany = connector;
        if (cany.path == null) {
          cany.path = _node(ELEMENT_PATH, a);
          _appendAtIndex(cany.canvas, cany.path, paintStyle.outlineStroke ? 1 : 0);
        } else {
          if (cany.path.parentNode !== cany.canvas) {
            _appendAtIndex(cany.canvas, cany.path, paintStyle.outlineStroke ? 1 : 0);
          }
          _attr(connector.path, a);
        }
        _applyStyles(connector.canvas, connector.path, paintStyle);
      }
    }
    function getConnectorElement(instance, c) {
      if (c.canvas != null) {
        return c.canvas;
      } else {
        var svg = _node(ELEMENT_SVG, {
          "style": "",
          "width": "0",
          "height": "0",
          "pointer-events": NONE,
          "position": ABSOLUTE
        });
        c.canvas = svg;
        instance._appendElement(c.canvas, instance.getContainer());
        if (c.cssClass != null) {
          instance.addClass(svg, c.cssClass);
        }
        instance.addClass(svg, instance.connectorClass);
        svg.jtk = svg.jtk || {};
        svg.jtk.connector = c;
        return svg;
      }
    }

    var SvgEndpoint = function () {
      function SvgEndpoint() {
        _classCallCheck(this, SvgEndpoint);
      }
      _createClass(SvgEndpoint, null, [{
        key: "getEndpointElement",
        value: function getEndpointElement(ep) {
          if (ep.canvas != null) {
            return ep.canvas;
          } else {
            var svg = _node(ELEMENT_SVG, {
              "style": "",
              "width": "0",
              "height": "0",
              "pointer-events": NONE,
              "position": ABSOLUTE
            });
            ep.svg = svg;
            var canvas = createElement(ELEMENT_DIV, {
              position: ABSOLUTE
            });
            ep.canvas = canvas;
            var classes = ep.classes.join(" ");
            ep.instance.addClass(canvas, classes);
            var scopes = ep.endpoint.scope.split(/\s/);
            for (var i = 0; i < scopes.length; i++) {
              ep.instance.setAttribute(canvas, ATTRIBUTE_SCOPE_PREFIX + scopes[i], TRUE$1);
            }
            if (!ep.instance._suspendDrawing) {
              _size(canvas, 0, 0, 1, 1);
            }
            ep.instance._appendElement(canvas, ep.instance.getContainer());
            canvas.appendChild(svg);
            if (ep.cssClass != null) {
              ep.instance.addClass(canvas, ep.cssClass);
            }
            ep.instance.addClass(canvas, ep.instance.endpointClass);
            canvas.jtk = canvas.jtk || {};
            canvas.jtk.endpoint = ep.endpoint;
            canvas.style.display = ep.endpoint.visible !== false ? BLOCK : NONE;
            return canvas;
          }
        }
      }, {
        key: "paint",
        value: function paint(ep, handlers, paintStyle) {
          this.getEndpointElement(ep);
          SvgComponent.paint(ep, true, paintStyle);
          var s = extend({}, paintStyle);
          if (s.outlineStroke) {
            s.stroke = s.outlineStroke;
          }
          if (ep.node == null) {
            ep.node = handlers.makeNode(ep, s);
            ep.svg.appendChild(ep.node);
          } else if (handlers.updateNode != null) {
            handlers.updateNode(ep, ep.node);
          }
          _applyStyles(ep.canvas, ep.node, s);
        }
      }]);
      return SvgEndpoint;
    }();

    var endpointMap = {};
    function registerEndpointRenderer(name, fns) {
      endpointMap[name] = fns;
    }
    function getPositionOnElement(evt, el, zoom) {
      var jel = el;
      var box = _typeof(el.getBoundingClientRect) !== UNDEFINED ? el.getBoundingClientRect() : {
        left: 0,
        top: 0,
        width: 0,
        height: 0
      },
          body = document.body,
          docElem = document.documentElement,
          scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
          scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
          clientTop = docElem.clientTop || body.clientTop || 0,
          clientLeft = docElem.clientLeft || body.clientLeft || 0,
          pst = 0,
          psl = 0,
          top = box.top + scrollTop - clientTop + pst * zoom,
          left = box.left + scrollLeft - clientLeft + psl * zoom,
          cl = pageLocation(evt),
          w = box.width || jel.offsetWidth * zoom,
          h = box.height || jel.offsetHeight * zoom,
          x = (cl.x - left) / w,
          y = (cl.y - top) / h;
      return {
        x: x,
        y: y
      };
    }
    function isSVGElementOverlay(o) {
      return isArrowOverlay(o) || isDiamondOverlay(o) || isPlainArrowOverlay(o);
    }
    function setVisible(component, v) {
      if (component.canvas) {
        component.canvas.style.display = v ? "block" : "none";
      }
    }
    function cleanup(component) {
      if (component.canvas) {
        component.canvas.parentNode.removeChild(component.canvas);
      }
      delete component.canvas;
      delete component.svg;
    }
    function getEndpointCanvas(ep) {
      return ep.canvas;
    }
    function getLabelElement(o) {
      return HTMLElementOverlay.getElement(o);
    }
    function getCustomElement(o) {
      return HTMLElementOverlay.getElement(o, o.component, function (c) {
        var el = o.create(c);
        o.instance.addClass(el, o.instance.overlayClass);
        return el;
      });
    }
    function groupDragConstrain(desiredLoc, dragEl, constrainRect, size) {
      var x = desiredLoc.x,
          y = desiredLoc.y;
      if (dragEl._jsPlumbParentGroup && dragEl._jsPlumbParentGroup.constrain) {
        x = Math.max(desiredLoc.x, 0);
        y = Math.max(desiredLoc.y, 0);
        x = Math.min(x, constrainRect.w - size.w);
        y = Math.min(y, constrainRect.h - size.h);
      }
      return {
        x: x,
        y: y
      };
    }
    var BrowserJsPlumbInstance = function (_JsPlumbInstance) {
      _inherits(BrowserJsPlumbInstance, _JsPlumbInstance);
      var _super = _createSuper(BrowserJsPlumbInstance);
      function BrowserJsPlumbInstance(_instanceIndex, defaults) {
        var _this;
        _classCallCheck(this, BrowserJsPlumbInstance);
        _this = _super.call(this, _instanceIndex, defaults);
        _this._instanceIndex = _instanceIndex;
        _defineProperty(_assertThisInitialized(_this), "dragSelection", void 0);
        _defineProperty(_assertThisInitialized(_this), "dragManager", void 0);
        _defineProperty(_assertThisInitialized(_this), "_connectorClick", void 0);
        _defineProperty(_assertThisInitialized(_this), "_connectorDblClick", void 0);
        _defineProperty(_assertThisInitialized(_this), "_connectorTap", void 0);
        _defineProperty(_assertThisInitialized(_this), "_connectorDblTap", void 0);
        _defineProperty(_assertThisInitialized(_this), "_endpointClick", void 0);
        _defineProperty(_assertThisInitialized(_this), "_endpointDblClick", void 0);
        _defineProperty(_assertThisInitialized(_this), "_overlayClick", void 0);
        _defineProperty(_assertThisInitialized(_this), "_overlayDblClick", void 0);
        _defineProperty(_assertThisInitialized(_this), "_overlayTap", void 0);
        _defineProperty(_assertThisInitialized(_this), "_overlayDblTap", void 0);
        _defineProperty(_assertThisInitialized(_this), "_connectorMouseover", void 0);
        _defineProperty(_assertThisInitialized(_this), "_connectorMouseout", void 0);
        _defineProperty(_assertThisInitialized(_this), "_endpointMouseover", void 0);
        _defineProperty(_assertThisInitialized(_this), "_endpointMouseout", void 0);
        _defineProperty(_assertThisInitialized(_this), "_connectorContextmenu", void 0);
        _defineProperty(_assertThisInitialized(_this), "_connectorMousedown", void 0);
        _defineProperty(_assertThisInitialized(_this), "_connectorMouseup", void 0);
        _defineProperty(_assertThisInitialized(_this), "_endpointMousedown", void 0);
        _defineProperty(_assertThisInitialized(_this), "_endpointMouseup", void 0);
        _defineProperty(_assertThisInitialized(_this), "_overlayMouseover", void 0);
        _defineProperty(_assertThisInitialized(_this), "_overlayMouseout", void 0);
        _defineProperty(_assertThisInitialized(_this), "_elementClick", void 0);
        _defineProperty(_assertThisInitialized(_this), "_elementTap", void 0);
        _defineProperty(_assertThisInitialized(_this), "_elementDblTap", void 0);
        _defineProperty(_assertThisInitialized(_this), "_elementMouseenter", void 0);
        _defineProperty(_assertThisInitialized(_this), "_elementMouseexit", void 0);
        _defineProperty(_assertThisInitialized(_this), "_elementMousemove", void 0);
        _defineProperty(_assertThisInitialized(_this), "_elementMouseup", void 0);
        _defineProperty(_assertThisInitialized(_this), "_elementMousedown", void 0);
        _defineProperty(_assertThisInitialized(_this), "_elementContextmenu", void 0);
        _defineProperty(_assertThisInitialized(_this), "eventManager", void 0);
        _defineProperty(_assertThisInitialized(_this), "draggingClass", "jtk-dragging");
        _defineProperty(_assertThisInitialized(_this), "elementDraggingClass", "jtk-element-dragging");
        _defineProperty(_assertThisInitialized(_this), "hoverClass", "jtk-hover");
        _defineProperty(_assertThisInitialized(_this), "sourceElementDraggingClass", "jtk-source-element-dragging");
        _defineProperty(_assertThisInitialized(_this), "targetElementDraggingClass", "jtk-target-element-dragging");
        _defineProperty(_assertThisInitialized(_this), "hoverSourceClass", "jtk-source-hover");
        _defineProperty(_assertThisInitialized(_this), "hoverTargetClass", "jtk-target-hover");
        _defineProperty(_assertThisInitialized(_this), "dragSelectClass", "jtk-drag-select");
        _defineProperty(_assertThisInitialized(_this), "managedElementsSelector", void 0);
        _defineProperty(_assertThisInitialized(_this), "elementsDraggable", void 0);
        _defineProperty(_assertThisInitialized(_this), "elementDragHandler", void 0);
        _defineProperty(_assertThisInitialized(_this), "groupDragOptions", void 0);
        _defineProperty(_assertThisInitialized(_this), "elementDragOptions", void 0);
        _defineProperty(_assertThisInitialized(_this), "svg", {
          node: function node(name, attributes) {
            return _node(name, attributes);
          },
          attr: function attr(node, attributes) {
            return _attr(node, attributes);
          },
          pos: function pos(d) {
            return _pos(d);
          }
        });
        _this.elementsDraggable = defaults && defaults.elementsDraggable !== false;
        _this.managedElementsSelector = defaults ? defaults.managedElementsSelector || SELECTOR_MANAGED_ELEMENT : SELECTOR_MANAGED_ELEMENT;
        _this.eventManager = new EventManager();
        _this.dragSelection = new DragSelection(_assertThisInitialized(_this));
        _this.dragManager = new DragManager(_assertThisInitialized(_this), _this.dragSelection
        );
        _this.dragManager.addHandler(new EndpointDragHandler(_assertThisInitialized(_this)));
        _this.groupDragOptions = {
          constrainFunction: groupDragConstrain
        };
        _this.dragManager.addHandler(new GroupDragHandler(_assertThisInitialized(_this), _this.dragSelection), _this.groupDragOptions);
        _this.elementDragHandler = new ElementDragHandler(_assertThisInitialized(_this), _this.dragSelection);
        _this.elementDragOptions = defaults && defaults.dragOptions || {};
        _this.dragManager.addHandler(_this.elementDragHandler, _this.elementDragOptions);
        if (defaults && defaults.dragOptions && defaults.dragOptions.filter) {
          _this.dragManager.addFilter(defaults.dragOptions.filter);
        }
        var _connClick = function _connClick(event, e) {
          if (!e.defaultPrevented && e._jsPlumbOverlay == null) {
            var connectorElement = findParent(getEventSource(e), SELECTOR_CONNECTOR, this.getContainer(), true);
            this.fire(event, connectorElement.jtk.connector.connection, e);
          }
        };
        _this._connectorClick = _connClick.bind(_assertThisInitialized(_this), EVENT_CONNECTION_CLICK);
        _this._connectorDblClick = _connClick.bind(_assertThisInitialized(_this), EVENT_CONNECTION_DBL_CLICK);
        _this._connectorTap = _connClick.bind(_assertThisInitialized(_this), EVENT_CONNECTION_TAP);
        _this._connectorDblTap = _connClick.bind(_assertThisInitialized(_this), EVENT_CONNECTION_DBL_TAP);
        var _connectorHover = function _connectorHover(state, e) {
          var el = getEventSource(e).parentNode;
          if (el.jtk && el.jtk.connector) {
            this.setConnectorHover(el.jtk.connector, state);
            this.fire(state ? EVENT_CONNECTION_MOUSEOVER : EVENT_CONNECTION_MOUSEOUT, el.jtk.connector.connection, e);
          }
        };
        _this._connectorMouseover = _connectorHover.bind(_assertThisInitialized(_this), true);
        _this._connectorMouseout = _connectorHover.bind(_assertThisInitialized(_this), false);
        var _connectorMouseupdown = function _connectorMouseupdown(state, e) {
          var el = getEventSource(e).parentNode;
          if (el.jtk && el.jtk.connector) {
            this.fire(state ? EVENT_CONNECTION_MOUSEUP : EVENT_CONNECTION_MOUSEDOWN, el.jtk.connector.connection, e);
          }
        };
        _this._connectorMouseup = _connectorMouseupdown.bind(_assertThisInitialized(_this), true);
        _this._connectorMousedown = _connectorMouseupdown.bind(_assertThisInitialized(_this), false);
        _this._connectorContextmenu = function (e) {
          var el = getEventSource(e).parentNode;
          if (el.jtk && el.jtk.connector) {
            this.fire(EVENT_CONNECTION_CONTEXTMENU, el.jtk.connector.connection, e);
          }
        }.bind(_assertThisInitialized(_this));
        var _epClick = function _epClick(event, e, endpointElement) {
          if (!e.defaultPrevented && e._jsPlumbOverlay == null) {
            this.fire(event, endpointElement.jtk.endpoint, e);
          }
        };
        _this._endpointClick = _epClick.bind(_assertThisInitialized(_this), EVENT_ENDPOINT_CLICK);
        _this._endpointDblClick = _epClick.bind(_assertThisInitialized(_this), EVENT_ENDPOINT_DBL_CLICK);
        var _endpointHover = function _endpointHover(state, e) {
          var el = getEventSource(e);
          if (el.jtk && el.jtk.endpoint) {
            this.setEndpointHover(el.jtk.endpoint, state);
            this.fire(state ? EVENT_ENDPOINT_MOUSEOVER : EVENT_ENDPOINT_MOUSEOUT, el.jtk.endpoint, e);
          }
        };
        _this._endpointMouseover = _endpointHover.bind(_assertThisInitialized(_this), true);
        _this._endpointMouseout = _endpointHover.bind(_assertThisInitialized(_this), false);
        var _endpointMouseupdown = function _endpointMouseupdown(state, e) {
          var el = getEventSource(e);
          if (el.jtk && el.jtk.endpoint) {
            this.fire(state ? EVENT_ENDPOINT_MOUSEUP : EVENT_ENDPOINT_MOUSEDOWN, el.jtk.endpoint, e);
          }
        };
        _this._endpointMouseup = _endpointMouseupdown.bind(_assertThisInitialized(_this), true);
        _this._endpointMousedown = _endpointMouseupdown.bind(_assertThisInitialized(_this), false);
        var _oClick = function (method, e) {
          var overlayElement = findParent(getEventSource(e), SELECTOR_OVERLAY, this.getContainer(), true);
          var overlay = overlayElement.jtk.overlay;
          if (overlay) {
            this.fireOverlayMethod(overlay, method, e);
          }
        }.bind(_assertThisInitialized(_this));
        _this._overlayClick = _oClick.bind(_assertThisInitialized(_this), EVENT_CLICK);
        _this._overlayDblClick = _oClick.bind(_assertThisInitialized(_this), EVENT_DBL_CLICK);
        _this._overlayTap = _oClick.bind(_assertThisInitialized(_this), EVENT_TAP);
        _this._overlayDblTap = _oClick.bind(_assertThisInitialized(_this), EVENT_DBL_TAP);
        var _overlayHover = function _overlayHover(state, e) {
          var overlayElement = findParent(getEventSource(e), SELECTOR_OVERLAY, this.getContainer(), true);
          var overlay = overlayElement.jtk.overlay;
          if (overlay) {
            this.setOverlayHover(overlay, state);
          }
        };
        _this._overlayMouseover = _overlayHover.bind(_assertThisInitialized(_this), true);
        _this._overlayMouseout = _overlayHover.bind(_assertThisInitialized(_this), false);
        var _elementClick = function _elementClick(event, e, target) {
          if (!e.defaultPrevented) {
            this.fire(e.detail === 1 ? EVENT_ELEMENT_CLICK : EVENT_ELEMENT_DBL_CLICK, target, e);
          }
        };
        _this._elementClick = _elementClick.bind(_assertThisInitialized(_this), EVENT_ELEMENT_CLICK);
        var _elementTap = function _elementTap(event, e, target) {
          if (!e.defaultPrevented) {
            this.fire(EVENT_ELEMENT_TAP, target, e);
          }
        };
        _this._elementTap = _elementTap.bind(_assertThisInitialized(_this), EVENT_ELEMENT_TAP);
        var _elementDblTap = function _elementDblTap(event, e, target) {
          if (!e.defaultPrevented) {
            this.fire(EVENT_ELEMENT_DBL_TAP, target, e);
          }
        };
        _this._elementDblTap = _elementDblTap.bind(_assertThisInitialized(_this), EVENT_ELEMENT_DBL_TAP);
        var _elementHover = function _elementHover(state, e) {
          this.fire(state ? EVENT_ELEMENT_MOUSE_OVER : EVENT_ELEMENT_MOUSE_OUT, getEventSource(e), e);
        };
        _this._elementMouseenter = _elementHover.bind(_assertThisInitialized(_this), true);
        _this._elementMouseexit = _elementHover.bind(_assertThisInitialized(_this), false);
        _this._elementMousemove = function (e) {
          this.fire(EVENT_ELEMENT_MOUSE_MOVE, getEventSource(e), e);
        }.bind(_assertThisInitialized(_this));
        _this._elementMouseup = function (e) {
          this.fire(EVENT_ELEMENT_MOUSE_UP, getEventSource(e), e);
        }.bind(_assertThisInitialized(_this));
        _this._elementMousedown = function (e) {
          this.fire(EVENT_ELEMENT_MOUSE_DOWN, getEventSource(e), e);
        }.bind(_assertThisInitialized(_this));
        _this._elementContextmenu = function (e) {
          this.fire(EVENT_ELEMENT_CONTEXTMENU, getEventSource(e), e);
        }.bind(_assertThisInitialized(_this));
        _this._attachEventDelegates();
        return _this;
      }
      _createClass(BrowserJsPlumbInstance, [{
        key: "fireOverlayMethod",
        value: function fireOverlayMethod(overlay, event, e) {
          var stem = overlay.component instanceof Connection ? CONNECTION : ENDPOINT;
          var mappedEvent = compoundEvent(stem, event)
          ;
          e._jsPlumbOverlay = overlay;
          overlay.fire(event, {
            e: e,
            overlay: overlay
          });
          this.fire(mappedEvent, overlay.component, e);
        }
      }, {
        key: "addDragFilter",
        value: function addDragFilter(filter, exclude) {
          this.dragManager.addFilter(filter, exclude);
        }
      }, {
        key: "removeDragFilter",
        value: function removeDragFilter(filter) {
          this.dragManager.removeFilter(filter);
        }
      }, {
        key: "setDragGrid",
        value: function setDragGrid(grid) {
          this.dragManager.setOption(this.elementDragHandler, {
            grid: grid
          });
        }
      }, {
        key: "_removeElement",
        value: function _removeElement(element) {
          element.parentNode && element.parentNode.removeChild(element);
        }
      }, {
        key: "_appendElement",
        value: function _appendElement(el, parent) {
          if (parent) {
            parent.appendChild(el);
          }
        }
      }, {
        key: "_getAssociatedElements",
        value: function _getAssociatedElements(el) {
          var a = [];
          if (el.nodeType !== 3 && el.nodeType !== 8) {
            var els = el.querySelectorAll(SELECTOR_MANAGED_ELEMENT);
            Array.prototype.push.apply(a, els);
          }
          return a.filter(function (_a) {
            return _a.nodeType !== 3 && _a.nodeType !== 8;
          });
        }
      }, {
        key: "shouldFireEvent",
        value: function shouldFireEvent(event, value, originalEvent) {
          return true;
        }
      }, {
        key: "getClass",
        value: function getClass$1(el) {
          return getClass(el);
        }
      }, {
        key: "addClass",
        value: function addClass$1(el, clazz) {
          addClass(el, clazz);
        }
      }, {
        key: "hasClass",
        value: function hasClass$1(el, clazz) {
          return hasClass(el, clazz);
        }
      }, {
        key: "removeClass",
        value: function removeClass$1(el, clazz) {
          removeClass(el, clazz);
        }
      }, {
        key: "toggleClass",
        value: function toggleClass$1(el, clazz) {
          toggleClass(el, clazz);
        }
      }, {
        key: "setAttribute",
        value: function setAttribute(el, name, value) {
          el.setAttribute(name, value);
        }
      }, {
        key: "getAttribute",
        value: function getAttribute(el, name) {
          return el.getAttribute(name);
        }
      }, {
        key: "setAttributes",
        value: function setAttributes(el, atts) {
          for (var i in atts) {
            el.setAttribute(i, atts[i]);
          }
        }
      }, {
        key: "removeAttribute",
        value: function removeAttribute(el, attName) {
          el.removeAttribute && el.removeAttribute(attName);
        }
      }, {
        key: "on",
        value: function on(el, event, callbackOrSelector, callback) {
          var _this2 = this;
          var _one = function _one(_el) {
            if (callback == null) {
              _this2.eventManager.on(_el, event, callbackOrSelector);
            } else {
              _this2.eventManager.on(_el, event, callbackOrSelector, callback);
            }
          };
          if (isNodeList(el)) {
            forEach(el, function (el) {
              return _one(el);
            });
          } else {
            _one(el);
          }
          return this;
        }
      }, {
        key: "off",
        value: function off(el, event, callback) {
          var _this3 = this;
          if (isNodeList(el)) {
            forEach(el, function (_el) {
              return _this3.eventManager.off(_el, event, callback);
            });
          } else {
            this.eventManager.off(el, event, callback);
          }
          return this;
        }
      }, {
        key: "trigger",
        value: function trigger(el, event, originalEvent, payload, detail) {
          this.eventManager.trigger(el, event, originalEvent, payload, detail);
        }
      }, {
        key: "getOffsetRelativeToRoot",
        value: function getOffsetRelativeToRoot(el) {
          return offsetRelativeToRoot(el);
        }
      }, {
        key: "getOffset",
        value: function getOffset(el) {
          var jel = el;
          var container = this.getContainer();
          var out = {
            x: jel.offsetLeft,
            y: jel.offsetTop
          },
              op = el !== container && jel.offsetParent !== container ? jel.offsetParent : null,
              _maybeAdjustScroll = function _maybeAdjustScroll(offsetParent) {
            if (offsetParent != null && offsetParent !== document.body && (offsetParent.scrollTop > 0 || offsetParent.scrollLeft > 0)) {
              out.x -= offsetParent.scrollLeft;
              out.y -= offsetParent.scrollTop;
            }
          };
          while (op != null) {
            out.x += op.offsetLeft;
            out.y += op.offsetTop;
            _maybeAdjustScroll(op);
            op = op.offsetParent === container ? null : op.offsetParent;
          }
          if (container != null && (container.scrollTop > 0 || container.scrollLeft > 0)) {
            var pp = jel.offsetParent != null ? this.getStyle(jel.offsetParent, PROPERTY_POSITION) : STATIC,
                p = this.getStyle(jel, PROPERTY_POSITION);
            if (p !== ABSOLUTE && p !== FIXED && pp !== ABSOLUTE && pp !== FIXED) {
              out.x -= container.scrollLeft;
              out.y -= container.scrollTop;
            }
          }
          return out;
        }
      }, {
        key: "getSize",
        value: function getSize(el) {
          return size(el);
        }
      }, {
        key: "getStyle",
        value: function getStyle(el, prop) {
          if (_typeof(window.getComputedStyle) !== UNDEFINED) {
            return getComputedStyle(el, null).getPropertyValue(prop);
          } else {
            return el.currentStyle[prop];
          }
        }
      }, {
        key: "getGroupContentArea",
        value: function getGroupContentArea(group) {
          var da = this.getSelector(group.el, SELECTOR_GROUP_CONTAINER);
          return da && da.length > 0 ? da[0] : group.el;
        }
      }, {
        key: "getSelector",
        value: function getSelector(ctx, spec) {
          var sel = null;
          if (arguments.length === 1) {
            if (!isString(ctx)) {
              var nodeList = document.createDocumentFragment();
              nodeList.appendChild(ctx);
              return fromArray(nodeList.childNodes);
            }
            sel = fromArray(document.querySelectorAll(ctx));
          } else {
            sel = fromArray(ctx.querySelectorAll(spec));
          }
          return sel;
        }
      }, {
        key: "setPosition",
        value: function setPosition(el, p) {
          var jel = el;
          jel.style.left = p.x + "px";
          jel.style.top = p.y + "px";
        }
      }, {
        key: "setDraggable",
        value: function setDraggable(element, draggable) {
          if (draggable) {
            this.removeAttribute(element, ATTRIBUTE_NOT_DRAGGABLE);
          } else {
            this.setAttribute(element, ATTRIBUTE_NOT_DRAGGABLE, TRUE$1);
          }
        }
      }, {
        key: "isDraggable",
        value: function isDraggable(el) {
          var d = this.getAttribute(el, ATTRIBUTE_NOT_DRAGGABLE);
          return d == null || d === FALSE$1;
        }
      }, {
        key: "toggleDraggable",
        value: function toggleDraggable(el) {
          var state = this.isDraggable(el);
          this.setDraggable(el, !state);
          return !state;
        }
      }, {
        key: "_attachEventDelegates",
        value: function _attachEventDelegates() {
          var currentContainer = this.getContainer();
          this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_OVERLAY, this._overlayClick);
          this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_OVERLAY, this._overlayDblClick);
          this.eventManager.on(currentContainer, EVENT_TAP, SELECTOR_OVERLAY, this._overlayTap);
          this.eventManager.on(currentContainer, EVENT_DBL_TAP, SELECTOR_OVERLAY, this._overlayDblTap);
          this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_CONNECTOR, this._connectorClick);
          this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_CONNECTOR, this._connectorDblClick);
          this.eventManager.on(currentContainer, EVENT_TAP, SELECTOR_CONNECTOR, this._connectorTap);
          this.eventManager.on(currentContainer, EVENT_DBL_TAP, SELECTOR_CONNECTOR, this._connectorDblTap);
          this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_ENDPOINT, this._endpointClick);
          this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_ENDPOINT, this._endpointDblClick);
          this.eventManager.on(currentContainer, EVENT_CLICK, this.managedElementsSelector, this._elementClick);
          this.eventManager.on(currentContainer, EVENT_TAP, this.managedElementsSelector, this._elementTap);
          this.eventManager.on(currentContainer, EVENT_DBL_TAP, this.managedElementsSelector, this._elementDblTap);
          this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_CONNECTOR, this._connectorMouseover);
          this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_CONNECTOR, this._connectorMouseout);
          this.eventManager.on(currentContainer, EVENT_CONTEXTMENU, SELECTOR_CONNECTOR, this._connectorContextmenu);
          this.eventManager.on(currentContainer, EVENT_MOUSEUP, SELECTOR_CONNECTOR, this._connectorMouseup);
          this.eventManager.on(currentContainer, EVENT_MOUSEDOWN, SELECTOR_CONNECTOR, this._connectorMousedown);
          this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_ENDPOINT, this._endpointMouseover);
          this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_ENDPOINT, this._endpointMouseout);
          this.eventManager.on(currentContainer, EVENT_MOUSEUP, SELECTOR_ENDPOINT, this._endpointMouseup);
          this.eventManager.on(currentContainer, EVENT_MOUSEDOWN, SELECTOR_ENDPOINT, this._endpointMousedown);
          this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_OVERLAY, this._overlayMouseover);
          this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_OVERLAY, this._overlayMouseout);
          this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_MANAGED_ELEMENT, this._elementMouseenter);
          this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_MANAGED_ELEMENT, this._elementMouseexit);
          this.eventManager.on(currentContainer, EVENT_MOUSEMOVE, SELECTOR_MANAGED_ELEMENT, this._elementMousemove);
          this.eventManager.on(currentContainer, EVENT_MOUSEUP, SELECTOR_MANAGED_ELEMENT, this._elementMouseup);
          this.eventManager.on(currentContainer, EVENT_MOUSEDOWN, SELECTOR_MANAGED_ELEMENT, this._elementMousedown);
          this.eventManager.on(currentContainer, EVENT_CONTEXTMENU, SELECTOR_MANAGED_ELEMENT, this._elementContextmenu);
        }
      }, {
        key: "_detachEventDelegates",
        value: function _detachEventDelegates() {
          var currentContainer = this.getContainer();
          if (currentContainer) {
            this.eventManager.off(currentContainer, EVENT_CLICK, this._connectorClick);
            this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._connectorDblClick);
            this.eventManager.off(currentContainer, EVENT_TAP, this._connectorTap);
            this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._connectorDblTap);
            this.eventManager.off(currentContainer, EVENT_CLICK, this._endpointClick);
            this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._endpointDblClick);
            this.eventManager.off(currentContainer, EVENT_CLICK, this._overlayClick);
            this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._overlayDblClick);
            this.eventManager.off(currentContainer, EVENT_TAP, this._overlayTap);
            this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._overlayDblTap);
            this.eventManager.off(currentContainer, EVENT_CLICK, this._elementClick);
            this.eventManager.off(currentContainer, EVENT_TAP, this._elementTap);
            this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._elementDblTap);
            this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._connectorMouseover);
            this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._connectorMouseout);
            this.eventManager.off(currentContainer, EVENT_CONTEXTMENU, this._connectorContextmenu);
            this.eventManager.off(currentContainer, EVENT_MOUSEUP, this._connectorMouseup);
            this.eventManager.off(currentContainer, EVENT_MOUSEDOWN, this._connectorMousedown);
            this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._endpointMouseover);
            this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._endpointMouseout);
            this.eventManager.off(currentContainer, EVENT_MOUSEUP, this._endpointMouseup);
            this.eventManager.off(currentContainer, EVENT_MOUSEDOWN, this._endpointMousedown);
            this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._overlayMouseover);
            this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._overlayMouseout);
            this.eventManager.off(currentContainer, EVENT_MOUSEENTER, this._elementMouseenter);
            this.eventManager.off(currentContainer, EVENT_MOUSEEXIT, this._elementMouseexit);
            this.eventManager.off(currentContainer, EVENT_MOUSEMOVE, this._elementMousemove);
            this.eventManager.off(currentContainer, EVENT_MOUSEUP, this._elementMouseup);
            this.eventManager.off(currentContainer, EVENT_MOUSEDOWN, this._elementMousedown);
            this.eventManager.off(currentContainer, EVENT_CONTEXTMENU, this._elementContextmenu);
          }
        }
      }, {
        key: "setContainer",
        value: function setContainer(newContainer) {
          var _this4 = this;
          if (newContainer === document || newContainer === document.body) {
            throw new Error("Cannot set document or document.body as container element");
          }
          this._detachEventDelegates();
          var dragFilters;
          if (this.dragManager != null) {
            dragFilters = this.dragManager.reset();
          }
          this.setAttribute(newContainer, ATTRIBUTE_CONTAINER, uuid().replace("-", ""));
          var currentContainer = this.getContainer();
          if (currentContainer != null) {
            currentContainer.removeAttribute(ATTRIBUTE_CONTAINER);
            var children = fromArray(currentContainer.childNodes).filter(function (cn) {
              return cn != null && (_this4.hasClass(cn, CLASS_CONNECTOR) || _this4.hasClass(cn, CLASS_ENDPOINT) || _this4.hasClass(cn, CLASS_OVERLAY) || cn.getAttribute && cn.getAttribute(ATTRIBUTE_MANAGED) != null);
            });
            forEach(children, function (el) {
              newContainer.appendChild(el);
            });
          }
          _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), "setContainer", this).call(this, newContainer);
          if (this.eventManager != null) {
            this._attachEventDelegates();
          }
          if (this.dragManager != null) {
            this.dragManager.addHandler(new EndpointDragHandler(this));
            this.dragManager.addHandler(new GroupDragHandler(this, this.dragSelection), this.groupDragOptions);
            this.elementDragHandler = new ElementDragHandler(this, this.dragSelection);
            this.dragManager.addHandler(this.elementDragHandler, this.elementDragOptions);
            if (dragFilters != null) {
              this.dragManager.setFilters(dragFilters);
            }
          }
        }
      }, {
        key: "reset",
        value: function reset() {
          _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), "reset", this).call(this);
          var container = this.getContainer();
          var els = container.querySelectorAll([SELECTOR_MANAGED_ELEMENT, SELECTOR_ENDPOINT, SELECTOR_CONNECTOR, SELECTOR_OVERLAY].join(","));
          forEach(els, function (el) {
            return el.parentNode && el.parentNode.removeChild(el);
          });
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this._detachEventDelegates();
          if (this.dragManager != null) {
            this.dragManager.reset();
          }
          this.clearDragSelection();
          _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), "destroy", this).call(this);
        }
      }, {
        key: "unmanage",
        value: function unmanage(el, removeElement) {
          this.removeFromDragSelection(el);
          _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), "unmanage", this).call(this, el, removeElement);
        }
      }, {
        key: "addToDragSelection",
        value: function addToDragSelection() {
          var _this5 = this;
          for (var _len = arguments.length, el = new Array(_len), _key = 0; _key < _len; _key++) {
            el[_key] = arguments[_key];
          }
          forEach(el, function (_el) {
            return _this5.dragSelection.add(_el);
          });
        }
      }, {
        key: "clearDragSelection",
        value: function clearDragSelection() {
          this.dragSelection.clear();
        }
      }, {
        key: "removeFromDragSelection",
        value: function removeFromDragSelection() {
          var _this6 = this;
          for (var _len2 = arguments.length, el = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            el[_key2] = arguments[_key2];
          }
          forEach(el, function (_el) {
            return _this6.dragSelection.remove(_el);
          });
        }
      }, {
        key: "toggleDragSelection",
        value: function toggleDragSelection() {
          var _this7 = this;
          for (var _len3 = arguments.length, el = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            el[_key3] = arguments[_key3];
          }
          forEach(el, function (_el) {
            return _this7.dragSelection.toggle(_el);
          });
        }
      }, {
        key: "addToDragGroup",
        value: function addToDragGroup(spec) {
          var _this$elementDragHand;
          for (var _len4 = arguments.length, els = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            els[_key4 - 1] = arguments[_key4];
          }
          (_this$elementDragHand = this.elementDragHandler).addToDragGroup.apply(_this$elementDragHand, [spec].concat(els));
        }
      }, {
        key: "removeFromDragGroup",
        value: function removeFromDragGroup() {
          var _this$elementDragHand2;
          (_this$elementDragHand2 = this.elementDragHandler).removeFromDragGroup.apply(_this$elementDragHand2, arguments);
        }
      }, {
        key: "setDragGroupState",
        value: function setDragGroupState(state) {
          var _this$elementDragHand3;
          for (var _len5 = arguments.length, els = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
            els[_key5 - 1] = arguments[_key5];
          }
          (_this$elementDragHand3 = this.elementDragHandler).setDragGroupState.apply(_this$elementDragHand3, [state].concat(els));
        }
      }, {
        key: "consume",
        value: function consume$1(e, doNotPreventDefault) {
          consume(e, doNotPreventDefault);
        }
      }, {
        key: "rotate",
        value: function rotate(element, rotation, doNotRepaint) {
          var elementId = this.getId(element);
          if (this._managedElements[elementId]) {
            this._managedElements[elementId].el.style.transform = "rotate(" + rotation + "deg)";
            this._managedElements[elementId].el.style.transformOrigin = "center center";
            return _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), "rotate", this).call(this, element, rotation, doNotRepaint);
          }
          return {
            c: new Set(),
            e: new Set()
          };
        }
      }, {
        key: "addOverlayClass",
        value: function addOverlayClass(o, clazz) {
          if (isLabelOverlay(o)) {
            o.instance.addClass(getLabelElement(o), clazz);
          } else if (isSVGElementOverlay(o)) {
            o.instance.addClass(SVGElementOverlay.ensurePath(o), clazz);
          } else if (isCustomOverlay(o)) {
            o.instance.addClass(getCustomElement(o), clazz);
          } else {
            throw "Could not add class to overlay of type [" + o.type + "]";
          }
        }
      }, {
        key: "removeOverlayClass",
        value: function removeOverlayClass(o, clazz) {
          if (isLabelOverlay(o)) {
            o.instance.removeClass(getLabelElement(o), clazz);
          } else if (isSVGElementOverlay(o)) {
            o.instance.removeClass(SVGElementOverlay.ensurePath(o), clazz);
          } else if (isCustomOverlay(o)) {
            o.instance.removeClass(getCustomElement(o), clazz);
          } else {
            throw "Could not remove class from overlay of type [" + o.type + "]";
          }
        }
      }, {
        key: "paintOverlay",
        value: function paintOverlay(o, params, extents) {
          if (isLabelOverlay(o)) {
            getLabelElement(o);
            var XY = o.component.getXY();
            o.canvas.style.left = XY.x + params.d.minx + "px";
            o.canvas.style.top = XY.y + params.d.miny + "px";
          } else if (isSVGElementOverlay(o)) {
            var path = isNaN(params.d.cxy.x) || isNaN(params.d.cxy.y) ? "M 0 0" : "M" + params.d.hxy.x + "," + params.d.hxy.y + " L" + params.d.tail[0].x + "," + params.d.tail[0].y + " L" + params.d.cxy.x + "," + params.d.cxy.y + " L" + params.d.tail[1].x + "," + params.d.tail[1].y + " L" + params.d.hxy.x + "," + params.d.hxy.y;
            SVGElementOverlay.paint(o, path, params, extents);
          } else if (isCustomOverlay(o)) {
            getCustomElement(o);
            var _XY = o.component.getXY();
            o.canvas.style.left = _XY.x + params.d.minx + "px";
            o.canvas.style.top = _XY.y + params.d.miny + "px";
          } else {
            throw "Could not paint overlay of type [" + o.type + "]";
          }
        }
      }, {
        key: "setOverlayVisible",
        value: function setOverlayVisible(o, visible) {
          var d = visible ? "block" : "none";
          function s(el) {
            if (el != null) {
              el.style.display = d;
            }
          }
          if (isLabelOverlay(o)) {
            s(getLabelElement(o));
          } else if (isCustomOverlay(o)) {
            s(getCustomElement(o));
          } else if (isSVGElementOverlay(o)) {
            s(o.path);
          }
        }
      }, {
        key: "reattachOverlay",
        value: function reattachOverlay(o, c) {
          if (isLabelOverlay(o)) {
            o.instance._appendElement(getLabelElement(o), this.getContainer());
          } else if (isCustomOverlay(o)) {
            o.instance._appendElement(getCustomElement(o), this.getContainer());
          } else if (isSVGElementOverlay(o)) {
            this._appendElement(SVGElementOverlay.ensurePath(o), c.connector.canvas);
          }
        }
      }, {
        key: "setOverlayHover",
        value: function setOverlayHover(o, hover) {
          var canvas;
          if (isLabelOverlay(o)) {
            canvas = getLabelElement(o);
          } else if (isCustomOverlay(o)) {
            canvas = getCustomElement(o);
          } else if (isSVGElementOverlay(o)) {
            canvas = SVGElementOverlay.ensurePath(o);
          }
          if (canvas != null) {
            if (this.hoverClass != null) {
              if (hover) {
                this.addClass(canvas, this.hoverClass);
              } else {
                this.removeClass(canvas, this.hoverClass);
              }
            }
            this.setHover(o.component, hover);
          }
        }
      }, {
        key: "destroyOverlay",
        value: function destroyOverlay(o) {
          if (isLabelOverlay(o)) {
            var el = getLabelElement(o);
            el.parentNode.removeChild(el);
            delete o.canvas;
            delete o.cachedDimensions;
          } else if (isArrowOverlay(o) || isDiamondOverlay(o) || isPlainArrowOverlay(o)) {
            SVGElementOverlay.destroy(o);
          } else if (isCustomOverlay(o)) {
            var _el2 = getCustomElement(o);
            _el2.parentNode.removeChild(_el2);
            delete o.canvas;
            delete o.cachedDimensions;
          }
        }
      }, {
        key: "drawOverlay",
        value: function drawOverlay(o, component, paintStyle, absolutePosition) {
          if (isLabelOverlay(o) || isCustomOverlay(o)) {
            var td = HTMLElementOverlay._getDimensions(o);
            if (td != null && td.w != null && td.h != null) {
              var cxy = {
                x: 0,
                y: 0
              };
              if (absolutePosition) {
                cxy = {
                  x: absolutePosition.x,
                  y: absolutePosition.y
                };
              } else if (component instanceof EndpointRepresentation) {
                var locToUse = Array.isArray(o.location) ? o.location : [o.location, o.location];
                cxy = {
                  x: locToUse[0] * component.w,
                  y: locToUse[1] * component.h
                };
              } else {
                var loc = o.location,
                    absolute = false;
                if (isString(o.location) || o.location < 0 || o.location > 1) {
                  loc = parseInt("" + o.location, 10);
                  absolute = true;
                }
                cxy = component.pointOnPath(loc, absolute);
              }
              var minx = cxy.x - td.w / 2,
                  miny = cxy.y - td.h / 2;
              return {
                component: o,
                d: {
                  minx: minx,
                  miny: miny,
                  td: td,
                  cxy: cxy
                },
                xmin: minx,
                xmax: minx + td.w,
                ymin: miny,
                ymax: miny + td.h
              };
            } else {
              return {
                xmin: 0,
                xmax: 0,
                ymin: 0,
                ymax: 0
              };
            }
          } else if (isArrowOverlay(o) || isDiamondOverlay(o) || isPlainArrowOverlay(o)) {
            return o.draw(component, paintStyle, absolutePosition);
          } else {
            throw "Could not draw overlay of type [" + o.type + "]";
          }
        }
      }, {
        key: "updateLabel",
        value: function updateLabel(o) {
          if (isFunction(o.label)) {
            var lt = o.label(this);
            if (lt != null) {
              getLabelElement(o).innerText = lt;
            } else {
              getLabelElement(o).innerText = "";
            }
          } else {
            if (o.labelText == null) {
              o.labelText = o.label;
              if (o.labelText != null) {
                getLabelElement(o).innerText = o.labelText;
              } else {
                getLabelElement(o).innerText = "";
              }
            }
          }
        }
      }, {
        key: "setHover",
        value: function setHover(component, hover) {
          component._hover = hover;
          if (component instanceof Endpoint && component.endpoint != null) {
            this.setEndpointHover(component, hover);
          } else if (component instanceof Connection && component.connector != null) {
            this.setConnectorHover(component.connector, hover);
          }
        }
      }, {
        key: "paintConnector",
        value: function paintConnector(connector, paintStyle, extents) {
          paintSvgConnector(this, connector, paintStyle, extents);
        }
      }, {
        key: "setConnectorHover",
        value: function setConnectorHover(connector, hover, doNotCascade) {
          if (hover === false || !this.currentlyDragging && !this.isHoverSuspended()) {
            var canvas = connector.canvas;
            if (canvas != null) {
              if (connector.hoverClass != null) {
                if (hover) {
                  this.addClass(canvas, connector.hoverClass);
                } else {
                  this.removeClass(canvas, connector.hoverClass);
                }
              }
              if (hover) {
                this.addClass(canvas, this.hoverClass);
              } else {
                this.removeClass(canvas, this.hoverClass);
              }
            }
            if (connector.connection.hoverPaintStyle != null) {
              connector.connection.paintStyleInUse = hover ? connector.connection.hoverPaintStyle : connector.connection.paintStyle;
              if (!this._suspendDrawing) {
                this.paintConnection(connector.connection);
              }
            }
            if (!doNotCascade) {
              this.setEndpointHover(connector.connection.endpoints[0], hover, true);
              this.setEndpointHover(connector.connection.endpoints[1], hover, true);
            }
          }
        }
      }, {
        key: "destroyConnector",
        value: function destroyConnector(connection) {
          if (connection.connector != null) {
            cleanup(connection.connector);
          }
        }
      }, {
        key: "addConnectorClass",
        value: function addConnectorClass(connector, clazz) {
          if (connector.canvas) {
            this.addClass(connector.canvas, clazz);
          }
        }
      }, {
        key: "removeConnectorClass",
        value: function removeConnectorClass(connector, clazz) {
          if (connector.canvas) {
            this.removeClass(connector.canvas, clazz);
          }
        }
      }, {
        key: "getConnectorClass",
        value: function getConnectorClass(connector) {
          if (connector.canvas) {
            return connector.canvas.className.baseVal;
          } else {
            return "";
          }
        }
      }, {
        key: "setConnectorVisible",
        value: function setConnectorVisible(connector, v) {
          setVisible(connector, v);
        }
      }, {
        key: "applyConnectorType",
        value: function applyConnectorType(connector, t) {
          if (connector.canvas && t.cssClass) {
            var classes = Array.isArray(t.cssClass) ? t.cssClass : [t.cssClass];
            this.addClass(connector.canvas, classes.join(" "));
          }
        }
      }, {
        key: "addEndpointClass",
        value: function addEndpointClass(ep, c) {
          var canvas = getEndpointCanvas(ep.endpoint);
          if (canvas != null) {
            this.addClass(canvas, c);
          }
        }
      }, {
        key: "applyEndpointType",
        value: function applyEndpointType(ep, t) {
          if (t.cssClass) {
            var canvas = getEndpointCanvas(ep.endpoint);
            if (canvas) {
              var classes = Array.isArray(t.cssClass) ? t.cssClass : [t.cssClass];
              this.addClass(canvas, classes.join(" "));
            }
          }
        }
      }, {
        key: "destroyEndpoint",
        value: function destroyEndpoint(ep) {
          var anchorClass = this.endpointAnchorClassPrefix + (ep.currentAnchorClass ? "-" + ep.currentAnchorClass : "");
          this.removeClass(ep.element, anchorClass);
          cleanup(ep.endpoint);
        }
      }, {
        key: "renderEndpoint",
        value: function renderEndpoint(ep, paintStyle) {
          var renderer = endpointMap[ep.endpoint.type];
          if (renderer != null) {
            SvgEndpoint.paint(ep.endpoint, renderer, paintStyle);
          } else {
            log("jsPlumb: no endpoint renderer found for type [" + ep.endpoint.type + "]");
          }
        }
      }, {
        key: "removeEndpointClass",
        value: function removeEndpointClass(ep, c) {
          var canvas = getEndpointCanvas(ep.endpoint);
          if (canvas != null) {
            this.removeClass(canvas, c);
          }
        }
      }, {
        key: "getEndpointClass",
        value: function getEndpointClass(ep) {
          var canvas = getEndpointCanvas(ep.endpoint);
          if (canvas != null) {
            return canvas.className;
          } else {
            return "";
          }
        }
      }, {
        key: "setEndpointHover",
        value: function setEndpointHover(endpoint, hover, doNotCascade) {
          if (endpoint != null && (hover === false || !this.currentlyDragging && !this.isHoverSuspended())) {
            var canvas = getEndpointCanvas(endpoint.endpoint);
            if (canvas != null) {
              if (endpoint.hoverClass != null) {
                if (hover) {
                  this.addClass(canvas, endpoint.hoverClass);
                } else {
                  this.removeClass(canvas, endpoint.hoverClass);
                }
              }
            }
            if (endpoint.hoverPaintStyle != null) {
              endpoint.paintStyleInUse = hover ? endpoint.hoverPaintStyle : endpoint.paintStyle;
              if (!this._suspendDrawing) {
                this.renderEndpoint(endpoint, endpoint.paintStyleInUse);
              }
            }
            if (!doNotCascade) {
              for (var i = 0; i < endpoint.connections.length; i++) {
                this.setConnectorHover(endpoint.connections[i].connector, hover, true);
              }
            }
          }
        }
      }, {
        key: "setEndpointVisible",
        value: function setEndpointVisible(ep, v) {
          setVisible(ep.endpoint, v);
        }
      }, {
        key: "setGroupVisible",
        value: function setGroupVisible(group, state) {
          var m = group.el.querySelectorAll(SELECTOR_MANAGED_ELEMENT);
          for (var i = 0; i < m.length; i++) {
            if (state) {
              this.show(m[i], true);
            } else {
              this.hide(m[i], true);
            }
          }
        }
      }, {
        key: "deleteConnection",
        value: function deleteConnection(connection, params) {
          if (connection != null && connection.deleted !== true) {
            this.setEndpointHover(connection.endpoints[0], false, true);
            this.setEndpointHover(connection.endpoints[1], false, true);
            return _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), "deleteConnection", this).call(this, connection, params);
          } else {
            return false;
          }
        }
      }, {
        key: "addSourceSelector",
        value: function addSourceSelector(selector, params, exclude) {
          this.addDragFilter(selector);
          return _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), "addSourceSelector", this).call(this, selector, params, exclude);
        }
      }, {
        key: "removeSourceSelector",
        value: function removeSourceSelector(selector) {
          this.removeDragFilter(selector.selector);
          _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), "removeSourceSelector", this).call(this, selector);
        }
      }]);
      return BrowserJsPlumbInstance;
    }(JsPlumbInstance);

    var CIRCLE = "circle";
    var register$2 = function register() {
      registerEndpointRenderer(DotEndpoint.type, {
        makeNode: function makeNode(ep, style) {
          return _node(CIRCLE, {
            "cx": ep.w / 2,
            "cy": ep.h / 2,
            "r": ep.radius
          });
        },
        updateNode: function updateNode(ep, node) {
          _attr(node, {
            "cx": "" + ep.w / 2,
            "cy": "" + ep.h / 2,
            "r": "" + ep.radius
          });
        }
      });
    };

    var RECT = "rect";
    var register$1 = function register() {
      registerEndpointRenderer(RectangleEndpoint.type, {
        makeNode: function makeNode(ep, style) {
          return _node(RECT, {
            "width": ep.w,
            "height": ep.h
          });
        },
        updateNode: function updateNode(ep, node) {
          _attr(node, {
            "width": ep.w,
            "height": ep.h
          });
        }
      });
    };

    var BLANK_ATTRIBUTES = {
      "width": 10,
      "height": 0,
      "fill": "transparent",
      "stroke": "transparent"
    };
    var register = function register() {
      registerEndpointRenderer(BlankEndpoint.type, {
        makeNode: function makeNode(ep, style) {
          return _node("rect", BLANK_ATTRIBUTES);
        },
        updateNode: function updateNode(ep, node) {
          _attr(node, BLANK_ATTRIBUTES);
        }
      });
    };

    register$2();
    register();
    register$1();
    var _jsPlumbInstanceIndex = 0;
    function getInstanceIndex() {
      var i = _jsPlumbInstanceIndex + 1;
      _jsPlumbInstanceIndex++;
      return i;
    }
    function newInstance(defaults) {
      return new BrowserJsPlumbInstance(getInstanceIndex(), defaults);
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    let urlAlphabet =
      'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
    let customAlphabet = (alphabet, size) => {
      return () => {
        let id = '';
        let i = size;
        while (i--) {
          id += alphabet[(Math.random() * alphabet.length) | 0];
        }
        return id
      }
    };
    let nanoid = (size = 21) => {
      let id = '';
      let i = size;
      while (i--) {
        id += urlAlphabet[(Math.random() * 64) | 0];
      }
      return id
    };

    function safeid(n = 10) {
        return customAlphabet("abcdefghijklmnopqrztuvwxyz", n)();
    }

    let refreshStore = writable();
    let canvasStore = writable();
    let canvas;
    canvasStore.subscribe((value) => {
        canvas = value;
    });
    function createEmptyFlow() {
        const id = safeid();
        return {
            id,
            name: `flow ${id}`,
            zoom: 1.0,
            pan: { x: 0.0, y: 0.0 },
            nodes: [],
            edges: [],
        };
    }
    let currentFlowStore = writable(createEmptyFlow());
    let jsPlumbInstanceStore = writable();
    function createJsPlumbInstance() {
        const spacing = Number.parseInt(getComputedStyle(document.documentElement).getPropertyValue("--spacing"));
        const jsPlumbInstance = newInstance({
            container: canvas,
            dragOptions: {
                grid: { w: spacing, h: spacing },
                cursor: "grabbing",
            },
        });
        jsPlumbInstanceStore.set(jsPlumbInstance);
    }

    /* src/LogoIcon.svelte generated by Svelte v3.44.2 */

    const file$l = "src/LogoIcon.svelte";

    function create_fragment$n(ctx) {
    	let svg;
    	let defs;
    	let g1;
    	let g0;
    	let path0;
    	let path1;
    	let path2;
    	let path3;
    	let path4;
    	let path5;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			defs = svg_element("defs");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			attr_dev(defs, "id", "defs2");
    			add_location(defs, file$l, 9, 2, 178);
    			attr_dev(path0, "id", "rect846");
    			set_style(path0, "stroke-width", "0.158123");
    			set_style(path0, "stroke-linecap", "round");
    			set_style(path0, "stroke-linejoin", "round");
    			attr_dev(path0, "d", "M 0.89122808,0 H 8.0210527 V 12.477193 H 0.89122808 Z");
    			attr_dev(path0, "class", "svelte-1ye3jbg");
    			add_location(path0, file$l, 12, 6, 241);
    			attr_dev(path1, "id", "path1181");
    			set_style(path1, "stroke-width", "0.168547");
    			set_style(path1, "stroke-linecap", "round");
    			set_style(path1, "stroke-linejoin", "round");
    			attr_dev(path1, "d", "M 8.0210533,12.477185 A 3.5649123,3.5649123 0 0 1 4.456141,16.042098 3.5649123,3.5649123 0 0 1 0.89122868,12.477185 3.5649123,3.5649123 0 0 1 4.456141,8.9122729 3.5649123,3.5649123 0 0 1 8.0210533,12.477185 Z");
    			attr_dev(path1, "class", "svelte-1ye3jbg");
    			add_location(path1, file$l, 17, 6, 430);
    			attr_dev(path2, "id", "rect1285");
    			set_style(path2, "stroke-width", "0.243801");
    			set_style(path2, "stroke-linecap", "round");
    			set_style(path2, "stroke-linejoin", "round");
    			attr_dev(path2, "d", "M 0,0 H 8.912281 V 3.5649123 H 0 Z");
    			attr_dev(path2, "class", "svelte-1ye3jbg");
    			add_location(path2, file$l, 22, 6, 775);
    			attr_dev(path3, "id", "rect846-5");
    			set_style(path3, "stroke-width", "0.158123");
    			set_style(path3, "stroke-linecap", "round");
    			set_style(path3, "stroke-linejoin", "round");
    			attr_dev(path3, "transform", "rotate(90)");
    			attr_dev(path3, "d", "m 8.912281,-16.933332 h 7.129825 V -4.4561396 H 8.912281 Z");
    			attr_dev(path3, "class", "svelte-1ye3jbg");
    			add_location(path3, file$l, 27, 6, 946);
    			attr_dev(path4, "id", "rect1285-3");
    			set_style(path4, "stroke-width", "0.243803");
    			set_style(path4, "stroke-linecap", "round");
    			set_style(path4, "stroke-linejoin", "round");
    			attr_dev(path4, "transform", "rotate(90)");
    			attr_dev(path4, "d", "m 8.0210524,-16.933332 h 8.9122806 v 3.564912 H 8.0210524 Z");
    			attr_dev(path4, "class", "svelte-1ye3jbg");
    			add_location(path4, file$l, 33, 6, 1173);
    			set_style(path5, "stroke", "none");
    			set_style(path5, "stroke-width", "0.0385321");
    			set_style(path5, "stroke-linecap", "round");
    			set_style(path5, "stroke-linejoin", "round");
    			attr_dev(path5, "d", "m 7.8439928,8.1026127 c 6.35e-4,-0.5433494 0.00254,-0.9810506 0.0042,-0.9726699 0.00164,0.00838 0.00845,0.049523 0.015095,0.091426 0.070288,0.4429789 0.2997277,0.8862957 0.6280385,1.2134794 0.3502832,0.3490804 0.7900408,0.5665616 1.2955127,0.640692 0.073419,0.010766 -0.071256,0.012927 -0.9285292,0.013867 l -1.0154987,0.00111 z");
    			attr_dev(path5, "id", "path2336");
    			attr_dev(path5, "class", "svelte-1ye3jbg");
    			add_location(path5, file$l, 39, 6, 1402);
    			attr_dev(g0, "id", "g2812");
    			add_location(g0, file$l, 11, 4, 220);
    			attr_dev(g1, "id", "layer1");
    			add_location(g1, file$l, 10, 2, 200);
    			attr_dev(svg, "width", "64");
    			attr_dev(svg, "height", "64");
    			attr_dev(svg, "viewBox", "0 0 16.933333 16.933334");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "id", "svg5");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:svg", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "class", "svelte-1ye3jbg");
    			add_location(svg, file$l, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, defs);
    			append_dev(svg, g1);
    			append_dev(g1, g0);
    			append_dev(g0, path0);
    			append_dev(g0, path1);
    			append_dev(g0, path2);
    			append_dev(g0, path3);
    			append_dev(g0, path4);
    			append_dev(g0, path5);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LogoIcon', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LogoIcon> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class LogoIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LogoIcon",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    /* src/appbar/Appbar.svelte generated by Svelte v3.44.2 */
    const file$k = "src/appbar/Appbar.svelte";

    // (11:2) {#if $currentFlowStore.name !== undefined}
    function create_if_block$6(ctx) {
    	let p;
    	let t_value = /*$currentFlowStore*/ ctx[1].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			attr_dev(p, "class", "svelte-1mb0jki");
    			add_location(p, file$k, 11, 4, 306);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$currentFlowStore*/ 2 && t_value !== (t_value = /*$currentFlowStore*/ ctx[1].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(11:2) {#if $currentFlowStore.name !== undefined}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div1;
    	let div0;
    	let logoicon;
    	let t0;
    	let h1;
    	let t1;
    	let t2;
    	let current;
    	logoicon = new LogoIcon({ $$inline: true });
    	let if_block = /*$currentFlowStore*/ ctx[1].name !== undefined && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(logoicon.$$.fragment);
    			t0 = space();
    			h1 = element("h1");
    			t1 = text(/*title*/ ctx[0]);
    			t2 = space();
    			if (if_block) if_block.c();
    			attr_dev(h1, "class", "svelte-1mb0jki");
    			add_location(h1, file$k, 8, 4, 231);
    			attr_dev(div0, "class", "logo svelte-1mb0jki");
    			add_location(div0, file$k, 6, 2, 191);
    			attr_dev(div1, "class", "appbar svelte-1mb0jki");
    			add_location(div1, file$k, 5, 0, 168);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(logoicon, div0, null);
    			append_dev(div0, t0);
    			append_dev(div0, h1);
    			append_dev(h1, t1);
    			append_dev(div1, t2);
    			if (if_block) if_block.m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 1) set_data_dev(t1, /*title*/ ctx[0]);

    			if (/*$currentFlowStore*/ ctx[1].name !== undefined) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logoicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logoicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(logoicon);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $currentFlowStore;
    	validate_store(currentFlowStore, 'currentFlowStore');
    	component_subscribe($$self, currentFlowStore, $$value => $$invalidate(1, $currentFlowStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Appbar', slots, []);
    	let { title = "PELT Studio" } = $$props;
    	const writable_props = ['title'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Appbar> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    	};

    	$$self.$capture_state = () => ({
    		currentFlowStore,
    		LogoIcon,
    		title,
    		$currentFlowStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, $currentFlowStore];
    }

    class Appbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, { title: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Appbar",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get title() {
    		throw new Error("<Appbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Appbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function isITableDefinition(arg) {
        return arg.name !== undefined;
    }
    function isITransformDefinition(arg) {
        return arg.transform !== undefined;
    }

    /* src/flowCanvas/components/Draggable.svelte generated by Svelte v3.44.2 */
    const file$j = "src/flowCanvas/components/Draggable.svelte";
    const get_footer_slot_changes$1 = dirty => ({});
    const get_footer_slot_context$1 = ctx => ({});
    const get_content_slot_changes = dirty => ({});
    const get_content_slot_context = ctx => ({});
    const get_header_slot_changes = dirty => ({});
    const get_header_slot_context = ctx => ({});

    // (29:2) {#if title !== undefined}
    function create_if_block_4$1(ctx) {
    	let header;
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[11].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[10], get_header_slot_context);

    	const block = {
    		c: function create() {
    			header = element("header");
    			t0 = text(/*title*/ ctx[2]);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(header, "class", "svelte-1mzoamu");
    			add_location(header, file$j, 29, 4, 973);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header, anchor);
    			append_dev(header, t0);
    			append_dev(header, t1);

    			if (header_slot) {
    				header_slot.m(header, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*title*/ 4) set_data_dev(t0, /*title*/ ctx[2]);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[10], dirty, get_header_slot_changes),
    						get_header_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(29:2) {#if title !== undefined}",
    		ctx
    	});

    	return block;
    }

    // (37:4) {#if content !== undefined}
    function create_if_block_3$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*content*/ ctx[3]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content*/ 8) set_data_dev(t, /*content*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(37:4) {#if content !== undefined}",
    		ctx
    	});

    	return block;
    }

    // (40:4) {#if form !== undefined}
    function create_if_block_2$1(ctx) {
    	let switch_instance;
    	let updating_formContext;
    	let switch_instance_anchor;
    	let current;

    	function switch_instance_formContext_binding(value) {
    		/*switch_instance_formContext_binding*/ ctx[12](value);
    	}

    	var switch_value = /*form*/ ctx[5];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		if (/*formContext*/ ctx[0] !== void 0) {
    			switch_instance_props.formContext = /*formContext*/ ctx[0];
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind(switch_instance, 'formContext', switch_instance_formContext_binding));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};

    			if (!updating_formContext && dirty & /*formContext*/ 1) {
    				updating_formContext = true;
    				switch_instance_changes.formContext = /*formContext*/ ctx[0];
    				add_flush_callback(() => updating_formContext = false);
    			}

    			if (switch_value !== (switch_value = /*form*/ ctx[5])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind(switch_instance, 'formContext', switch_instance_formContext_binding));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(40:4) {#if form !== undefined}",
    		ctx
    	});

    	return block;
    }

    // (44:2) {#if footer !== undefined || $$slots.footer}
    function create_if_block$5(ctx) {
    	let footer_1;
    	let t;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[11].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[10], get_footer_slot_context$1);
    	let if_block = /*footer*/ ctx[4] !== undefined && create_if_block_1$2(ctx);

    	const block = {
    		c: function create() {
    			footer_1 = element("footer");
    			if (footer_slot) footer_slot.c();
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(footer_1, "class", "svelte-1mzoamu");
    			add_location(footer_1, file$j, 44, 4, 1304);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, footer_1, anchor);

    			if (footer_slot) {
    				footer_slot.m(footer_1, null);
    			}

    			append_dev(footer_1, t);
    			if (if_block) if_block.m(footer_1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[10], dirty, get_footer_slot_changes$1),
    						get_footer_slot_context$1
    					);
    				}
    			}

    			if (/*footer*/ ctx[4] !== undefined) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$2(ctx);
    					if_block.c();
    					if_block.m(footer_1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(footer_1);
    			if (footer_slot) footer_slot.d(detaching);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(44:2) {#if footer !== undefined || $$slots.footer}",
    		ctx
    	});

    	return block;
    }

    // (47:6) {#if footer !== undefined}
    function create_if_block_1$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*footer*/ ctx[4]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*footer*/ 16) set_data_dev(t, /*footer*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(47:6) {#if footer !== undefined}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let div;
    	let t0;
    	let section;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block0 = /*title*/ ctx[2] !== undefined && create_if_block_4$1(ctx);
    	const content_slot_template = /*#slots*/ ctx[11].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[10], get_content_slot_context);
    	let if_block1 = /*content*/ ctx[3] !== undefined && create_if_block_3$1(ctx);
    	let if_block2 = /*form*/ ctx[5] !== undefined && create_if_block_2$1(ctx);
    	let if_block3 = (/*footer*/ ctx[4] !== undefined || /*$$slots*/ ctx[7].footer) && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			section = element("section");
    			if (content_slot) content_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			attr_dev(section, "class", "svelte-1mzoamu");
    			add_location(section, file$j, 34, 2, 1049);
    			attr_dev(div, "id", /*id*/ ctx[1]);
    			attr_dev(div, "class", "draggableWrapper svelte-1mzoamu");
    			add_location(div, file$j, 27, 0, 885);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, section);

    			if (content_slot) {
    				content_slot.m(section, null);
    			}

    			append_dev(section, t1);
    			if (if_block1) if_block1.m(section, null);
    			append_dev(section, t2);
    			if (if_block2) if_block2.m(section, null);
    			append_dev(div, t3);
    			if (if_block3) if_block3.m(div, null);
    			/*div_binding*/ ctx[13](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*title*/ ctx[2] !== undefined) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*title*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[10], dirty, get_content_slot_changes),
    						get_content_slot_context
    					);
    				}
    			}

    			if (/*content*/ ctx[3] !== undefined) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$1(ctx);
    					if_block1.c();
    					if_block1.m(section, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*form*/ ctx[5] !== undefined) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*form*/ 32) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(section, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*footer*/ ctx[4] !== undefined || /*$$slots*/ ctx[7].footer) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*footer, $$slots*/ 144) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block$5(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*id*/ 2) {
    				attr_dev(div, "id", /*id*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(content_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(content_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (content_slot) content_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			/*div_binding*/ ctx[13](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let $jsPlumbInstanceStore;
    	validate_store(jsPlumbInstanceStore, 'jsPlumbInstanceStore');
    	component_subscribe($$self, jsPlumbInstanceStore, $$value => $$invalidate(14, $jsPlumbInstanceStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Draggable', slots, ['header','content','footer']);
    	const $$slots = compute_slots(slots);
    	let { id } = $$props;
    	let { top } = $$props;
    	let { left } = $$props;
    	let { title = undefined } = $$props;
    	let { content = undefined } = $$props;
    	let { footer = undefined } = $$props;
    	let { form = undefined } = $$props;
    	let { formContext = undefined } = $$props;
    	let element;

    	onMount(() => {
    		$jsPlumbInstanceStore.manage(element);
    		$jsPlumbInstanceStore.setDraggable(element, true);
    		$jsPlumbInstanceStore.bind(EVENT_DRAG_MOVE, updateCoords);
    		element.style.setProperty("top", `${top || 0}px`);
    		element.style.setProperty("left", `${left || 0}px`);
    	});

    	function updateCoords(event) {
    		if (element !== undefined) {
    			$$invalidate(9, left = parseInt(element.style.getPropertyValue("left")));
    			$$invalidate(8, top = parseInt(element.style.getPropertyValue("top")));
    		}
    	}

    	const writable_props = ['id', 'top', 'left', 'title', 'content', 'footer', 'form', 'formContext'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Draggable> was created with unknown prop '${key}'`);
    	});

    	function switch_instance_formContext_binding(value) {
    		formContext = value;
    		$$invalidate(0, formContext);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(6, element);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    		if ('top' in $$props) $$invalidate(8, top = $$props.top);
    		if ('left' in $$props) $$invalidate(9, left = $$props.left);
    		if ('title' in $$props) $$invalidate(2, title = $$props.title);
    		if ('content' in $$props) $$invalidate(3, content = $$props.content);
    		if ('footer' in $$props) $$invalidate(4, footer = $$props.footer);
    		if ('form' in $$props) $$invalidate(5, form = $$props.form);
    		if ('formContext' in $$props) $$invalidate(0, formContext = $$props.formContext);
    		if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		EVENT_DRAG_MOVE,
    		jsPlumbInstanceStore,
    		id,
    		top,
    		left,
    		title,
    		content,
    		footer,
    		form,
    		formContext,
    		element,
    		updateCoords,
    		$jsPlumbInstanceStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    		if ('top' in $$props) $$invalidate(8, top = $$props.top);
    		if ('left' in $$props) $$invalidate(9, left = $$props.left);
    		if ('title' in $$props) $$invalidate(2, title = $$props.title);
    		if ('content' in $$props) $$invalidate(3, content = $$props.content);
    		if ('footer' in $$props) $$invalidate(4, footer = $$props.footer);
    		if ('form' in $$props) $$invalidate(5, form = $$props.form);
    		if ('formContext' in $$props) $$invalidate(0, formContext = $$props.formContext);
    		if ('element' in $$props) $$invalidate(6, element = $$props.element);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		formContext,
    		id,
    		title,
    		content,
    		footer,
    		form,
    		element,
    		$$slots,
    		top,
    		left,
    		$$scope,
    		slots,
    		switch_instance_formContext_binding,
    		div_binding
    	];
    }

    class Draggable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
    			id: 1,
    			top: 8,
    			left: 9,
    			title: 2,
    			content: 3,
    			footer: 4,
    			form: 5,
    			formContext: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Draggable",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[1] === undefined && !('id' in props)) {
    			console.warn("<Draggable> was created without expected prop 'id'");
    		}

    		if (/*top*/ ctx[8] === undefined && !('top' in props)) {
    			console.warn("<Draggable> was created without expected prop 'top'");
    		}

    		if (/*left*/ ctx[9] === undefined && !('left' in props)) {
    			console.warn("<Draggable> was created without expected prop 'left'");
    		}
    	}

    	get id() {
    		throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get top() {
    		throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set top(value) {
    		throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get left() {
    		throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set left(value) {
    		throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content() {
    		throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content(value) {
    		throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get footer() {
    		throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set footer(value) {
    		throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get form() {
    		throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set form(value) {
    		throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get formContext() {
    		throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set formContext(value) {
    		throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/flowCanvas/Node.svelte generated by Svelte v3.44.2 */
    const get_footer_slot_changes = dirty => ({});
    const get_footer_slot_context = ctx => ({ slot: "footer" });

    // (22:2) 
    function create_footer_slot$1(ctx) {
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[8].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[12], get_footer_slot_context);

    	const block = {
    		c: function create() {
    			if (footer_slot) footer_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (footer_slot) {
    				footer_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[12],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[12], dirty, get_footer_slot_changes),
    						get_footer_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footer_slot$1.name,
    		type: "slot",
    		source: "(22:2) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let draggable;
    	let updating_top;
    	let updating_left;
    	let updating_formContext;
    	let current;

    	function draggable_top_binding(value) {
    		/*draggable_top_binding*/ ctx[9](value);
    	}

    	function draggable_left_binding(value) {
    		/*draggable_left_binding*/ ctx[10](value);
    	}

    	function draggable_formContext_binding(value) {
    		/*draggable_formContext_binding*/ ctx[11](value);
    	}

    	let draggable_props = {
    		id: /*id*/ ctx[3],
    		title: /*title*/ ctx[4],
    		content: /*content*/ ctx[5],
    		footer: /*footer*/ ctx[6],
    		form: /*form*/ ctx[7],
    		$$slots: { footer: [create_footer_slot$1] },
    		$$scope: { ctx }
    	};

    	if (/*top*/ ctx[0] !== void 0) {
    		draggable_props.top = /*top*/ ctx[0];
    	}

    	if (/*left*/ ctx[1] !== void 0) {
    		draggable_props.left = /*left*/ ctx[1];
    	}

    	if (/*formContext*/ ctx[2] !== void 0) {
    		draggable_props.formContext = /*formContext*/ ctx[2];
    	}

    	draggable = new Draggable({ props: draggable_props, $$inline: true });
    	binding_callbacks.push(() => bind(draggable, 'top', draggable_top_binding));
    	binding_callbacks.push(() => bind(draggable, 'left', draggable_left_binding));
    	binding_callbacks.push(() => bind(draggable, 'formContext', draggable_formContext_binding));

    	const block = {
    		c: function create() {
    			create_component(draggable.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(draggable, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const draggable_changes = {};
    			if (dirty & /*id*/ 8) draggable_changes.id = /*id*/ ctx[3];
    			if (dirty & /*title*/ 16) draggable_changes.title = /*title*/ ctx[4];
    			if (dirty & /*content*/ 32) draggable_changes.content = /*content*/ ctx[5];
    			if (dirty & /*footer*/ 64) draggable_changes.footer = /*footer*/ ctx[6];
    			if (dirty & /*form*/ 128) draggable_changes.form = /*form*/ ctx[7];

    			if (dirty & /*$$scope*/ 4096) {
    				draggable_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_top && dirty & /*top*/ 1) {
    				updating_top = true;
    				draggable_changes.top = /*top*/ ctx[0];
    				add_flush_callback(() => updating_top = false);
    			}

    			if (!updating_left && dirty & /*left*/ 2) {
    				updating_left = true;
    				draggable_changes.left = /*left*/ ctx[1];
    				add_flush_callback(() => updating_left = false);
    			}

    			if (!updating_formContext && dirty & /*formContext*/ 4) {
    				updating_formContext = true;
    				draggable_changes.formContext = /*formContext*/ ctx[2];
    				add_flush_callback(() => updating_formContext = false);
    			}

    			draggable.$set(draggable_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(draggable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(draggable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(draggable, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Node', slots, ['footer']);
    	let { id } = $$props;
    	let { top } = $$props;
    	let { left } = $$props;
    	let { title = undefined } = $$props;
    	let { content = undefined } = $$props;
    	let { footer = undefined } = $$props;
    	let { form = undefined } = $$props;
    	let { formContext = undefined } = $$props;
    	const writable_props = ['id', 'top', 'left', 'title', 'content', 'footer', 'form', 'formContext'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Node> was created with unknown prop '${key}'`);
    	});

    	function draggable_top_binding(value) {
    		top = value;
    		$$invalidate(0, top);
    	}

    	function draggable_left_binding(value) {
    		left = value;
    		$$invalidate(1, left);
    	}

    	function draggable_formContext_binding(value) {
    		formContext = value;
    		$$invalidate(2, formContext);
    	}

    	$$self.$$set = $$props => {
    		if ('id' in $$props) $$invalidate(3, id = $$props.id);
    		if ('top' in $$props) $$invalidate(0, top = $$props.top);
    		if ('left' in $$props) $$invalidate(1, left = $$props.left);
    		if ('title' in $$props) $$invalidate(4, title = $$props.title);
    		if ('content' in $$props) $$invalidate(5, content = $$props.content);
    		if ('footer' in $$props) $$invalidate(6, footer = $$props.footer);
    		if ('form' in $$props) $$invalidate(7, form = $$props.form);
    		if ('formContext' in $$props) $$invalidate(2, formContext = $$props.formContext);
    		if ('$$scope' in $$props) $$invalidate(12, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Draggable,
    		id,
    		top,
    		left,
    		title,
    		content,
    		footer,
    		form,
    		formContext
    	});

    	$$self.$inject_state = $$props => {
    		if ('id' in $$props) $$invalidate(3, id = $$props.id);
    		if ('top' in $$props) $$invalidate(0, top = $$props.top);
    		if ('left' in $$props) $$invalidate(1, left = $$props.left);
    		if ('title' in $$props) $$invalidate(4, title = $$props.title);
    		if ('content' in $$props) $$invalidate(5, content = $$props.content);
    		if ('footer' in $$props) $$invalidate(6, footer = $$props.footer);
    		if ('form' in $$props) $$invalidate(7, form = $$props.form);
    		if ('formContext' in $$props) $$invalidate(2, formContext = $$props.formContext);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		top,
    		left,
    		formContext,
    		id,
    		title,
    		content,
    		footer,
    		form,
    		slots,
    		draggable_top_binding,
    		draggable_left_binding,
    		draggable_formContext_binding,
    		$$scope
    	];
    }

    class Node extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
    			id: 3,
    			top: 0,
    			left: 1,
    			title: 4,
    			content: 5,
    			footer: 6,
    			form: 7,
    			formContext: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Node",
    			options,
    			id: create_fragment$k.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[3] === undefined && !('id' in props)) {
    			console.warn("<Node> was created without expected prop 'id'");
    		}

    		if (/*top*/ ctx[0] === undefined && !('top' in props)) {
    			console.warn("<Node> was created without expected prop 'top'");
    		}

    		if (/*left*/ ctx[1] === undefined && !('left' in props)) {
    			console.warn("<Node> was created without expected prop 'left'");
    		}
    	}

    	get id() {
    		throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get top() {
    		throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set top(value) {
    		throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get left() {
    		throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set left(value) {
    		throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content() {
    		throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content(value) {
    		throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get footer() {
    		throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set footer(value) {
    		throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get form() {
    		throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set form(value) {
    		throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get formContext() {
    		throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set formContext(value) {
    		throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/flowCanvas/controls/InputControl.svelte generated by Svelte v3.44.2 */
    const file$i = "src/flowCanvas/controls/InputControl.svelte";

    // (37:62) 
    function create_if_block_4(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "id", /*controlId*/ ctx[8]);
    			attr_dev(input, "name", /*name*/ ctx[1]);
    			attr_dev(input, "type", "checkbox");
    			input.disabled = /*disabled*/ ctx[4];
    			attr_dev(input, "pattern", /*pattern*/ ctx[5]);
    			attr_dev(input, "class", "svelte-1g8x4py");
    			add_location(input, file$i, 37, 4, 1109);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = /*value*/ ctx[0];

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[13]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*name*/ 2) {
    				attr_dev(input, "name", /*name*/ ctx[1]);
    			}

    			if (dirty & /*disabled*/ 16) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[4]);
    			}

    			if (dirty & /*pattern*/ 32) {
    				attr_dev(input, "pattern", /*pattern*/ ctx[5]);
    			}

    			if (dirty & /*value*/ 1) {
    				input.checked = /*value*/ ctx[0];
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(37:62) ",
    		ctx
    	});

    	return block;
    }

    // (28:59) 
    function create_if_block_3(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "id", /*controlId*/ ctx[8]);
    			attr_dev(input, "name", /*name*/ ctx[1]);
    			attr_dev(input, "type", "number");
    			input.disabled = /*disabled*/ ctx[4];
    			attr_dev(input, "pattern", /*pattern*/ ctx[5]);
    			attr_dev(input, "class", "svelte-1g8x4py");
    			add_location(input, file$i, 28, 4, 924);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler_3*/ ctx[12]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*name*/ 2) {
    				attr_dev(input, "name", /*name*/ ctx[1]);
    			}

    			if (dirty & /*disabled*/ 16) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[4]);
    			}

    			if (dirty & /*pattern*/ 32) {
    				attr_dev(input, "pattern", /*pattern*/ ctx[5]);
    			}

    			if (dirty & /*value*/ 1 && to_number(input.value) !== /*value*/ ctx[0]) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(28:59) ",
    		ctx
    	});

    	return block;
    }

    // (26:58) 
    function create_if_block_2(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "id", /*controlId*/ ctx[8]);
    			attr_dev(input, "name", /*name*/ ctx[1]);
    			attr_dev(input, "type", "email");
    			input.disabled = /*disabled*/ ctx[4];
    			attr_dev(input, "pattern", /*pattern*/ ctx[5]);
    			attr_dev(input, "class", "svelte-1g8x4py");
    			add_location(input, file$i, 26, 4, 783);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler_2*/ ctx[11]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*name*/ 2) {
    				attr_dev(input, "name", /*name*/ ctx[1]);
    			}

    			if (dirty & /*disabled*/ 16) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[4]);
    			}

    			if (dirty & /*pattern*/ 32) {
    				attr_dev(input, "pattern", /*pattern*/ ctx[5]);
    			}

    			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(26:58) ",
    		ctx
    	});

    	return block;
    }

    // (17:61) 
    function create_if_block_1$1(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "id", /*controlId*/ ctx[8]);
    			attr_dev(input, "name", /*name*/ ctx[1]);
    			attr_dev(input, "type", "password");
    			input.disabled = /*disabled*/ ctx[4];
    			attr_dev(input, "pattern", /*pattern*/ ctx[5]);
    			attr_dev(input, "class", "svelte-1g8x4py");
    			add_location(input, file$i, 17, 4, 600);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler_1*/ ctx[10]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*name*/ 2) {
    				attr_dev(input, "name", /*name*/ ctx[1]);
    			}

    			if (dirty & /*disabled*/ 16) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[4]);
    			}

    			if (dirty & /*pattern*/ 32) {
    				attr_dev(input, "pattern", /*pattern*/ ctx[5]);
    			}

    			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(17:61) ",
    		ctx
    	});

    	return block;
    }

    // (15:2) {#if type === "text" && typeof value === "string"}
    function create_if_block$4(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "id", /*controlId*/ ctx[8]);
    			attr_dev(input, "name", /*name*/ ctx[1]);
    			attr_dev(input, "type", "text");
    			input.disabled = /*disabled*/ ctx[4];
    			attr_dev(input, "pattern", /*pattern*/ ctx[5]);
    			attr_dev(input, "class", "svelte-1g8x4py");
    			add_location(input, file$i, 15, 4, 458);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[9]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*name*/ 2) {
    				attr_dev(input, "name", /*name*/ ctx[1]);
    			}

    			if (dirty & /*disabled*/ 16) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[4]);
    			}

    			if (dirty & /*pattern*/ 32) {
    				attr_dev(input, "pattern", /*pattern*/ ctx[5]);
    			}

    			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(15:2) {#if type === \\\"text\\\" && typeof value === \\\"string\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let div;
    	let label_1;
    	let t0;
    	let t1;

    	function select_block_type(ctx, dirty) {
    		if (/*type*/ ctx[2] === "text" && typeof /*value*/ ctx[0] === "string") return create_if_block$4;
    		if (/*type*/ ctx[2] === "password" && typeof /*value*/ ctx[0] === "string") return create_if_block_1$1;
    		if (/*type*/ ctx[2] === "email" && typeof /*value*/ ctx[0] === "string") return create_if_block_2;
    		if (/*type*/ ctx[2] === "number" && typeof /*value*/ ctx[0] === "number") return create_if_block_3;
    		if (/*type*/ ctx[2] === "checkbox" && typeof /*value*/ ctx[0] === "boolean") return create_if_block_4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			label_1 = element("label");
    			t0 = text(/*label*/ ctx[3]);
    			t1 = space();
    			if (if_block) if_block.c();
    			attr_dev(label_1, "id", /*labelId*/ ctx[7]);
    			attr_dev(label_1, "for", /*controlId*/ ctx[8]);
    			attr_dev(label_1, "class", "svelte-1g8x4py");
    			add_location(label_1, file$i, 13, 2, 349);
    			attr_dev(div, "id", /*groupId*/ ctx[6]);
    			attr_dev(div, "class", "svelte-1g8x4py");
    			add_location(div, file$i, 12, 0, 328);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label_1);
    			append_dev(label_1, t0);
    			append_dev(div, t1);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*label*/ 8) set_data_dev(t0, /*label*/ ctx[3]);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (if_block) {
    				if_block.d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('InputControl', slots, []);
    	let { name = safeid() } = $$props;
    	let { type = "text" } = $$props;
    	let { label = name } = $$props;
    	let { disabled = false } = $$props;
    	let { value } = $$props;
    	let { pattern = undefined } = $$props;
    	const groupId = `group_${name}`;
    	const labelId = `label_${name}`;
    	const controlId = `control_${name}`;
    	const writable_props = ['name', 'type', 'label', 'disabled', 'value', 'pattern'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InputControl> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	function input_input_handler_1() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	function input_input_handler_2() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	function input_input_handler_3() {
    		value = to_number(this.value);
    		$$invalidate(0, value);
    	}

    	function input_change_handler() {
    		value = this.checked;
    		$$invalidate(0, value);
    	}

    	$$self.$$set = $$props => {
    		if ('name' in $$props) $$invalidate(1, name = $$props.name);
    		if ('type' in $$props) $$invalidate(2, type = $$props.type);
    		if ('label' in $$props) $$invalidate(3, label = $$props.label);
    		if ('disabled' in $$props) $$invalidate(4, disabled = $$props.disabled);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('pattern' in $$props) $$invalidate(5, pattern = $$props.pattern);
    	};

    	$$self.$capture_state = () => ({
    		safeid,
    		name,
    		type,
    		label,
    		disabled,
    		value,
    		pattern,
    		groupId,
    		labelId,
    		controlId
    	});

    	$$self.$inject_state = $$props => {
    		if ('name' in $$props) $$invalidate(1, name = $$props.name);
    		if ('type' in $$props) $$invalidate(2, type = $$props.type);
    		if ('label' in $$props) $$invalidate(3, label = $$props.label);
    		if ('disabled' in $$props) $$invalidate(4, disabled = $$props.disabled);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('pattern' in $$props) $$invalidate(5, pattern = $$props.pattern);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		value,
    		name,
    		type,
    		label,
    		disabled,
    		pattern,
    		groupId,
    		labelId,
    		controlId,
    		input_input_handler,
    		input_input_handler_1,
    		input_input_handler_2,
    		input_input_handler_3,
    		input_change_handler
    	];
    }

    class InputControl extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
    			name: 1,
    			type: 2,
    			label: 3,
    			disabled: 4,
    			value: 0,
    			pattern: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InputControl",
    			options,
    			id: create_fragment$j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[0] === undefined && !('value' in props)) {
    			console.warn("<InputControl> was created without expected prop 'value'");
    		}
    	}

    	get name() {
    		throw new Error("<InputControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<InputControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<InputControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<InputControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<InputControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<InputControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<InputControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<InputControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<InputControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<InputControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pattern() {
    		throw new Error("<InputControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pattern(value) {
    		throw new Error("<InputControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/flowCanvas/components/Connectable.svelte generated by Svelte v3.44.2 */

    const { console: console_1$2 } = globals;
    const file$h = "src/flowCanvas/components/Connectable.svelte";

    function create_fragment$i(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "id", /*id*/ ctx[0]);
    			add_location(div, file$h, 33, 0, 915);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[6](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*id*/ 1) {
    				attr_dev(div, "id", /*id*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[6](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $jsPlumbInstanceStore;
    	validate_store(jsPlumbInstanceStore, 'jsPlumbInstanceStore');
    	component_subscribe($$self, jsPlumbInstanceStore, $$value => $$invalidate(7, $jsPlumbInstanceStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Connectable', slots, ['default']);
    	let { isSource = true } = $$props;
    	let { isTarget = true } = $$props;
    	let { id } = $$props;
    	let element;

    	onMount(() => {
    		if (isSource) {
    			$jsPlumbInstanceStore.addEndpoint(element, {
    				endpoint: "Dot",
    				anchor: "Right",
    				maxConnections: -1,
    				source: true,
    				target: false,
    				cssClass: "endpointRound",
    				hoverClass: "endpointRoundHover"
    			});
    		}

    		if (isTarget) {
    			$jsPlumbInstanceStore.addEndpoint(element, {
    				endpoint: "Rectangle",
    				anchor: "Left",
    				maxConnections: -1,
    				source: false,
    				target: true,
    				cssClass: "endpointSquare",
    				hoverClass: "endpointSquareHover"
    			});
    		}

    		console.debug("created endpoints for", id);
    	});

    	const writable_props = ['isSource', 'isTarget', 'id'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<Connectable> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(1, element);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('isSource' in $$props) $$invalidate(2, isSource = $$props.isSource);
    		if ('isTarget' in $$props) $$invalidate(3, isTarget = $$props.isTarget);
    		if ('id' in $$props) $$invalidate(0, id = $$props.id);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		jsPlumbInstanceStore,
    		isSource,
    		isTarget,
    		id,
    		element,
    		$jsPlumbInstanceStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('isSource' in $$props) $$invalidate(2, isSource = $$props.isSource);
    		if ('isTarget' in $$props) $$invalidate(3, isTarget = $$props.isTarget);
    		if ('id' in $$props) $$invalidate(0, id = $$props.id);
    		if ('element' in $$props) $$invalidate(1, element = $$props.element);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [id, element, isSource, isTarget, $$scope, slots, div_binding];
    }

    class Connectable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, { isSource: 2, isTarget: 3, id: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Connectable",
    			options,
    			id: create_fragment$i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[0] === undefined && !('id' in props)) {
    			console_1$2.warn("<Connectable> was created without expected prop 'id'");
    		}
    	}

    	get isSource() {
    		throw new Error("<Connectable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isSource(value) {
    		throw new Error("<Connectable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isTarget() {
    		throw new Error("<Connectable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isTarget(value) {
    		throw new Error("<Connectable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Connectable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Connectable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /**
     * @license
     * Lodash <https://lodash.com/>
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    var lodash = createCommonjsModule(function (module, exports) {
    (function() {

      /** Used as a safe reference for `undefined` in pre-ES5 environments. */
      var undefined$1;

      /** Used as the semantic version number. */
      var VERSION = '4.17.21';

      /** Used as the size to enable large array optimizations. */
      var LARGE_ARRAY_SIZE = 200;

      /** Error message constants. */
      var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
          FUNC_ERROR_TEXT = 'Expected a function',
          INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

      /** Used to stand-in for `undefined` hash values. */
      var HASH_UNDEFINED = '__lodash_hash_undefined__';

      /** Used as the maximum memoize cache size. */
      var MAX_MEMOIZE_SIZE = 500;

      /** Used as the internal argument placeholder. */
      var PLACEHOLDER = '__lodash_placeholder__';

      /** Used to compose bitmasks for cloning. */
      var CLONE_DEEP_FLAG = 1,
          CLONE_FLAT_FLAG = 2,
          CLONE_SYMBOLS_FLAG = 4;

      /** Used to compose bitmasks for value comparisons. */
      var COMPARE_PARTIAL_FLAG = 1,
          COMPARE_UNORDERED_FLAG = 2;

      /** Used to compose bitmasks for function metadata. */
      var WRAP_BIND_FLAG = 1,
          WRAP_BIND_KEY_FLAG = 2,
          WRAP_CURRY_BOUND_FLAG = 4,
          WRAP_CURRY_FLAG = 8,
          WRAP_CURRY_RIGHT_FLAG = 16,
          WRAP_PARTIAL_FLAG = 32,
          WRAP_PARTIAL_RIGHT_FLAG = 64,
          WRAP_ARY_FLAG = 128,
          WRAP_REARG_FLAG = 256,
          WRAP_FLIP_FLAG = 512;

      /** Used as default options for `_.truncate`. */
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';

      /** Used to detect hot functions by number of calls within a span of milliseconds. */
      var HOT_COUNT = 800,
          HOT_SPAN = 16;

      /** Used to indicate the type of lazy iteratees. */
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2,
          LAZY_WHILE_FLAG = 3;

      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0,
          MAX_SAFE_INTEGER = 9007199254740991,
          MAX_INTEGER = 1.7976931348623157e+308,
          NAN = 0 / 0;

      /** Used as references for the maximum length and index of an array. */
      var MAX_ARRAY_LENGTH = 4294967295,
          MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
          HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

      /** Used to associate wrap methods with their bit flags. */
      var wrapFlags = [
        ['ary', WRAP_ARY_FLAG],
        ['bind', WRAP_BIND_FLAG],
        ['bindKey', WRAP_BIND_KEY_FLAG],
        ['curry', WRAP_CURRY_FLAG],
        ['curryRight', WRAP_CURRY_RIGHT_FLAG],
        ['flip', WRAP_FLIP_FLAG],
        ['partial', WRAP_PARTIAL_FLAG],
        ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
        ['rearg', WRAP_REARG_FLAG]
      ];

      /** `Object#toString` result references. */
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          asyncTag = '[object AsyncFunction]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          domExcTag = '[object DOMException]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          genTag = '[object GeneratorFunction]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          nullTag = '[object Null]',
          objectTag = '[object Object]',
          promiseTag = '[object Promise]',
          proxyTag = '[object Proxy]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          symbolTag = '[object Symbol]',
          undefinedTag = '[object Undefined]',
          weakMapTag = '[object WeakMap]',
          weakSetTag = '[object WeakSet]';

      var arrayBufferTag = '[object ArrayBuffer]',
          dataViewTag = '[object DataView]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';

      /** Used to match empty string literals in compiled template source. */
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

      /** Used to match HTML entities and HTML characters. */
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
          reUnescapedHtml = /[&<>"']/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

      /** Used to match template delimiters. */
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;

      /** Used to match property names within property paths. */
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

      /**
       * Used to match `RegExp`
       * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
       */
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
          reHasRegExpChar = RegExp(reRegExpChar.source);

      /** Used to match leading whitespace. */
      var reTrimStart = /^\s+/;

      /** Used to match a single whitespace character. */
      var reWhitespace = /\s/;

      /** Used to match wrap detail comments. */
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
          reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
          reSplitDetails = /,? & /;

      /** Used to match words composed of alphanumeric characters. */
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

      /**
       * Used to validate the `validate` option in `_.template` variable.
       *
       * Forbids characters which could potentially change the meaning of the function argument definition:
       * - "()," (modification of function parameters)
       * - "=" (default value)
       * - "[]{}" (destructuring of function parameters)
       * - "/" (beginning of a comment)
       * - whitespace
       */
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

      /** Used to match backslashes in property paths. */
      var reEscapeChar = /\\(\\)?/g;

      /**
       * Used to match
       * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
       */
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

      /** Used to match `RegExp` flags from their coerced string values. */
      var reFlags = /\w*$/;

      /** Used to detect bad signed hexadecimal string values. */
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

      /** Used to detect binary string values. */
      var reIsBinary = /^0b[01]+$/i;

      /** Used to detect host constructors (Safari). */
      var reIsHostCtor = /^\[object .+?Constructor\]$/;

      /** Used to detect octal string values. */
      var reIsOctal = /^0o[0-7]+$/i;

      /** Used to detect unsigned integer values. */
      var reIsUint = /^(?:0|[1-9]\d*)$/;

      /** Used to match Latin Unicode letters (excluding mathematical operators). */
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

      /** Used to ensure capturing order of template delimiters. */
      var reNoMatch = /($^)/;

      /** Used to match unescaped characters in compiled string literals. */
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

      /** Used to compose unicode character classes. */
      var rsAstralRange = '\\ud800-\\udfff',
          rsComboMarksRange = '\\u0300-\\u036f',
          reComboHalfMarksRange = '\\ufe20-\\ufe2f',
          rsComboSymbolsRange = '\\u20d0-\\u20ff',
          rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
          rsDingbatRange = '\\u2700-\\u27bf',
          rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
          rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
          rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
          rsPunctuationRange = '\\u2000-\\u206f',
          rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
          rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
          rsVarRange = '\\ufe0e\\ufe0f',
          rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

      /** Used to compose unicode capture groups. */
      var rsApos = "['\u2019]",
          rsAstral = '[' + rsAstralRange + ']',
          rsBreak = '[' + rsBreakRange + ']',
          rsCombo = '[' + rsComboRange + ']',
          rsDigits = '\\d+',
          rsDingbat = '[' + rsDingbatRange + ']',
          rsLower = '[' + rsLowerRange + ']',
          rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
          rsFitz = '\\ud83c[\\udffb-\\udfff]',
          rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
          rsNonAstral = '[^' + rsAstralRange + ']',
          rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
          rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
          rsUpper = '[' + rsUpperRange + ']',
          rsZWJ = '\\u200d';

      /** Used to compose unicode regexes. */
      var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
          rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
          rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
          rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
          reOptMod = rsModifier + '?',
          rsOptVar = '[' + rsVarRange + ']?',
          rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
          rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
          rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
          rsSeq = rsOptVar + reOptMod + rsOptJoin,
          rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
          rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

      /** Used to match apostrophes. */
      var reApos = RegExp(rsApos, 'g');

      /**
       * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
       * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
       */
      var reComboMark = RegExp(rsCombo, 'g');

      /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
      var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

      /** Used to match complex or compound words. */
      var reUnicodeWord = RegExp([
        rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
        rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
        rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
        rsUpper + '+' + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join('|'), 'g');

      /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
      var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

      /** Used to detect strings that need a more robust regexp to match words. */
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

      /** Used to assign default `context` object properties. */
      var contextProps = [
        'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
        'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
        'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
        'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
        '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
      ];

      /** Used to make template sourceURLs easier to identify. */
      var templateCounter = -1;

      /** Used to identify `toStringTag` values of typed arrays. */
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
      typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
      typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
      typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
      typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
      typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
      typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
      typedArrayTags[errorTag] = typedArrayTags[funcTag] =
      typedArrayTags[mapTag] = typedArrayTags[numberTag] =
      typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
      typedArrayTags[setTag] = typedArrayTags[stringTag] =
      typedArrayTags[weakMapTag] = false;

      /** Used to identify `toStringTag` values supported by `_.clone`. */
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] =
      cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
      cloneableTags[boolTag] = cloneableTags[dateTag] =
      cloneableTags[float32Tag] = cloneableTags[float64Tag] =
      cloneableTags[int8Tag] = cloneableTags[int16Tag] =
      cloneableTags[int32Tag] = cloneableTags[mapTag] =
      cloneableTags[numberTag] = cloneableTags[objectTag] =
      cloneableTags[regexpTag] = cloneableTags[setTag] =
      cloneableTags[stringTag] = cloneableTags[symbolTag] =
      cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
      cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] =
      cloneableTags[weakMapTag] = false;

      /** Used to map Latin Unicode letters to basic Latin letters. */
      var deburredLetters = {
        // Latin-1 Supplement block.
        '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
        '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
        '\xc7': 'C',  '\xe7': 'c',
        '\xd0': 'D',  '\xf0': 'd',
        '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
        '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
        '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
        '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
        '\xd1': 'N',  '\xf1': 'n',
        '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
        '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
        '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
        '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
        '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
        '\xc6': 'Ae', '\xe6': 'ae',
        '\xde': 'Th', '\xfe': 'th',
        '\xdf': 'ss',
        // Latin Extended-A block.
        '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
        '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
        '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
        '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
        '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
        '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
        '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
        '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
        '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
        '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
        '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
        '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
        '\u0134': 'J',  '\u0135': 'j',
        '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
        '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
        '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
        '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
        '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
        '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
        '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
        '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
        '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
        '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
        '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
        '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
        '\u0163': 't',  '\u0165': 't', '\u0167': 't',
        '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
        '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
        '\u0174': 'W',  '\u0175': 'w',
        '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
        '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
        '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
        '\u0132': 'IJ', '\u0133': 'ij',
        '\u0152': 'Oe', '\u0153': 'oe',
        '\u0149': "'n", '\u017f': 's'
      };

      /** Used to map characters to HTML entities. */
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      };

      /** Used to map HTML entities to characters. */
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'"
      };

      /** Used to escape characters for inclusion in compiled string literals. */
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };

      /** Built-in method references without a dependency on `root`. */
      var freeParseFloat = parseFloat,
          freeParseInt = parseInt;

      /** Detect free variable `global` from Node.js. */
      var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

      /** Detect free variable `self`. */
      var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

      /** Used as a reference to the global object. */
      var root = freeGlobal || freeSelf || Function('return this')();

      /** Detect free variable `exports`. */
      var freeExports = exports && !exports.nodeType && exports;

      /** Detect free variable `module`. */
      var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

      /** Detect the popular CommonJS extension `module.exports`. */
      var moduleExports = freeModule && freeModule.exports === freeExports;

      /** Detect free variable `process` from Node.js. */
      var freeProcess = moduleExports && freeGlobal.process;

      /** Used to access faster Node.js helpers. */
      var nodeUtil = (function() {
        try {
          // Use `util.types` for Node.js 10+.
          var types = freeModule && freeModule.require && freeModule.require('util').types;

          if (types) {
            return types;
          }

          // Legacy `process.binding('util')` for Node.js < 10.
          return freeProcess && freeProcess.binding && freeProcess.binding('util');
        } catch (e) {}
      }());

      /* Node.js helper references. */
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
          nodeIsDate = nodeUtil && nodeUtil.isDate,
          nodeIsMap = nodeUtil && nodeUtil.isMap,
          nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
          nodeIsSet = nodeUtil && nodeUtil.isSet,
          nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

      /*--------------------------------------------------------------------------*/

      /**
       * A faster alternative to `Function#apply`, this function invokes `func`
       * with the `this` binding of `thisArg` and the arguments of `args`.
       *
       * @private
       * @param {Function} func The function to invoke.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} args The arguments to invoke `func` with.
       * @returns {*} Returns the result of `func`.
       */
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0: return func.call(thisArg);
          case 1: return func.call(thisArg, args[0]);
          case 2: return func.call(thisArg, args[0], args[1]);
          case 3: return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }

      /**
       * A specialized version of `baseAggregator` for arrays.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform keys.
       * @param {Object} accumulator The initial aggregated object.
       * @returns {Function} Returns `accumulator`.
       */
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.forEach` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEach(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }

      /**
       * A specialized version of `_.forEachRight` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;

        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }

      /**
       * A specialized version of `_.every` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       */
      function arrayEvery(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }

      /**
       * A specialized version of `_.filter` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */
      function arrayFilter(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }

      /**
       * A specialized version of `_.includes` for arrays without support for
       * specifying an index to search from.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }

      /**
       * This function is like `arrayIncludes` except that it accepts a comparator.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludesWith(array, value, comparator) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }

      /**
       * A specialized version of `_.map` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function arrayMap(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);

        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }

      /**
       * Appends the elements of `values` to `array`.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to append.
       * @returns {Array} Returns `array`.
       */
      function arrayPush(array, values) {
        var index = -1,
            length = values.length,
            offset = array.length;

        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }

      /**
       * A specialized version of `_.reduce` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the first element of `array` as
       *  the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1,
            length = array == null ? 0 : array.length;

        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.reduceRight` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the last element of `array` as
       *  the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.some` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       */
      function arraySome(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }

      /**
       * Gets the size of an ASCII `string`.
       *
       * @private
       * @param {string} string The string inspect.
       * @returns {number} Returns the string size.
       */
      var asciiSize = baseProperty('length');

      /**
       * Converts an ASCII `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function asciiToArray(string) {
        return string.split('');
      }

      /**
       * Splits an ASCII `string` into an array of its words.
       *
       * @private
       * @param {string} The string to inspect.
       * @returns {Array} Returns the words of `string`.
       */
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }

      /**
       * The base implementation of methods like `_.findKey` and `_.findLastKey`,
       * without support for iteratee shorthands, which iterates over `collection`
       * using `eachFunc`.
       *
       * @private
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} predicate The function invoked per iteration.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @returns {*} Returns the found element or its key, else `undefined`.
       */
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection) {
          if (predicate(value, key, collection)) {
            result = key;
            return false;
          }
        });
        return result;
      }

      /**
       * The base implementation of `_.findIndex` and `_.findLastIndex` without
       * support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} predicate The function invoked per iteration.
       * @param {number} fromIndex The index to search from.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 1 : -1);

        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOf(array, value, fromIndex) {
        return value === value
          ? strictIndexOf(array, value, fromIndex)
          : baseFindIndex(array, baseIsNaN, fromIndex);
      }

      /**
       * This function is like `baseIndexOf` except that it accepts a comparator.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1,
            length = array.length;

        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * The base implementation of `_.isNaN` without support for number objects.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
       */
      function baseIsNaN(value) {
        return value !== value;
      }

      /**
       * The base implementation of `_.mean` and `_.meanBy` without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {number} Returns the mean.
       */
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? (baseSum(array, iteratee) / length) : NAN;
      }

      /**
       * The base implementation of `_.property` without support for deep paths.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @returns {Function} Returns the new accessor function.
       */
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined$1 : object[key];
        };
      }

      /**
       * The base implementation of `_.propertyOf` without support for deep paths.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       */
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined$1 : object[key];
        };
      }

      /**
       * The base implementation of `_.reduce` and `_.reduceRight`, without support
       * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} accumulator The initial value.
       * @param {boolean} initAccum Specify using the first or last element of
       *  `collection` as the initial value.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @returns {*} Returns the accumulated value.
       */
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection) {
          accumulator = initAccum
            ? (initAccum = false, value)
            : iteratee(accumulator, value, index, collection);
        });
        return accumulator;
      }

      /**
       * The base implementation of `_.sortBy` which uses `comparer` to define the
       * sort order of `array` and replaces criteria objects with their corresponding
       * values.
       *
       * @private
       * @param {Array} array The array to sort.
       * @param {Function} comparer The function to define sort order.
       * @returns {Array} Returns `array`.
       */
      function baseSortBy(array, comparer) {
        var length = array.length;

        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }

      /**
       * The base implementation of `_.sum` and `_.sumBy` without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {number} Returns the sum.
       */
      function baseSum(array, iteratee) {
        var result,
            index = -1,
            length = array.length;

        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : (result + current);
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.times` without support for iteratee shorthands
       * or max array length checks.
       *
       * @private
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       */
      function baseTimes(n, iteratee) {
        var index = -1,
            result = Array(n);

        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }

      /**
       * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
       * of key-value pairs for `object` corresponding to the property names of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the key-value pairs.
       */
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }

      /**
       * The base implementation of `_.trim`.
       *
       * @private
       * @param {string} string The string to trim.
       * @returns {string} Returns the trimmed string.
       */
      function baseTrim(string) {
        return string
          ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
          : string;
      }

      /**
       * The base implementation of `_.unary` without support for storing metadata.
       *
       * @private
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       */
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }

      /**
       * The base implementation of `_.values` and `_.valuesIn` which creates an
       * array of `object` property values corresponding to the property names
       * of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the array of property values.
       */
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }

      /**
       * Checks if a `cache` value for `key` exists.
       *
       * @private
       * @param {Object} cache The cache to query.
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function cacheHas(cache, key) {
        return cache.has(key);
      }

      /**
       * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
       * that is not found in the character symbols.
       *
       * @private
       * @param {Array} strSymbols The string symbols to inspect.
       * @param {Array} chrSymbols The character symbols to find.
       * @returns {number} Returns the index of the first unmatched string symbol.
       */
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1,
            length = strSymbols.length;

        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }

      /**
       * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
       * that is not found in the character symbols.
       *
       * @private
       * @param {Array} strSymbols The string symbols to inspect.
       * @param {Array} chrSymbols The character symbols to find.
       * @returns {number} Returns the index of the last unmatched string symbol.
       */
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;

        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }

      /**
       * Gets the number of `placeholder` occurrences in `array`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} placeholder The placeholder to search for.
       * @returns {number} Returns the placeholder count.
       */
      function countHolders(array, placeholder) {
        var length = array.length,
            result = 0;

        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }

      /**
       * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
       * letters to basic Latin letters.
       *
       * @private
       * @param {string} letter The matched letter to deburr.
       * @returns {string} Returns the deburred letter.
       */
      var deburrLetter = basePropertyOf(deburredLetters);

      /**
       * Used by `_.escape` to convert characters to HTML entities.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      var escapeHtmlChar = basePropertyOf(htmlEscapes);

      /**
       * Used by `_.template` to escape characters for inclusion in compiled string literals.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }

      /**
       * Gets the value at `key` of `object`.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */
      function getValue(object, key) {
        return object == null ? undefined$1 : object[key];
      }

      /**
       * Checks if `string` contains Unicode symbols.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {boolean} Returns `true` if a symbol is found, else `false`.
       */
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }

      /**
       * Checks if `string` contains a word composed of Unicode symbols.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {boolean} Returns `true` if a word is found, else `false`.
       */
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }

      /**
       * Converts `iterator` to an array.
       *
       * @private
       * @param {Object} iterator The iterator to convert.
       * @returns {Array} Returns the converted array.
       */
      function iteratorToArray(iterator) {
        var data,
            result = [];

        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }

      /**
       * Converts `map` to its key-value pairs.
       *
       * @private
       * @param {Object} map The map to convert.
       * @returns {Array} Returns the key-value pairs.
       */
      function mapToArray(map) {
        var index = -1,
            result = Array(map.size);

        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }

      /**
       * Creates a unary function that invokes `func` with its argument transformed.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {Function} transform The argument transform.
       * @returns {Function} Returns the new function.
       */
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }

      /**
       * Replaces all `placeholder` elements in `array` with an internal placeholder
       * and returns an array of their indexes.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {*} placeholder The placeholder to replace.
       * @returns {Array} Returns the new array of placeholder indexes.
       */
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }

      /**
       * Converts `set` to an array of its values.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the values.
       */
      function setToArray(set) {
        var index = -1,
            result = Array(set.size);

        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }

      /**
       * Converts `set` to its value-value pairs.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the value-value pairs.
       */
      function setToPairs(set) {
        var index = -1,
            result = Array(set.size);

        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }

      /**
       * A specialized version of `_.indexOf` which performs strict equality
       * comparisons of values, i.e. `===`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1,
            length = array.length;

        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }

      /**
       * A specialized version of `_.lastIndexOf` which performs strict equality
       * comparisons of values, i.e. `===`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }

      /**
       * Gets the number of symbols in `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the string size.
       */
      function stringSize(string) {
        return hasUnicode(string)
          ? unicodeSize(string)
          : asciiSize(string);
      }

      /**
       * Converts `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function stringToArray(string) {
        return hasUnicode(string)
          ? unicodeToArray(string)
          : asciiToArray(string);
      }

      /**
       * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
       * character of `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the index of the last non-whitespace character.
       */
      function trimmedEndIndex(string) {
        var index = string.length;

        while (index-- && reWhitespace.test(string.charAt(index))) {}
        return index;
      }

      /**
       * Used by `_.unescape` to convert HTML entities to characters.
       *
       * @private
       * @param {string} chr The matched character to unescape.
       * @returns {string} Returns the unescaped character.
       */
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

      /**
       * Gets the size of a Unicode `string`.
       *
       * @private
       * @param {string} string The string inspect.
       * @returns {number} Returns the string size.
       */
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }

      /**
       * Converts a Unicode `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }

      /**
       * Splits a Unicode `string` into an array of its words.
       *
       * @private
       * @param {string} The string to inspect.
       * @returns {Array} Returns the words of `string`.
       */
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }

      /*--------------------------------------------------------------------------*/

      /**
       * Create a new pristine `lodash` function using the `context` object.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Util
       * @param {Object} [context=root] The context object.
       * @returns {Function} Returns a new `lodash` function.
       * @example
       *
       * _.mixin({ 'foo': _.constant('foo') });
       *
       * var lodash = _.runInContext();
       * lodash.mixin({ 'bar': lodash.constant('bar') });
       *
       * _.isFunction(_.foo);
       * // => true
       * _.isFunction(_.bar);
       * // => false
       *
       * lodash.isFunction(lodash.foo);
       * // => false
       * lodash.isFunction(lodash.bar);
       * // => true
       *
       * // Create a suped-up `defer` in Node.js.
       * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
       */
      var runInContext = (function runInContext(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

        /** Built-in constructor references. */
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;

        /** Used for built-in method references. */
        var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype;

        /** Used to detect overreaching core-js shims. */
        var coreJsData = context['__core-js_shared__'];

        /** Used to resolve the decompiled source of functions. */
        var funcToString = funcProto.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /** Used to generate unique IDs. */
        var idCounter = 0;

        /** Used to detect methods masquerading as native. */
        var maskSrcKey = (function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
          return uid ? ('Symbol(src)_1.' + uid) : '';
        }());

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString = objectProto.toString;

        /** Used to infer the `Object` constructor. */
        var objectCtorString = funcToString.call(Object);

        /** Used to restore the original `_` reference in `_.noConflict`. */
        var oldDash = root._;

        /** Used to detect if a method is native. */
        var reIsNative = RegExp('^' +
          funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
          .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
        );

        /** Built-in value references. */
        var Buffer = moduleExports ? context.Buffer : undefined$1,
            Symbol = context.Symbol,
            Uint8Array = context.Uint8Array,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
            getPrototype = overArg(Object.getPrototypeOf, Object),
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice,
            spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
            symIterator = Symbol ? Symbol.iterator : undefined$1,
            symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

        var defineProperty = (function() {
          try {
            var func = getNative(Object, 'defineProperty');
            func({}, '', {});
            return func;
          } catch (e) {}
        }());

        /** Mocked built-ins. */
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
            ctxNow = Date && Date.now !== root.Date.now && Date.now,
            ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeCeil = Math.ceil,
            nativeFloor = Math.floor,
            nativeGetSymbols = Object.getOwnPropertySymbols,
            nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
            nativeIsFinite = context.isFinite,
            nativeJoin = arrayProto.join,
            nativeKeys = overArg(Object.keys, Object),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = Date.now,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random,
            nativeReverse = arrayProto.reverse;

        /* Built-in method references that are verified to be native. */
        var DataView = getNative(context, 'DataView'),
            Map = getNative(context, 'Map'),
            Promise = getNative(context, 'Promise'),
            Set = getNative(context, 'Set'),
            WeakMap = getNative(context, 'WeakMap'),
            nativeCreate = getNative(Object, 'create');

        /** Used to store function metadata. */
        var metaMap = WeakMap && new WeakMap;

        /** Used to lookup unminified function names. */
        var realNames = {};

        /** Used to detect maps, sets, and weakmaps. */
        var dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map),
            promiseCtorString = toSource(Promise),
            setCtorString = toSource(Set),
            weakMapCtorString = toSource(WeakMap);

        /** Used to convert symbols to primitives and strings. */
        var symbolProto = Symbol ? Symbol.prototype : undefined$1,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
            symbolToString = symbolProto ? symbolProto.toString : undefined$1;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a `lodash` object which wraps `value` to enable implicit method
         * chain sequences. Methods that operate on and return arrays, collections,
         * and functions can be chained together. Methods that retrieve a single value
         * or may return a primitive value will automatically end the chain sequence
         * and return the unwrapped value. Otherwise, the value must be unwrapped
         * with `_#value`.
         *
         * Explicit chain sequences, which must be unwrapped with `_#value`, may be
         * enabled using `_.chain`.
         *
         * The execution of chained methods is lazy, that is, it's deferred until
         * `_#value` is implicitly or explicitly called.
         *
         * Lazy evaluation allows several methods to support shortcut fusion.
         * Shortcut fusion is an optimization to merge iteratee calls; this avoids
         * the creation of intermediate arrays and can greatly reduce the number of
         * iteratee executions. Sections of a chain sequence qualify for shortcut
         * fusion if the section is applied to an array and iteratees accept only
         * one argument. The heuristic for whether a section qualifies for shortcut
         * fusion is subject to change.
         *
         * Chaining is supported in custom builds as long as the `_#value` method is
         * directly or indirectly included in the build.
         *
         * In addition to lodash methods, wrappers have `Array` and `String` methods.
         *
         * The wrapper `Array` methods are:
         * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
         *
         * The wrapper `String` methods are:
         * `replace` and `split`
         *
         * The wrapper methods that support shortcut fusion are:
         * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
         * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
         * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
         *
         * The chainable wrapper methods are:
         * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
         * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
         * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
         * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
         * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
         * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
         * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
         * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
         * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
         * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
         * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
         * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
         * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
         * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
         * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
         * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
         * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
         * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
         * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
         * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
         * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
         * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
         * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
         * `zipObject`, `zipObjectDeep`, and `zipWith`
         *
         * The wrapper methods that are **not** chainable by default are:
         * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
         * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
         * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
         * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
         * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
         * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
         * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
         * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
         * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
         * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
         * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
         * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
         * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
         * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
         * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
         * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
         * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
         * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
         * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
         * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
         * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
         * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
         * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
         * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
         * `upperFirst`, `value`, and `words`
         *
         * @name _
         * @constructor
         * @category Seq
         * @param {*} value The value to wrap in a `lodash` instance.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var wrapped = _([1, 2, 3]);
         *
         * // Returns an unwrapped value.
         * wrapped.reduce(_.add);
         * // => 6
         *
         * // Returns a wrapped value.
         * var squares = wrapped.map(square);
         *
         * _.isArray(squares);
         * // => false
         *
         * _.isArray(squares.value());
         * // => true
         */
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }

        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} proto The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate = (function() {
          function object() {}
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result = new object;
            object.prototype = undefined$1;
            return result;
          };
        }());

        /**
         * The function whose prototype chain sequence wrappers inherit from.
         *
         * @private
         */
        function baseLodash() {
          // No operation performed.
        }

        /**
         * The base constructor for creating `lodash` wrapper objects.
         *
         * @private
         * @param {*} value The value to wrap.
         * @param {boolean} [chainAll] Enable explicit method chain sequences.
         */
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }

        /**
         * By default, the template delimiters used by lodash are like those in
         * embedded Ruby (ERB) as well as ES2015 template strings. Change the
         * following template settings to use alternative delimiters.
         *
         * @static
         * @memberOf _
         * @type {Object}
         */
        lodash.templateSettings = {

          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'escape': reEscape,

          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'evaluate': reEvaluate,

          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'interpolate': reInterpolate,

          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          'variable': '',

          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          'imports': {

            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            '_': lodash
          }
        };

        // Ensure wrappers are instances of `baseLodash`.
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;

        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
         *
         * @private
         * @constructor
         * @param {*} value The value to wrap.
         */
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }

        /**
         * Creates a clone of the lazy wrapper object.
         *
         * @private
         * @name clone
         * @memberOf LazyWrapper
         * @returns {Object} Returns the cloned `LazyWrapper` object.
         */
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = copyArray(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = copyArray(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = copyArray(this.__views__);
          return result;
        }

        /**
         * Reverses the direction of lazy iteration.
         *
         * @private
         * @name reverse
         * @memberOf LazyWrapper
         * @returns {Object} Returns the new reversed `LazyWrapper` object.
         */
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }

        /**
         * Extracts the unwrapped value from its lazy wrapper.
         *
         * @private
         * @name value
         * @memberOf LazyWrapper
         * @returns {*} Returns the unwrapped value.
         */
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);

          if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result = [];

          outer:
          while (length-- && resIndex < takeCount) {
            index += dir;

            var iterIndex = -1,
                value = array[index];

            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);

              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }

        // Ensure `LazyWrapper` is an instance of `baseLodash`.
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a hash object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Hash(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the hash.
         *
         * @private
         * @name clear
         * @memberOf Hash
         */
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the hash.
         *
         * @private
         * @name delete
         * @memberOf Hash
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function hashDelete(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }

        /**
         * Gets the hash value for `key`.
         *
         * @private
         * @name get
         * @memberOf Hash
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined$1 : result;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
        }

        /**
         * Checks if a hash value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Hash
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
        }

        /**
         * Sets the hash `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Hash
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the hash instance.
         */
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
          return this;
        }

        // Add methods to `Hash`.
        Hash.prototype.clear = hashClear;
        Hash.prototype['delete'] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates an list cache object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function ListCache(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the list cache.
         *
         * @private
         * @name clear
         * @memberOf ListCache
         */
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the list cache.
         *
         * @private
         * @name delete
         * @memberOf ListCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function listCacheDelete(key) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }

        /**
         * Gets the list cache value for `key`.
         *
         * @private
         * @name get
         * @memberOf ListCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function listCacheGet(key) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          return index < 0 ? undefined$1 : data[index][1];
        }

        /**
         * Checks if a list cache value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf ListCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }

        /**
         * Sets the list cache `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf ListCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the list cache instance.
         */
        function listCacheSet(key, value) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }

        // Add methods to `ListCache`.
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype['delete'] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a map cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function MapCache(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the map.
         *
         * @private
         * @name clear
         * @memberOf MapCache
         */
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            'hash': new Hash,
            'map': new (Map || ListCache),
            'string': new Hash
          };
        }

        /**
         * Removes `key` and its value from the map.
         *
         * @private
         * @name delete
         * @memberOf MapCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function mapCacheDelete(key) {
          var result = getMapData(this, key)['delete'](key);
          this.size -= result ? 1 : 0;
          return result;
        }

        /**
         * Gets the map value for `key`.
         *
         * @private
         * @name get
         * @memberOf MapCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }

        /**
         * Checks if a map value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf MapCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }

        /**
         * Sets the map `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf MapCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the map cache instance.
         */
        function mapCacheSet(key, value) {
          var data = getMapData(this, key),
              size = data.size;

          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }

        // Add methods to `MapCache`.
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype['delete'] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;

        /*------------------------------------------------------------------------*/

        /**
         *
         * Creates an array cache object to store unique values.
         *
         * @private
         * @constructor
         * @param {Array} [values] The values to cache.
         */
        function SetCache(values) {
          var index = -1,
              length = values == null ? 0 : values.length;

          this.__data__ = new MapCache;
          while (++index < length) {
            this.add(values[index]);
          }
        }

        /**
         * Adds `value` to the array cache.
         *
         * @private
         * @name add
         * @memberOf SetCache
         * @alias push
         * @param {*} value The value to cache.
         * @returns {Object} Returns the cache instance.
         */
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }

        /**
         * Checks if `value` is in the array cache.
         *
         * @private
         * @name has
         * @memberOf SetCache
         * @param {*} value The value to search for.
         * @returns {number} Returns `true` if `value` is found, else `false`.
         */
        function setCacheHas(value) {
          return this.__data__.has(value);
        }

        // Add methods to `SetCache`.
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a stack cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }

        /**
         * Removes all key-value entries from the stack.
         *
         * @private
         * @name clear
         * @memberOf Stack
         */
        function stackClear() {
          this.__data__ = new ListCache;
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the stack.
         *
         * @private
         * @name delete
         * @memberOf Stack
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function stackDelete(key) {
          var data = this.__data__,
              result = data['delete'](key);

          this.size = data.size;
          return result;
        }

        /**
         * Gets the stack value for `key`.
         *
         * @private
         * @name get
         * @memberOf Stack
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function stackGet(key) {
          return this.__data__.get(key);
        }

        /**
         * Checks if a stack value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Stack
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function stackHas(key) {
          return this.__data__.has(key);
        }

        /**
         * Sets the stack `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Stack
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the stack cache instance.
         */
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }

        // Add methods to `Stack`.
        Stack.prototype.clear = stackClear;
        Stack.prototype['delete'] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates an array of the enumerable property names of the array-like `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @param {boolean} inherited Specify returning inherited property names.
         * @returns {Array} Returns the array of property names.
         */
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value),
              isArg = !isArr && isArguments(value),
              isBuff = !isArr && !isArg && isBuffer(value),
              isType = !isArr && !isArg && !isBuff && isTypedArray(value),
              skipIndexes = isArr || isArg || isBuff || isType,
              result = skipIndexes ? baseTimes(value.length, String) : [],
              length = result.length;

          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) &&
                !(skipIndexes && (
                   // Safari 9 has enumerable `arguments.length` in strict mode.
                   key == 'length' ||
                   // Node.js 0.10 has enumerable non-index properties on buffers.
                   (isBuff && (key == 'offset' || key == 'parent')) ||
                   // PhantomJS 2 has enumerable non-index properties on typed arrays.
                   (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
                   // Skip index properties.
                   isIndex(key, length)
                ))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * A specialized version of `_.sample` for arrays.
         *
         * @private
         * @param {Array} array The array to sample.
         * @returns {*} Returns the random element.
         */
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined$1;
        }

        /**
         * A specialized version of `_.sampleSize` for arrays.
         *
         * @private
         * @param {Array} array The array to sample.
         * @param {number} n The number of elements to sample.
         * @returns {Array} Returns the random elements.
         */
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }

        /**
         * A specialized version of `_.shuffle` for arrays.
         *
         * @private
         * @param {Array} array The array to shuffle.
         * @returns {Array} Returns the new shuffled array.
         */
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }

        /**
         * This function is like `assignValue` except that it doesn't assign
         * `undefined` values.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignMergeValue(object, key, value) {
          if ((value !== undefined$1 && !eq(object[key], value)) ||
              (value === undefined$1 && !(key in object))) {
            baseAssignValue(object, key, value);
          }
        }

        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
              (value === undefined$1 && !(key in object))) {
            baseAssignValue(object, key, value);
          }
        }

        /**
         * Gets the index at which the `key` is found in `array` of key-value pairs.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} key The key to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }

        /**
         * Aggregates elements of `collection` on `accumulator` with keys transformed
         * by `iteratee` and values set by `setter`.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform keys.
         * @param {Object} accumulator The initial aggregated object.
         * @returns {Function} Returns `accumulator`.
         */
        function baseAggregator(collection, setter, iteratee, accumulator) {
          baseEach(collection, function(value, key, collection) {
            setter(accumulator, value, iteratee(value), collection);
          });
          return accumulator;
        }

        /**
         * The base implementation of `_.assign` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }

        /**
         * The base implementation of `_.assignIn` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }

        /**
         * The base implementation of `assignValue` and `assignMergeValue` without
         * value checks.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function baseAssignValue(object, key, value) {
          if (key == '__proto__' && defineProperty) {
            defineProperty(object, key, {
              'configurable': true,
              'enumerable': true,
              'value': value,
              'writable': true
            });
          } else {
            object[key] = value;
          }
        }

        /**
         * The base implementation of `_.at` without support for individual paths.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {string[]} paths The property paths to pick.
         * @returns {Array} Returns the picked elements.
         */
        function baseAt(object, paths) {
          var index = -1,
              length = paths.length,
              result = Array(length),
              skip = object == null;

          while (++index < length) {
            result[index] = skip ? undefined$1 : get(object, paths[index]);
          }
          return result;
        }

        /**
         * The base implementation of `_.clamp` which doesn't coerce arguments.
         *
         * @private
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         */
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined$1) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined$1) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }

        /**
         * The base implementation of `_.clone` and `_.cloneDeep` which tracks
         * traversed objects.
         *
         * @private
         * @param {*} value The value to clone.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Deep clone
         *  2 - Flatten inherited properties
         *  4 - Clone symbols
         * @param {Function} [customizer] The function to customize cloning.
         * @param {string} [key] The key of `value`.
         * @param {Object} [object] The parent object of `value`.
         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
         * @returns {*} Returns the cloned value.
         */
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result,
              isDeep = bitmask & CLONE_DEEP_FLAG,
              isFlat = bitmask & CLONE_FLAT_FLAG,
              isFull = bitmask & CLONE_SYMBOLS_FLAG;

          if (customizer) {
            result = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result !== undefined$1) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result);
            }
          } else {
            var tag = getTag(value),
                isFunc = tag == funcTag || tag == genTag;

            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = (isFlat || isFunc) ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat
                  ? copySymbolsIn(value, baseAssignIn(result, value))
                  : copySymbols(value, baseAssign(result, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result = initCloneByTag(value, tag, isDeep);
            }
          }
          // Check for circular references and return its corresponding clone.
          stack || (stack = new Stack);
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result);

          if (isSet(value)) {
            value.forEach(function(subValue) {
              result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key) {
              result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
            });
          }

          var keysFunc = isFull
            ? (isFlat ? getAllKeysIn : getAllKeys)
            : (isFlat ? keysIn : keys);

          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function(subValue, key) {
            if (props) {
              key = subValue;
              subValue = value[key];
            }
            // Recursively populate clone (susceptible to call stack limits).
            assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
          });
          return result;
        }

        /**
         * The base implementation of `_.conforms` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property predicates to conform to.
         * @returns {Function} Returns the new spec function.
         */
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }

        /**
         * The base implementation of `_.conformsTo` which accepts `props` to check.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property predicates to conform to.
         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
         */
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (length--) {
            var key = props[length],
                predicate = source[key],
                value = object[key];

            if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }

        /**
         * The base implementation of `_.delay` and `_.defer` which accepts `args`
         * to provide to `func`.
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {Array} args The arguments to provide to `func`.
         * @returns {number|Object} Returns the timer id or timeout object.
         */
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() { func.apply(undefined$1, args); }, wait);
        }

        /**
         * The base implementation of methods like `_.difference` without support
         * for excluding multiple arrays or iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Array} values The values to exclude.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         */
        function baseDifference(array, values, iteratee, comparator) {
          var index = -1,
              includes = arrayIncludes,
              isCommon = true,
              length = array.length,
              result = [],
              valuesLength = values.length;

          if (!length) {
            return result;
          }
          if (iteratee) {
            values = arrayMap(values, baseUnary(iteratee));
          }
          if (comparator) {
            includes = arrayIncludesWith;
            isCommon = false;
          }
          else if (values.length >= LARGE_ARRAY_SIZE) {
            includes = cacheHas;
            isCommon = false;
            values = new SetCache(values);
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee == null ? value : iteratee(value);

            value = (comparator || value !== 0) ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result.push(value);
            }
            else if (!includes(values, computed, comparator)) {
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.forEach` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEach = createBaseEach(baseForOwn);

        /**
         * The base implementation of `_.forEachRight` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEachRight = createBaseEach(baseForOwnRight, true);

        /**
         * The base implementation of `_.every` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`
         */
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }

        /**
         * The base implementation of methods like `_.max` and `_.min` which accepts a
         * `comparator` to determine the extremum value.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The iteratee invoked per iteration.
         * @param {Function} comparator The comparator used to compare values.
         * @returns {*} Returns the extremum value.
         */
        function baseExtremum(array, iteratee, comparator) {
          var index = -1,
              length = array.length;

          while (++index < length) {
            var value = array[index],
                current = iteratee(value);

            if (current != null && (computed === undefined$1
                  ? (current === current && !isSymbol(current))
                  : comparator(current, computed)
                )) {
              var computed = current,
                  result = value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.fill` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         */
        function baseFill(array, value, start, end) {
          var length = array.length;

          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined$1 || end > length) ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }

        /**
         * The base implementation of `_.filter` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }

        /**
         * The base implementation of `_.flatten` with support for restricting flattening.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {number} depth The maximum recursion depth.
         * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
         * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */
        function baseFlatten(array, depth, predicate, isStrict, result) {
          var index = -1,
              length = array.length;

          predicate || (predicate = isFlattenable);
          result || (result = []);

          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, depth - 1, predicate, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `baseForOwn` which iterates over `object`
         * properties returned by `keysFunc` and invokes `iteratee` for each property.
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor = createBaseFor();

        /**
         * This function is like `baseFor` except that it iterates over properties
         * in the opposite order.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseForRight = createBaseFor(true);

        /**
         * The base implementation of `_.forOwn` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn(object, iteratee) {
          return object && baseFor(object, iteratee, keys);
        }

        /**
         * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwnRight(object, iteratee) {
          return object && baseForRight(object, iteratee, keys);
        }

        /**
         * The base implementation of `_.functions` which creates an array of
         * `object` function property names filtered from `props`.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} props The property names to filter.
         * @returns {Array} Returns the function names.
         */
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }

        /**
         * The base implementation of `_.get` without support for default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @returns {*} Returns the resolved value.
         */
        function baseGet(object, path) {
          path = castPath(path, object);

          var index = 0,
              length = path.length;

          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return (index && index == length) ? object : undefined$1;
        }

        /**
         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @param {Function} symbolsFunc The function to get the symbols of `object`.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }

        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return (symToStringTag && symToStringTag in Object(value))
            ? getRawTag(value)
            : objectToString(value);
        }

        /**
         * The base implementation of `_.gt` which doesn't coerce arguments.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`,
         *  else `false`.
         */
        function baseGt(value, other) {
          return value > other;
        }

        /**
         * The base implementation of `_.has` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }

        /**
         * The base implementation of `_.hasIn` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHasIn(object, key) {
          return object != null && key in Object(object);
        }

        /**
         * The base implementation of `_.inRange` which doesn't coerce arguments.
         *
         * @private
         * @param {number} number The number to check.
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
         */
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }

        /**
         * The base implementation of methods like `_.intersection`, without support
         * for iteratee shorthands, that accepts an array of arrays to inspect.
         *
         * @private
         * @param {Array} arrays The arrays to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of shared values.
         */
        function baseIntersection(arrays, iteratee, comparator) {
          var includes = comparator ? arrayIncludesWith : arrayIncludes,
              length = arrays[0].length,
              othLength = arrays.length,
              othIndex = othLength,
              caches = Array(othLength),
              maxLength = Infinity,
              result = [];

          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee) {
              array = arrayMap(array, baseUnary(iteratee));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
              ? new SetCache(othIndex && array)
              : undefined$1;
          }
          array = arrays[0];

          var index = -1,
              seen = caches[0];

          outer:
          while (++index < length && result.length < maxLength) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            value = (comparator || value !== 0) ? value : 0;
            if (!(seen
                  ? cacheHas(seen, computed)
                  : includes(result, computed, comparator)
                )) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache
                      ? cacheHas(cache, computed)
                      : includes(arrays[othIndex], computed, comparator))
                    ) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.invert` and `_.invertBy` which inverts
         * `object` with values transformed by `iteratee` and set by `setter`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform values.
         * @param {Object} accumulator The initial inverted object.
         * @returns {Function} Returns `accumulator`.
         */
        function baseInverter(object, setter, iteratee, accumulator) {
          baseForOwn(object, function(value, key, object) {
            setter(accumulator, iteratee(value), key, object);
          });
          return accumulator;
        }

        /**
         * The base implementation of `_.invoke` without support for individual
         * method arguments.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {Array} args The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         */
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined$1 : apply(func, object, args);
        }

        /**
         * The base implementation of `_.isArguments`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         */
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }

        /**
         * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
         */
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }

        /**
         * The base implementation of `_.isDate` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
         */
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }

        /**
         * The base implementation of `_.isEqual` which supports partial comparisons
         * and tracks traversed objects.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Unordered comparison
         *  2 - Partial comparison
         * @param {Function} [customizer] The function to customize comparisons.
         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }

        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = objIsArr ? arrayTag : getTag(object),
              othTag = othIsArr ? arrayTag : getTag(other);

          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;

          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;

          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack);
            return (objIsArr || isTypedArray(object))
              ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
              : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object,
                  othUnwrapped = othIsWrapped ? other.value() : other;

              stack || (stack = new Stack);
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack);
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }

        /**
         * The base implementation of `_.isMap` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         */
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }

        /**
         * The base implementation of `_.isMatch` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Array} matchData The property names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;

          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2])
                  ? data[1] !== object[data[0]]
                  : !(data[0] in object)
                ) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];

            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack;
              if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result === undefined$1
                    ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                    : result
                  )) {
                return false;
              }
            }
          }
          return true;
        }

        /**
         * The base implementation of `_.isNative` without bad shim checks.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         */
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }

        /**
         * The base implementation of `_.isRegExp` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
         */
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }

        /**
         * The base implementation of `_.isSet` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         */
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }

        /**
         * The base implementation of `_.isTypedArray` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         */
        function baseIsTypedArray(value) {
          return isObjectLike(value) &&
            isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }

        /**
         * The base implementation of `_.iteratee`.
         *
         * @private
         * @param {*} [value=_.identity] The value to convert to an iteratee.
         * @returns {Function} Returns the iteratee.
         */
        function baseIteratee(value) {
          // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
          // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
          if (typeof value == 'function') {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == 'object') {
            return isArray(value)
              ? baseMatchesProperty(value[0], value[1])
              : baseMatches(value);
          }
          return property(value);
        }

        /**
         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty.call(object, key) && key != 'constructor') {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object),
              result = [];

          for (var key in object) {
            if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.lt` which doesn't coerce arguments.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`,
         *  else `false`.
         */
        function baseLt(value, other) {
          return value < other;
        }

        /**
         * The base implementation of `_.map` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];

          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }

        /**
         * The base implementation of `_.matches` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }

        /**
         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return (objValue === undefined$1 && objValue === srcValue)
              ? hasIn(object, path)
              : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }

        /**
         * The base implementation of `_.merge` without support for multiple sources.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack);
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            }
            else {
              var newValue = customizer
                ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
                : undefined$1;

              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }

        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key),
              srcValue = safeGet(source, key),
              stacked = stack.get(srcValue);

          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer
            ? customizer(objValue, srcValue, (key + ''), object, source, stack)
            : undefined$1;

          var isCommon = newValue === undefined$1;

          if (isCommon) {
            var isArr = isArray(srcValue),
                isBuff = !isArr && isBuffer(srcValue),
                isTyped = !isArr && !isBuff && isTypedArray(srcValue);

            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              }
              else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              }
              else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              }
              else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              }
              else {
                newValue = [];
              }
            }
            else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              }
              else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            }
            else {
              isCommon = false;
            }
          }
          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack['delete'](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }

        /**
         * The base implementation of `_.nth` which doesn't coerce arguments.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {number} n The index of the element to return.
         * @returns {*} Returns the nth element of `array`.
         */
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined$1;
        }

        /**
         * The base implementation of `_.orderBy` without param guards.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
         * @param {string[]} orders The sort orders of `iteratees`.
         * @returns {Array} Returns the new sorted array.
         */
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee) {
              if (isArray(iteratee)) {
                return function(value) {
                  return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
                }
              }
              return iteratee;
            });
          } else {
            iteratees = [identity];
          }

          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

          var result = baseMap(collection, function(value, key, collection) {
            var criteria = arrayMap(iteratees, function(iteratee) {
              return iteratee(value);
            });
            return { 'criteria': criteria, 'index': ++index, 'value': value };
          });

          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }

        /**
         * The base implementation of `_.pick` without support for individual
         * property identifiers.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @returns {Object} Returns the new object.
         */
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }

        /**
         * The base implementation of  `_.pickBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @param {Function} predicate The function invoked per property.
         * @returns {Object} Returns the new object.
         */
        function basePickBy(object, paths, predicate) {
          var index = -1,
              length = paths.length,
              result = {};

          while (++index < length) {
            var path = paths[index],
                value = baseGet(object, path);

            if (predicate(value, path)) {
              baseSet(result, castPath(path, object), value);
            }
          }
          return result;
        }

        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }

        /**
         * The base implementation of `_.pullAllBy` without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns `array`.
         */
        function basePullAll(array, values, iteratee, comparator) {
          var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
              index = -1,
              length = values.length,
              seen = array;

          if (array === values) {
            values = copyArray(values);
          }
          if (iteratee) {
            seen = arrayMap(array, baseUnary(iteratee));
          }
          while (++index < length) {
            var fromIndex = 0,
                value = values[index],
                computed = iteratee ? iteratee(value) : value;

            while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }

        /**
         * The base implementation of `_.pullAt` without support for individual
         * indexes or capturing the removed elements.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {number[]} indexes The indexes of elements to remove.
         * @returns {Array} Returns `array`.
         */
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0,
              lastIndex = length - 1;

          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }

        /**
         * The base implementation of `_.random` without support for returning
         * floating-point numbers.
         *
         * @private
         * @param {number} lower The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the random number.
         */
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }

        /**
         * The base implementation of `_.range` and `_.rangeRight` which doesn't
         * coerce arguments.
         *
         * @private
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @param {number} step The value to increment or decrement by.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the range of numbers.
         */
        function baseRange(start, end, step, fromRight) {
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);

          while (length--) {
            result[fromRight ? length : ++index] = start;
            start += step;
          }
          return result;
        }

        /**
         * The base implementation of `_.repeat` which doesn't coerce arguments.
         *
         * @private
         * @param {string} string The string to repeat.
         * @param {number} n The number of times to repeat the string.
         * @returns {string} Returns the repeated string.
         */
        function baseRepeat(string, n) {
          var result = '';
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result;
          }
          // Leverage the exponentiation by squaring algorithm for a faster repeat.
          // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);

          return result;
        }

        /**
         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         */
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + '');
        }

        /**
         * The base implementation of `_.sample`.
         *
         * @private
         * @param {Array|Object} collection The collection to sample.
         * @returns {*} Returns the random element.
         */
        function baseSample(collection) {
          return arraySample(values(collection));
        }

        /**
         * The base implementation of `_.sampleSize` without param guards.
         *
         * @private
         * @param {Array|Object} collection The collection to sample.
         * @param {number} n The number of elements to sample.
         * @returns {Array} Returns the random elements.
         */
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }

        /**
         * The base implementation of `_.set`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);

          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;

          while (nested != null && ++index < length) {
            var key = toKey(path[index]),
                newValue = value;

            if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
              return object;
            }

            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject(objValue)
                  ? objValue
                  : (isIndex(path[index + 1]) ? [] : {});
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }

        /**
         * The base implementation of `setData` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };

        /**
         * The base implementation of `setToString` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, 'toString', {
            'configurable': true,
            'enumerable': false,
            'value': constant(string),
            'writable': true
          });
        };

        /**
         * The base implementation of `_.shuffle`.
         *
         * @private
         * @param {Array|Object} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         */
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }

        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;

          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;

          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }

        /**
         * The base implementation of `_.some` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function baseSome(collection, predicate) {
          var result;

          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }

        /**
         * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
         * performs a binary search of `array` to determine the index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function baseSortedIndex(array, value, retHighest) {
          var low = 0,
              high = array == null ? low : array.length;

          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];

              if (computed !== null && !isSymbol(computed) &&
                  (retHighest ? (computed <= value) : (computed < value))) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }

        /**
         * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
         * which invokes `iteratee` for `value` and each element of `array` to compute
         * their sort ranking. The iteratee is invoked with one argument; (value).
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} iteratee The iteratee invoked per element.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function baseSortedIndexBy(array, value, iteratee, retHighest) {
          var low = 0,
              high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }

          value = iteratee(value);
          var valIsNaN = value !== value,
              valIsNull = value === null,
              valIsSymbol = isSymbol(value),
              valIsUndefined = value === undefined$1;

          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                othIsDefined = computed !== undefined$1,
                othIsNull = computed === null,
                othIsReflexive = computed === computed,
                othIsSymbol = isSymbol(computed);

            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }

        /**
         * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
         * support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseSortedUniq(array, iteratee) {
          var index = -1,
              length = array.length,
              resIndex = 0,
              result = [];

          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.toNumber` which doesn't ensure correct
         * conversions of binary, hexadecimal, or octal string values.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         */
        function baseToNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }

        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value == 'string') {
            return value;
          }
          if (isArray(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap(value, baseToString) + '';
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : '';
          }
          var result = (value + '');
          return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }

        /**
         * The base implementation of `_.uniqBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseUniq(array, iteratee, comparator) {
          var index = -1,
              includes = arrayIncludes,
              length = array.length,
              isCommon = true,
              result = [],
              seen = result;

          if (comparator) {
            isCommon = false;
            includes = arrayIncludesWith;
          }
          else if (length >= LARGE_ARRAY_SIZE) {
            var set = iteratee ? null : createSet(array);
            if (set) {
              return setToArray(set);
            }
            isCommon = false;
            includes = cacheHas;
            seen = new SetCache;
          }
          else {
            seen = iteratee ? [] : result;
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            value = (comparator || value !== 0) ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            }
            else if (!includes(seen, computed, comparator)) {
              if (seen !== result) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.unset`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The property path to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         */
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }

        /**
         * The base implementation of `_.update`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to update.
         * @param {Function} updater The function to produce the updated value.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }

        /**
         * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
         * without support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {Function} predicate The function invoked per iteration.
         * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;

          while ((fromRight ? index-- : ++index < length) &&
            predicate(array[index], index, array)) {}

          return isDrop
            ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
            : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }

        /**
         * The base implementation of `wrapperValue` which returns the result of
         * performing a sequence of actions on the unwrapped `value`, where each
         * successive action is supplied the return value of the previous.
         *
         * @private
         * @param {*} value The unwrapped value.
         * @param {Array} actions Actions to perform to resolve the unwrapped value.
         * @returns {*} Returns the resolved value.
         */
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          return arrayReduce(actions, function(result, action) {
            return action.func.apply(action.thisArg, arrayPush([result], action.args));
          }, result);
        }

        /**
         * The base implementation of methods like `_.xor`, without support for
         * iteratee shorthands, that accepts an array of arrays to inspect.
         *
         * @private
         * @param {Array} arrays The arrays to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of values.
         */
        function baseXor(arrays, iteratee, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1,
              result = Array(length);

          while (++index < length) {
            var array = arrays[index],
                othIndex = -1;

            while (++othIndex < length) {
              if (othIndex != index) {
                result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result, 1), iteratee, comparator);
        }

        /**
         * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
         *
         * @private
         * @param {Array} props The property identifiers.
         * @param {Array} values The property values.
         * @param {Function} assignFunc The function to assign values.
         * @returns {Object} Returns the new object.
         */
        function baseZipObject(props, values, assignFunc) {
          var index = -1,
              length = props.length,
              valsLength = values.length,
              result = {};

          while (++index < length) {
            var value = index < valsLength ? values[index] : undefined$1;
            assignFunc(result, props[index], value);
          }
          return result;
        }

        /**
         * Casts `value` to an empty array if it's not an array like object.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Array|Object} Returns the cast array-like object.
         */
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }

        /**
         * Casts `value` to `identity` if it's not a function.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Function} Returns cast function.
         */
        function castFunction(value) {
          return typeof value == 'function' ? value : identity;
        }

        /**
         * Casts `value` to a path array if it's not one.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {Object} [object] The object to query keys on.
         * @returns {Array} Returns the cast property path array.
         */
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }

        /**
         * A `baseRest` alias which can be replaced with `identity` by module
         * replacement plugins.
         *
         * @private
         * @type {Function}
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */
        var castRest = baseRest;

        /**
         * Casts `array` to a slice if it's needed.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {number} start The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the cast slice.
         */
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined$1 ? length : end;
          return (!start && end >= length) ? array : baseSlice(array, start, end);
        }

        /**
         * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
         *
         * @private
         * @param {number|Object} id The timer id or timeout object of the timer to clear.
         */
        var clearTimeout = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };

        /**
         * Creates a clone of  `buffer`.
         *
         * @private
         * @param {Buffer} buffer The buffer to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Buffer} Returns the cloned buffer.
         */
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length,
              result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

          buffer.copy(result);
          return result;
        }

        /**
         * Creates a clone of `arrayBuffer`.
         *
         * @private
         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */
        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result).set(new Uint8Array(arrayBuffer));
          return result;
        }

        /**
         * Creates a clone of `dataView`.
         *
         * @private
         * @param {Object} dataView The data view to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned data view.
         */
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }

        /**
         * Creates a clone of `regexp`.
         *
         * @private
         * @param {Object} regexp The regexp to clone.
         * @returns {Object} Returns the cloned regexp.
         */
        function cloneRegExp(regexp) {
          var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result.lastIndex = regexp.lastIndex;
          return result;
        }

        /**
         * Creates a clone of the `symbol` object.
         *
         * @private
         * @param {Object} symbol The symbol object to clone.
         * @returns {Object} Returns the cloned symbol object.
         */
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }

        /**
         * Creates a clone of `typedArray`.
         *
         * @private
         * @param {Object} typedArray The typed array to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned typed array.
         */
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }

        /**
         * Compares values to sort them in ascending order.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {number} Returns the sort order indicator for `value`.
         */
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1,
                valIsNull = value === null,
                valIsReflexive = value === value,
                valIsSymbol = isSymbol(value);

            var othIsDefined = other !== undefined$1,
                othIsNull = other === null,
                othIsReflexive = other === other,
                othIsSymbol = isSymbol(other);

            if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
                (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
                (valIsNull && othIsDefined && othIsReflexive) ||
                (!valIsDefined && othIsReflexive) ||
                !valIsReflexive) {
              return 1;
            }
            if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
                (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
                (othIsNull && valIsDefined && valIsReflexive) ||
                (!othIsDefined && valIsReflexive) ||
                !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }

        /**
         * Used by `_.orderBy` to compare multiple properties of a value to another
         * and stable sort them.
         *
         * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
         * specify an order of "desc" for descending or "asc" for ascending sort order
         * of corresponding values.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {boolean[]|string[]} orders The order to sort by for each property.
         * @returns {number} Returns the sort order indicator for `object`.
         */
        function compareMultiple(object, other, orders) {
          var index = -1,
              objCriteria = object.criteria,
              othCriteria = other.criteria,
              length = objCriteria.length,
              ordersLength = orders.length;

          while (++index < length) {
            var result = compareAscending(objCriteria[index], othCriteria[index]);
            if (result) {
              if (index >= ordersLength) {
                return result;
              }
              var order = orders[index];
              return result * (order == 'desc' ? -1 : 1);
            }
          }
          // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
          // that causes it, under certain circumstances, to provide the same value for
          // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
          // for more details.
          //
          // This also ensures a stable sort in V8 and other engines.
          // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
          return object.index - other.index;
        }

        /**
         * Creates an array that is the composition of partially applied arguments,
         * placeholders, and provided arguments into a single array of arguments.
         *
         * @private
         * @param {Array} args The provided arguments.
         * @param {Array} partials The arguments to prepend to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @params {boolean} [isCurried] Specify composing for a curried function.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1,
              argsLength = args.length,
              holdersLength = holders.length,
              leftIndex = -1,
              leftLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(leftLength + rangeLength),
              isUncurried = !isCurried;

          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }

        /**
         * This function is like `composeArgs` except that the arguments composition
         * is tailored for `_.partialRight`.
         *
         * @private
         * @param {Array} args The provided arguments.
         * @param {Array} partials The arguments to append to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @params {boolean} [isCurried] Specify composing for a curried function.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1,
              argsLength = args.length,
              holdersIndex = -1,
              holdersLength = holders.length,
              rightIndex = -1,
              rightLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(rangeLength + rightLength),
              isUncurried = !isCurried;

          while (++argsIndex < rangeLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result;
        }

        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function copyArray(source, array) {
          var index = -1,
              length = source.length;

          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }

        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property identifiers to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});

          var index = -1,
              length = props.length;

          while (++index < length) {
            var key = props[index];

            var newValue = customizer
              ? customizer(object[key], source[key], key, object, source)
              : undefined$1;

            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }

        /**
         * Copies own symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }

        /**
         * Copies own and inherited symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }

        /**
         * Creates a function like `_.groupBy`.
         *
         * @private
         * @param {Function} setter The function to set accumulator values.
         * @param {Function} [initializer] The accumulator object initializer.
         * @returns {Function} Returns the new aggregator function.
         */
        function createAggregator(setter, initializer) {
          return function(collection, iteratee) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator,
                accumulator = initializer ? initializer() : {};

            return func(collection, setter, getIteratee(iteratee, 2), accumulator);
          };
        }

        /**
         * Creates a function like `_.assign`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined$1,
                guard = length > 2 ? sources[2] : undefined$1;

            customizer = (assigner.length > 3 && typeof customizer == 'function')
              ? (length--, customizer)
              : undefined$1;

            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined$1 : customizer;
              length = 1;
            }
            object = Object(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }

        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee);
            }
            var length = collection.length,
                index = fromRight ? length : -1,
                iterable = Object(collection);

            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }

        /**
         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length;

            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }

        /**
         * Creates a function that wraps `func` to invoke it with the optional `this`
         * binding of `thisArg`.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG,
              Ctor = createCtor(func);

          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }

        /**
         * Creates a function like `_.lowerFirst`.
         *
         * @private
         * @param {string} methodName The name of the `String` case method to use.
         * @returns {Function} Returns the new case function.
         */
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);

            var strSymbols = hasUnicode(string)
              ? stringToArray(string)
              : undefined$1;

            var chr = strSymbols
              ? strSymbols[0]
              : string.charAt(0);

            var trailing = strSymbols
              ? castSlice(strSymbols, 1).join('')
              : string.slice(1);

            return chr[methodName]() + trailing;
          };
        }

        /**
         * Creates a function like `_.camelCase`.
         *
         * @private
         * @param {Function} callback The function to combine each word.
         * @returns {Function} Returns the new compounder function.
         */
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
          };
        }

        /**
         * Creates a function that produces an instance of `Ctor` regardless of
         * whether it was invoked as part of a `new` expression or by `call` or `apply`.
         *
         * @private
         * @param {Function} Ctor The constructor to wrap.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCtor(Ctor) {
          return function() {
            // Use a `switch` statement to work with class constructors. See
            // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
            // for more details.
            var args = arguments;
            switch (args.length) {
              case 0: return new Ctor;
              case 1: return new Ctor(args[0]);
              case 2: return new Ctor(args[0], args[1]);
              case 3: return new Ctor(args[0], args[1], args[2]);
              case 4: return new Ctor(args[0], args[1], args[2], args[3]);
              case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);

            // Mimic the constructor's `return` behavior.
            // See https://es5.github.io/#x13.2.2 for more details.
            return isObject(result) ? result : thisBinding;
          };
        }

        /**
         * Creates a function that wraps `func` to enable currying.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {number} arity The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);

          function wrapper() {
            var length = arguments.length,
                args = Array(length),
                index = length,
                placeholder = getHolder(wrapper);

            while (index--) {
              args[index] = arguments[index];
            }
            var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
              ? []
              : replaceHolders(args, placeholder);

            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
                args, holders, undefined$1, undefined$1, arity - length);
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }

        /**
         * Creates a `_.find` or `_.findLast` function.
         *
         * @private
         * @param {Function} findIndexFunc The function to find the collection index.
         * @returns {Function} Returns the new find function.
         */
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object(collection);
            if (!isArrayLike(collection)) {
              var iteratee = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) { return iteratee(iterable[key], key, iterable); };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
          };
        }

        /**
         * Creates a `_.flow` or `_.flowRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new flow function.
         */
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length,
                index = length,
                prereq = LodashWrapper.prototype.thru;

            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];

              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined$1;

              if (data && isLaziable(data[0]) &&
                    data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                    !data[4].length && data[9] == 1
                  ) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func))
                  ? wrapper[funcName]()
                  : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];

              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;

              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          });
        }

        /**
         * Creates a function that wraps `func` to invoke it with optional `this`
         * binding of `thisArg`, partial application, and currying.
         *
         * @private
         * @param {Function|string} func The function or method name to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to
         *  the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [partialsRight] The arguments to append to those provided
         *  to the new function.
         * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG,
              isBind = bitmask & WRAP_BIND_FLAG,
              isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
              isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
              isFlip = bitmask & WRAP_FLIP_FLAG,
              Ctor = isBindKey ? undefined$1 : createCtor(func);

          function wrapper() {
            var length = arguments.length,
                args = Array(length),
                index = length;

            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper),
                  holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func, bitmask, createHybrid, wrapper.placeholder, thisArg,
                args, newHolders, argPos, ary, arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;

            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary < length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }

        /**
         * Creates a function like `_.invertBy`.
         *
         * @private
         * @param {Function} setter The function to set accumulator values.
         * @param {Function} toIteratee The function to resolve iteratees.
         * @returns {Function} Returns the new inverter function.
         */
        function createInverter(setter, toIteratee) {
          return function(object, iteratee) {
            return baseInverter(object, setter, toIteratee(iteratee), {});
          };
        }

        /**
         * Creates a function that performs a mathematical operation on two values.
         *
         * @private
         * @param {Function} operator The function to perform the operation.
         * @param {number} [defaultValue] The value used for `undefined` arguments.
         * @returns {Function} Returns the new mathematical operation function.
         */
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result = value;
            }
            if (other !== undefined$1) {
              if (result === undefined$1) {
                return other;
              }
              if (typeof value == 'string' || typeof other == 'string') {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result = operator(value, other);
            }
            return result;
          };
        }

        /**
         * Creates a function like `_.over`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over iteratees.
         * @returns {Function} Returns the new over function.
         */
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee) {
                return apply(iteratee, thisArg, args);
              });
            });
          });
        }

        /**
         * Creates the padding for `string` based on `length`. The `chars` string
         * is truncated if the number of characters exceeds `length`.
         *
         * @private
         * @param {number} length The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padding for `string`.
         */
        function createPadding(length, chars) {
          chars = chars === undefined$1 ? ' ' : baseToString(chars);

          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars)
            ? castSlice(stringToArray(result), 0, length).join('')
            : result.slice(0, length);
        }

        /**
         * Creates a function that wraps `func` to invoke it with the `this` binding
         * of `thisArg` and `partials` prepended to the arguments it receives.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} partials The arguments to prepend to those provided to
         *  the new function.
         * @returns {Function} Returns the new wrapped function.
         */
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG,
              Ctor = createCtor(func);

          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength),
                fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }

        /**
         * Creates a `_.range` or `_.rangeRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new range function.
         */
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
              end = step = undefined$1;
            }
            // Ensure the sign of `-0` is preserved.
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }

        /**
         * Creates a function that performs a relational operation on two values.
         *
         * @private
         * @param {Function} operator The function to perform the operation.
         * @returns {Function} Returns the new relational operation function.
         */
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == 'string' && typeof other == 'string')) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }

        /**
         * Creates a function that wraps `func` to continue currying.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {Function} wrapFunc The function to create the `func` wrapper.
         * @param {*} placeholder The placeholder value.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to
         *  the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG,
              newHolders = isCurry ? holders : undefined$1,
              newHoldersRight = isCurry ? undefined$1 : holders,
              newPartials = isCurry ? partials : undefined$1,
              newPartialsRight = isCurry ? undefined$1 : partials;

          bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
            newHoldersRight, argPos, ary, arity
          ];

          var result = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData(result, newData);
          }
          result.placeholder = placeholder;
          return setWrapToString(result, func, bitmask);
        }

        /**
         * Creates a function like `_.round`.
         *
         * @private
         * @param {string} methodName The name of the `Math` method to use when rounding.
         * @returns {Function} Returns the new round function.
         */
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              // Shift with exponential notation to avoid floating-point issues.
              // See [MDN](https://mdn.io/round#Examples) for more details.
              var pair = (toString(number) + 'e').split('e'),
                  value = func(pair[0] + 'e' + (+pair[1] + precision));

              pair = (toString(value) + 'e').split('e');
              return +(pair[0] + 'e' + (+pair[1] - precision));
            }
            return func(number);
          };
        }

        /**
         * Creates a set object of `values`.
         *
         * @private
         * @param {Array} values The values to add to the set.
         * @returns {Object} Returns the new set.
         */
        var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
          return new Set(values);
        };

        /**
         * Creates a `_.toPairs` or `_.toPairsIn` function.
         *
         * @private
         * @param {Function} keysFunc The function to get the keys of a given object.
         * @returns {Function} Returns the new pairs function.
         */
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }

        /**
         * Creates a function that either curries or invokes `func` with optional
         * `this` binding and partially applied arguments.
         *
         * @private
         * @param {Function|string} func The function or method name to wrap.
         * @param {number} bitmask The bitmask flags.
         *    1 - `_.bind`
         *    2 - `_.bindKey`
         *    4 - `_.curry` or `_.curryRight` of a bound function
         *    8 - `_.curry`
         *   16 - `_.curryRight`
         *   32 - `_.partial`
         *   64 - `_.partialRight`
         *  128 - `_.rearg`
         *  256 - `_.ary`
         *  512 - `_.flip`
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to be partially applied.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined$1;
          }
          ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;

          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;

            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func);

          var newData = [
            func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
            argPos, ary, arity
          ];

          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1
            ? (isBindKey ? 0 : func.length)
            : nativeMax(newData[9] - length, 0);

          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result = createPartial(func, bitmask, thisArg, partials);
          } else {
            result = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result, newData), func, bitmask);
        }

        /**
         * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
         * of source objects to the destination object for all destination properties
         * that resolve to `undefined`.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to assign.
         * @param {Object} object The parent object of `objValue`.
         * @returns {*} Returns the value to assign.
         */
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined$1 ||
              (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            return srcValue;
          }
          return objValue;
        }

        /**
         * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
         * objects into destination objects that are passed thru.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to merge.
         * @param {Object} object The parent object of `objValue`.
         * @param {Object} source The parent object of `srcValue`.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         * @returns {*} Returns the value to assign.
         */
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
            stack['delete'](srcValue);
          }
          return objValue;
        }

        /**
         * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
         * objects.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {string} key The key of the property to inspect.
         * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
         */
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined$1 : value;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `array` and `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              arrLength = array.length,
              othLength = other.length;

          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          // Check that cyclic values are equal.
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1,
              result = true,
              seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

          stack.set(array, other);
          stack.set(other, array);

          // Ignore non-index properties.
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index];

            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, arrValue, index, other, array, stack)
                : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (seen) {
              if (!arraySome(other, function(othValue, othIndex) {
                    if (!cacheHas(seen, othIndex) &&
                        (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                      return seen.push(othIndex);
                    }
                  })) {
                result = false;
                break;
              }
            } else if (!(
                  arrValue === othValue ||
                    equalFunc(arrValue, othValue, bitmask, customizer, stack)
                )) {
              result = false;
              break;
            }
          }
          stack['delete'](array);
          stack['delete'](other);
          return result;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if ((object.byteLength != other.byteLength) ||
                  (object.byteOffset != other.byteOffset)) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;

            case arrayBufferTag:
              if ((object.byteLength != other.byteLength) ||
                  !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;

            case boolTag:
            case dateTag:
            case numberTag:
              // Coerce booleans to `1` or `0` and dates to milliseconds.
              // Invalid dates are coerced to `NaN`.
              return eq(+object, +other);

            case errorTag:
              return object.name == other.name && object.message == other.message;

            case regexpTag:
            case stringTag:
              // Coerce regexes to strings and treat strings, primitives and objects,
              // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
              // for more details.
              return object == (other + '');

            case mapTag:
              var convert = mapToArray;

            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);

              if (object.size != other.size && !isPartial) {
                return false;
              }
              // Assume cyclic values are equal.
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;

              // Recursively compare objects (susceptible to call stack limits).
              stack.set(object, other);
              var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack['delete'](object);
              return result;

            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              objProps = getAllKeys(object),
              objLength = objProps.length,
              othProps = getAllKeys(other),
              othLength = othProps.length;

          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          // Check that cyclic values are equal.
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result = true;
          stack.set(object, other);
          stack.set(other, object);

          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key];

            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, objValue, key, other, object, stack)
                : customizer(objValue, othValue, key, object, other, stack);
            }
            // Recursively compare objects (susceptible to call stack limits).
            if (!(compared === undefined$1
                  ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
                  : compared
                )) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;

            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                  typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack['delete'](object);
          stack['delete'](other);
          return result;
        }

        /**
         * A specialized version of `baseRest` which flattens the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + '');
        }

        /**
         * Creates an array of own enumerable property names and symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }

        /**
         * Creates an array of own and inherited enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }

        /**
         * Gets metadata for `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {*} Returns the metadata for `func`.
         */
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };

        /**
         * Gets the name of `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {string} Returns the function name.
         */
        function getFuncName(func) {
          var result = (func.name + ''),
              array = realNames[result],
              length = hasOwnProperty.call(realNames, result) ? array.length : 0;

          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }

        /**
         * Gets the argument placeholder value for `func`.
         *
         * @private
         * @param {Function} func The function to inspect.
         * @returns {*} Returns the placeholder value.
         */
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
          return object.placeholder;
        }

        /**
         * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
         * this function returns the custom method, otherwise it returns `baseIteratee`.
         * If arguments are provided, the chosen function is invoked with them and
         * its result is returned.
         *
         * @private
         * @param {*} [value] The value to convert to an iteratee.
         * @param {number} [arity] The arity of the created iteratee.
         * @returns {Function} Returns the chosen function or its result.
         */
        function getIteratee() {
          var result = lodash.iteratee || iteratee;
          result = result === iteratee ? baseIteratee : result;
          return arguments.length ? result(arguments[0], arguments[1]) : result;
        }

        /**
         * Gets the data for `map`.
         *
         * @private
         * @param {Object} map The map to query.
         * @param {string} key The reference key.
         * @returns {*} Returns the map data.
         */
        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key)
            ? data[typeof key == 'string' ? 'string' : 'hash']
            : data.map;
        }

        /**
         * Gets the property names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData(object) {
          var result = keys(object),
              length = result.length;

          while (length--) {
            var key = result[length],
                value = object[key];

            result[length] = [key, value, isStrictComparable(value)];
          }
          return result;
        }

        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined$1;
        }

        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag),
              tag = value[symToStringTag];

          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e) {}

          var result = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result;
        }

        /**
         * Creates an array of the own enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };

        /**
         * Creates an array of the own and inherited enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result = [];
          while (object) {
            arrayPush(result, getSymbols(object));
            object = getPrototype(object);
          }
          return result;
        };

        /**
         * Gets the `toStringTag` of `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        var getTag = baseGetTag;

        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
        if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
            (Map && getTag(new Map) != mapTag) ||
            (Promise && getTag(Promise.resolve()) != promiseTag) ||
            (Set && getTag(new Set) != setTag) ||
            (WeakMap && getTag(new WeakMap) != weakMapTag)) {
          getTag = function(value) {
            var result = baseGetTag(value),
                Ctor = result == objectTag ? value.constructor : undefined$1,
                ctorString = Ctor ? toSource(Ctor) : '';

            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString: return dataViewTag;
                case mapCtorString: return mapTag;
                case promiseCtorString: return promiseTag;
                case setCtorString: return setTag;
                case weakMapCtorString: return weakMapTag;
              }
            }
            return result;
          };
        }

        /**
         * Gets the view, applying any `transforms` to the `start` and `end` positions.
         *
         * @private
         * @param {number} start The start of the view.
         * @param {number} end The end of the view.
         * @param {Array} transforms The transformations to apply to the view.
         * @returns {Object} Returns an object containing the `start` and `end`
         *  positions of the view.
         */
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;

          while (++index < length) {
            var data = transforms[index],
                size = data.size;

            switch (data.type) {
              case 'drop':      start += size; break;
              case 'dropRight': end -= size; break;
              case 'take':      end = nativeMin(end, start + size); break;
              case 'takeRight': start = nativeMax(start, end - size); break;
            }
          }
          return { 'start': start, 'end': end };
        }

        /**
         * Extracts wrapper details from the `source` body comment.
         *
         * @private
         * @param {string} source The source to inspect.
         * @returns {Array} Returns the wrapper details.
         */
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }

        /**
         * Checks if `path` exists on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @param {Function} hasFunc The function to check properties.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         */
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);

          var index = -1,
              length = path.length,
              result = false;

          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result || ++index != length) {
            return result;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) &&
            (isArray(object) || isArguments(object));
        }

        /**
         * Initializes an array clone.
         *
         * @private
         * @param {Array} array The array to clone.
         * @returns {Array} Returns the initialized clone.
         */
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);

          // Add properties assigned by `RegExp#exec`.
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }

        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject(object) {
          return (typeof object.constructor == 'function' && !isPrototype(object))
            ? baseCreate(getPrototype(object))
            : {};
        }

        /**
         * Initializes an object clone based on its `toStringTag`.
         *
         * **Note:** This function only supports cloning values with tags of
         * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
         *
         * @private
         * @param {Object} object The object to clone.
         * @param {string} tag The `toStringTag` of the object to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);

            case boolTag:
            case dateTag:
              return new Ctor(+object);

            case dataViewTag:
              return cloneDataView(object, isDeep);

            case float32Tag: case float64Tag:
            case int8Tag: case int16Tag: case int32Tag:
            case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
              return cloneTypedArray(object, isDeep);

            case mapTag:
              return new Ctor;

            case numberTag:
            case stringTag:
              return new Ctor(object);

            case regexpTag:
              return cloneRegExp(object);

            case setTag:
              return new Ctor;

            case symbolTag:
              return cloneSymbol(object);
          }
        }

        /**
         * Inserts wrapper `details` in a comment at the top of the `source` body.
         *
         * @private
         * @param {string} source The source to modify.
         * @returns {Array} details The details to insert.
         * @returns {string} Returns the modified source.
         */
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
          details = details.join(length > 2 ? ', ' : ' ');
          return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
        }

        /**
         * Checks if `value` is a flattenable `arguments` object or array.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
         */
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) ||
            !!(spreadableSymbol && value && value[spreadableSymbol]);
        }

        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;

          return !!length &&
            (type == 'number' ||
              (type != 'symbol' && reIsUint.test(value))) &&
                (value > -1 && value % 1 == 0 && value < length);
        }

        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
         *  else `false`.
         */
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number'
                ? (isArrayLike(object) && isIndex(index, object.length))
                : (type == 'string' && index in object)
              ) {
            return eq(object[index], value);
          }
          return false;
        }

        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == 'number' || type == 'symbol' || type == 'boolean' ||
              value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
            (object != null && value in Object(object));
        }

        /**
         * Checks if `value` is suitable for use as unique object key.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
         */
        function isKeyable(value) {
          var type = typeof value;
          return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
            ? (value !== '__proto__')
            : (value === null);
        }

        /**
         * Checks if `func` has a lazy counterpart.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
         *  else `false`.
         */
        function isLaziable(func) {
          var funcName = getFuncName(func),
              other = lodash[funcName];

          if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }

        /**
         * Checks if `func` has its source masked.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
         */
        function isMasked(func) {
          return !!maskSrcKey && (maskSrcKey in func);
        }

        /**
         * Checks if `func` is capable of being masked.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
         */
        var isMaskable = coreJsData ? isFunction : stubFalse;

        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */
        function isPrototype(value) {
          var Ctor = value && value.constructor,
              proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

          return value === proto;
        }

        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }

        /**
         * A specialized version of `matchesProperty` for source values suitable
         * for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue &&
              (srcValue !== undefined$1 || (key in Object(object)));
          };
        }

        /**
         * A specialized version of `_.memoize` which clears the memoized function's
         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
         *
         * @private
         * @param {Function} func The function to have its output memoized.
         * @returns {Function} Returns the new memoized function.
         */
        function memoizeCapped(func) {
          var result = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });

          var cache = result.cache;
          return result;
        }

        /**
         * Merges the function metadata of `source` into `data`.
         *
         * Merging metadata reduces the number of wrappers used to invoke a function.
         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
         * may be applied regardless of execution order. Methods like `_.ary` and
         * `_.rearg` modify function arguments, making the order in which they are
         * executed important, preventing the merging of metadata. However, we make
         * an exception for a safe combined case where curried functions have `_.ary`
         * and or `_.rearg` applied.
         *
         * @private
         * @param {Array} data The destination metadata.
         * @param {Array} source The source metadata.
         * @returns {Array} Returns `data`.
         */
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

          var isCombo =
            ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
            ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
            ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

          // Exit early if metadata can't be merged.
          if (!(isCommon || isCombo)) {
            return data;
          }
          // Use source `thisArg` if available.
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            // Set when currying a bound function.
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          // Compose partial arguments.
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          // Compose partial right arguments.
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          // Use source `argPos` if available.
          value = source[7];
          if (value) {
            data[7] = value;
          }
          // Use source `ary` if it's smaller.
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          // Use source `arity` if one is not provided.
          if (data[9] == null) {
            data[9] = source[9];
          }
          // Use source `func` and merge bitmasks.
          data[0] = source[0];
          data[1] = newBitmask;

          return data;
        }

        /**
         * This function is like
         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * except that it includes inherited enumerable properties.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function nativeKeysIn(object) {
          var result = [];
          if (object != null) {
            for (var key in Object(object)) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }

        /**
         * A specialized version of `baseRest` which transforms the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @param {Function} transform The rest array transform.
         * @returns {Function} Returns the new function.
         */
        function overRest(func, start, transform) {
          start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length);

            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform(array);
            return apply(func, this, otherArgs);
          };
        }

        /**
         * Gets the parent value at `path` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path to get the parent value of.
         * @returns {*} Returns the parent value.
         */
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }

        /**
         * Reorder `array` according to the specified indexes where the element at
         * the first index is assigned as the first element, the element at
         * the second index is assigned as the second element, and so on.
         *
         * @private
         * @param {Array} array The array to reorder.
         * @param {Array} indexes The arranged array indexes.
         * @returns {Array} Returns `array`.
         */
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = copyArray(array);

          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
          }
          return array;
        }

        /**
         * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function safeGet(object, key) {
          if (key === 'constructor' && typeof object[key] === 'function') {
            return;
          }

          if (key == '__proto__') {
            return;
          }

          return object[key];
        }

        /**
         * Sets metadata for `func`.
         *
         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
         * period of time, it will trip its breaker and transition to an identity
         * function to avoid garbage collection pauses in V8. See
         * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
         * for more details.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var setData = shortOut(baseSetData);

        /**
         * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @returns {number|Object} Returns the timer id or timeout object.
         */
        var setTimeout = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };

        /**
         * Sets the `toString` method of `func` to return `string`.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var setToString = shortOut(baseSetToString);

        /**
         * Sets the `toString` method of `wrapper` to mimic the source of `reference`
         * with wrapper details in a comment at the top of the source body.
         *
         * @private
         * @param {Function} wrapper The function to modify.
         * @param {Function} reference The reference function.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @returns {Function} Returns `wrapper`.
         */
        function setWrapToString(wrapper, reference, bitmask) {
          var source = (reference + '');
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }

        /**
         * Creates a function that'll short out and invoke `identity` instead
         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
         * milliseconds.
         *
         * @private
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new shortable function.
         */
        function shortOut(func) {
          var count = 0,
              lastCalled = 0;

          return function() {
            var stamp = nativeNow(),
                remaining = HOT_SPAN - (stamp - lastCalled);

            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }

        /**
         * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
         *
         * @private
         * @param {Array} array The array to shuffle.
         * @param {number} [size=array.length] The size of `array`.
         * @returns {Array} Returns `array`.
         */
        function shuffleSelf(array, size) {
          var index = -1,
              length = array.length,
              lastIndex = length - 1;

          size = size === undefined$1 ? length : size;
          while (++index < size) {
            var rand = baseRandom(index, lastIndex),
                value = array[rand];

            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size;
          return array;
        }

        /**
         * Converts `string` to a property path array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the property path array.
         */
        var stringToPath = memoizeCapped(function(string) {
          var result = [];
          if (string.charCodeAt(0) === 46 /* . */) {
            result.push('');
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        });

        /**
         * Converts `value` to a string key if it's not a string or symbol.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {string|symbol} Returns the key.
         */
        function toKey(value) {
          if (typeof value == 'string' || isSymbol(value)) {
            return value;
          }
          var result = (value + '');
          return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }

        /**
         * Converts `func` to its source code.
         *
         * @private
         * @param {Function} func The function to convert.
         * @returns {string} Returns the source code.
         */
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {}
            try {
              return (func + '');
            } catch (e) {}
          }
          return '';
        }

        /**
         * Updates wrapper `details` based on `bitmask` flags.
         *
         * @private
         * @returns {Array} details The details to modify.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @returns {Array} Returns `details`.
         */
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = '_.' + pair[0];
            if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }

        /**
         * Creates a clone of `wrapper`.
         *
         * @private
         * @param {Object} wrapper The wrapper to clone.
         * @returns {Object} Returns the cloned wrapper.
         */
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result.__actions__ = copyArray(wrapper.__actions__);
          result.__index__  = wrapper.__index__;
          result.__values__ = wrapper.__values__;
          return result;
        }

        /*------------------------------------------------------------------------*/

        /**
         * Creates an array of elements split into groups the length of `size`.
         * If `array` can't be split evenly, the final chunk will be the remaining
         * elements.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to process.
         * @param {number} [size=1] The length of each chunk
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the new array of chunks.
         * @example
         *
         * _.chunk(['a', 'b', 'c', 'd'], 2);
         * // => [['a', 'b'], ['c', 'd']]
         *
         * _.chunk(['a', 'b', 'c', 'd'], 3);
         * // => [['a', 'b', 'c'], ['d']]
         */
        function chunk(array, size, guard) {
          if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
            size = 1;
          } else {
            size = nativeMax(toInteger(size), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size < 1) {
            return [];
          }
          var index = 0,
              resIndex = 0,
              result = Array(nativeCeil(length / size));

          while (index < length) {
            result[resIndex++] = baseSlice(array, index, (index += size));
          }
          return result;
        }

        /**
         * Creates an array with all falsey values removed. The values `false`, `null`,
         * `0`, `""`, `undefined`, and `NaN` are falsey.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to compact.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.compact([0, 1, false, 2, '', 3]);
         * // => [1, 2, 3]
         */
        function compact(array) {
          var index = -1,
              length = array == null ? 0 : array.length,
              resIndex = 0,
              result = [];

          while (++index < length) {
            var value = array[index];
            if (value) {
              result[resIndex++] = value;
            }
          }
          return result;
        }

        /**
         * Creates a new array concatenating `array` with any additional arrays
         * and/or values.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to concatenate.
         * @param {...*} [values] The values to concatenate.
         * @returns {Array} Returns the new concatenated array.
         * @example
         *
         * var array = [1];
         * var other = _.concat(array, 2, [3], [[4]]);
         *
         * console.log(other);
         * // => [1, 2, 3, [4]]
         *
         * console.log(array);
         * // => [1]
         */
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array(length - 1),
              array = arguments[0],
              index = length;

          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }

        /**
         * Creates an array of `array` values not included in the other given arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. The order and references of result values are
         * determined by the first array.
         *
         * **Note:** Unlike `_.pullAll`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.without, _.xor
         * @example
         *
         * _.difference([2, 1], [2, 3]);
         * // => [1]
         */
        var difference = baseRest(function(array, values) {
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
            : [];
        });

        /**
         * This method is like `_.difference` except that it accepts `iteratee` which
         * is invoked for each element of `array` and `values` to generate the criterion
         * by which they're compared. The order and references of result values are
         * determined by the first array. The iteratee is invoked with one argument:
         * (value).
         *
         * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        var differenceBy = baseRest(function(array, values) {
          var iteratee = last(values);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined$1;
          }
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
            : [];
        });

        /**
         * This method is like `_.difference` except that it accepts `comparator`
         * which is invoked to compare elements of `array` to `values`. The order and
         * references of result values are determined by the first array. The comparator
         * is invoked with two arguments: (arrVal, othVal).
         *
         * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         *
         * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }]
         */
        var differenceWith = baseRest(function(array, values) {
          var comparator = last(values);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
            : [];
        });

        /**
         * Creates a slice of `array` with `n` elements dropped from the beginning.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.drop([1, 2, 3]);
         * // => [2, 3]
         *
         * _.drop([1, 2, 3], 2);
         * // => [3]
         *
         * _.drop([1, 2, 3], 5);
         * // => []
         *
         * _.drop([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }

        /**
         * Creates a slice of `array` with `n` elements dropped from the end.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropRight([1, 2, 3]);
         * // => [1, 2]
         *
         * _.dropRight([1, 2, 3], 2);
         * // => [1]
         *
         * _.dropRight([1, 2, 3], 5);
         * // => []
         *
         * _.dropRight([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }

        /**
         * Creates a slice of `array` excluding elements dropped from the end.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.dropRightWhile(users, function(o) { return !o.active; });
         * // => objects for ['barney']
         *
         * // The `_.matches` iteratee shorthand.
         * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
         * // => objects for ['barney', 'fred']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.dropRightWhile(users, ['active', false]);
         * // => objects for ['barney']
         *
         * // The `_.property` iteratee shorthand.
         * _.dropRightWhile(users, 'active');
         * // => objects for ['barney', 'fred', 'pebbles']
         */
        function dropRightWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), true, true)
            : [];
        }

        /**
         * Creates a slice of `array` excluding elements dropped from the beginning.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.dropWhile(users, function(o) { return !o.active; });
         * // => objects for ['pebbles']
         *
         * // The `_.matches` iteratee shorthand.
         * _.dropWhile(users, { 'user': 'barney', 'active': false });
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.dropWhile(users, ['active', false]);
         * // => objects for ['pebbles']
         *
         * // The `_.property` iteratee shorthand.
         * _.dropWhile(users, 'active');
         * // => objects for ['barney', 'fred', 'pebbles']
         */
        function dropWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), true)
            : [];
        }

        /**
         * Fills elements of `array` with `value` from `start` up to, but not
         * including, `end`.
         *
         * **Note:** This method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Array
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.fill(array, 'a');
         * console.log(array);
         * // => ['a', 'a', 'a']
         *
         * _.fill(Array(3), 2);
         * // => [2, 2, 2]
         *
         * _.fill([4, 6, 8, 10], '*', 1, 3);
         * // => [4, '*', '*', 10]
         */
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }

        /**
         * This method is like `_.find` except that it returns the index of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.findIndex(users, function(o) { return o.user == 'barney'; });
         * // => 0
         *
         * // The `_.matches` iteratee shorthand.
         * _.findIndex(users, { 'user': 'fred', 'active': false });
         * // => 1
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findIndex(users, ['active', false]);
         * // => 0
         *
         * // The `_.property` iteratee shorthand.
         * _.findIndex(users, 'active');
         * // => 2
         */
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }

        /**
         * This method is like `_.findIndex` except that it iterates over elements
         * of `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=array.length-1] The index to search from.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
         * // => 2
         *
         * // The `_.matches` iteratee shorthand.
         * _.findLastIndex(users, { 'user': 'barney', 'active': true });
         * // => 0
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findLastIndex(users, ['active', false]);
         * // => 2
         *
         * // The `_.property` iteratee shorthand.
         * _.findLastIndex(users, 'active');
         * // => 0
         */
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = fromIndex < 0
              ? nativeMax(length + index, 0)
              : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }

        /**
         * Flattens `array` a single level deep.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, [3, [4]], 5]]);
         * // => [1, 2, [3, [4]], 5]
         */
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }

        /**
         * Recursively flattens `array`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flattenDeep([1, [2, [3, [4]], 5]]);
         * // => [1, 2, 3, 4, 5]
         */
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }

        /**
         * Recursively flatten `array` up to `depth` times.
         *
         * @static
         * @memberOf _
         * @since 4.4.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @param {number} [depth=1] The maximum recursion depth.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * var array = [1, [2, [3, [4]], 5]];
         *
         * _.flattenDepth(array, 1);
         * // => [1, 2, [3, [4]], 5]
         *
         * _.flattenDepth(array, 2);
         * // => [1, 2, 3, [4], 5]
         */
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }

        /**
         * The inverse of `_.toPairs`; this method returns an object composed
         * from key-value `pairs`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} pairs The key-value pairs.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.fromPairs([['a', 1], ['b', 2]]);
         * // => { 'a': 1, 'b': 2 }
         */
        function fromPairs(pairs) {
          var index = -1,
              length = pairs == null ? 0 : pairs.length,
              result = {};

          while (++index < length) {
            var pair = pairs[index];
            result[pair[0]] = pair[1];
          }
          return result;
        }

        /**
         * Gets the first element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @alias first
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the first element of `array`.
         * @example
         *
         * _.head([1, 2, 3]);
         * // => 1
         *
         * _.head([]);
         * // => undefined
         */
        function head(array) {
          return (array && array.length) ? array[0] : undefined$1;
        }

        /**
         * Gets the index at which the first occurrence of `value` is found in `array`
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it's used as the
         * offset from the end of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.indexOf([1, 2, 1, 2], 2);
         * // => 1
         *
         * // Search from the `fromIndex`.
         * _.indexOf([1, 2, 1, 2], 2, 2);
         * // => 3
         */
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }

        /**
         * Gets all but the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.initial([1, 2, 3]);
         * // => [1, 2]
         */
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }

        /**
         * Creates an array of unique values that are included in all given arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. The order and references of result values are
         * determined by the first array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * _.intersection([2, 1], [2, 3]);
         * // => [2]
         */
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped)
            : [];
        });

        /**
         * This method is like `_.intersection` except that it accepts `iteratee`
         * which is invoked for each element of each `arrays` to generate the criterion
         * by which they're compared. The order and references of result values are
         * determined by the first array. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [2.1]
         *
         * // The `_.property` iteratee shorthand.
         * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }]
         */
        var intersectionBy = baseRest(function(arrays) {
          var iteratee = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject);

          if (iteratee === last(mapped)) {
            iteratee = undefined$1;
          } else {
            mapped.pop();
          }
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped, getIteratee(iteratee, 2))
            : [];
        });

        /**
         * This method is like `_.intersection` except that it accepts `comparator`
         * which is invoked to compare elements of `arrays`. The order and references
         * of result values are determined by the first array. The comparator is
         * invoked with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.intersectionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }]
         */
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject);

          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped, undefined$1, comparator)
            : [];
        });

        /**
         * Converts all elements in `array` into a string separated by `separator`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to convert.
         * @param {string} [separator=','] The element separator.
         * @returns {string} Returns the joined string.
         * @example
         *
         * _.join(['a', 'b', 'c'], '~');
         * // => 'a~b~c'
         */
        function join(array, separator) {
          return array == null ? '' : nativeJoin.call(array, separator);
        }

        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined$1;
        }

        /**
         * This method is like `_.indexOf` except that it iterates over elements of
         * `array` from right to left.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=array.length-1] The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.lastIndexOf([1, 2, 1, 2], 2);
         * // => 3
         *
         * // Search from the `fromIndex`.
         * _.lastIndexOf([1, 2, 1, 2], 2, 2);
         * // => 1
         */
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value
            ? strictLastIndexOf(array, value, index)
            : baseFindIndex(array, baseIsNaN, index, true);
        }

        /**
         * Gets the element at index `n` of `array`. If `n` is negative, the nth
         * element from the end is returned.
         *
         * @static
         * @memberOf _
         * @since 4.11.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=0] The index of the element to return.
         * @returns {*} Returns the nth element of `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'd'];
         *
         * _.nth(array, 1);
         * // => 'b'
         *
         * _.nth(array, -2);
         * // => 'c';
         */
        function nth(array, n) {
          return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
        }

        /**
         * Removes all given values from `array` using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
         * to remove elements from an array by predicate.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...*} [values] The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
         *
         * _.pull(array, 'a', 'c');
         * console.log(array);
         * // => ['b', 'b']
         */
        var pull = baseRest(pullAll);

        /**
         * This method is like `_.pull` except that it accepts an array of values to remove.
         *
         * **Note:** Unlike `_.difference`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
         *
         * _.pullAll(array, ['a', 'c']);
         * console.log(array);
         * // => ['b', 'b']
         */
        function pullAll(array, values) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values)
            : array;
        }

        /**
         * This method is like `_.pullAll` except that it accepts `iteratee` which is
         * invoked for each element of `array` and `values` to generate the criterion
         * by which they're compared. The iteratee is invoked with one argument: (value).
         *
         * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
         *
         * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
         * console.log(array);
         * // => [{ 'x': 2 }]
         */
        function pullAllBy(array, values, iteratee) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values, getIteratee(iteratee, 2))
            : array;
        }

        /**
         * This method is like `_.pullAll` except that it accepts `comparator` which
         * is invoked to compare elements of `array` to `values`. The comparator is
         * invoked with two arguments: (arrVal, othVal).
         *
         * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
         *
         * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
         * console.log(array);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
         */
        function pullAllWith(array, values, comparator) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values, undefined$1, comparator)
            : array;
        }

        /**
         * Removes elements from `array` corresponding to `indexes` and returns an
         * array of removed elements.
         *
         * **Note:** Unlike `_.at`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...(number|number[])} [indexes] The indexes of elements to remove.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = ['a', 'b', 'c', 'd'];
         * var pulled = _.pullAt(array, [1, 3]);
         *
         * console.log(array);
         * // => ['a', 'c']
         *
         * console.log(pulled);
         * // => ['b', 'd']
         */
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length,
              result = baseAt(array, indexes);

          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));

          return result;
        });

        /**
         * Removes all elements from `array` that `predicate` returns truthy for
         * and returns an array of the removed elements. The predicate is invoked
         * with three arguments: (value, index, array).
         *
         * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
         * to pull elements from an array by value.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = [1, 2, 3, 4];
         * var evens = _.remove(array, function(n) {
         *   return n % 2 == 0;
         * });
         *
         * console.log(array);
         * // => [1, 3]
         *
         * console.log(evens);
         * // => [2, 4]
         */
        function remove(array, predicate) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;

          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }

        /**
         * Reverses `array` so that the first element becomes the last, the second
         * element becomes the second to last, and so on.
         *
         * **Note:** This method mutates `array` and is based on
         * [`Array#reverse`](https://mdn.io/Array/reverse).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.reverse(array);
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }

        /**
         * Creates a slice of `array` from `start` up to, but not including, `end`.
         *
         * **Note:** This method is used instead of
         * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
         * returned.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$1 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }

        /**
         * Uses a binary search to determine the lowest index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedIndex([30, 50], 40);
         * // => 1
         */
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }

        /**
         * This method is like `_.sortedIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * var objects = [{ 'x': 4 }, { 'x': 5 }];
         *
         * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
         * // => 0
         *
         * // The `_.property` iteratee shorthand.
         * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
         * // => 0
         */
        function sortedIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
        }

        /**
         * This method is like `_.indexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
         * // => 1
         */
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * This method is like `_.sortedIndex` except that it returns the highest
         * index at which `value` should be inserted into `array` in order to
         * maintain its sort order.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
         * // => 4
         */
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }

        /**
         * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * var objects = [{ 'x': 4 }, { 'x': 5 }];
         *
         * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
         * // => 1
         *
         * // The `_.property` iteratee shorthand.
         * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
         * // => 1
         */
        function sortedLastIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
        }

        /**
         * This method is like `_.lastIndexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
         * // => 3
         */
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * This method is like `_.uniq` except that it's designed and optimized
         * for sorted arrays.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniq([1, 1, 2]);
         * // => [1, 2]
         */
        function sortedUniq(array) {
          return (array && array.length)
            ? baseSortedUniq(array)
            : [];
        }

        /**
         * This method is like `_.uniqBy` except that it's designed and optimized
         * for sorted arrays.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
         * // => [1.1, 2.3]
         */
        function sortedUniqBy(array, iteratee) {
          return (array && array.length)
            ? baseSortedUniq(array, getIteratee(iteratee, 2))
            : [];
        }

        /**
         * Gets all but the first element of `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.tail([1, 2, 3]);
         * // => [2, 3]
         */
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }

        /**
         * Creates a slice of `array` with `n` elements taken from the beginning.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.take([1, 2, 3]);
         * // => [1]
         *
         * _.take([1, 2, 3], 2);
         * // => [1, 2]
         *
         * _.take([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.take([1, 2, 3], 0);
         * // => []
         */
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }

        /**
         * Creates a slice of `array` with `n` elements taken from the end.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeRight([1, 2, 3]);
         * // => [3]
         *
         * _.takeRight([1, 2, 3], 2);
         * // => [2, 3]
         *
         * _.takeRight([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.takeRight([1, 2, 3], 0);
         * // => []
         */
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }

        /**
         * Creates a slice of `array` with elements taken from the end. Elements are
         * taken until `predicate` returns falsey. The predicate is invoked with
         * three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.takeRightWhile(users, function(o) { return !o.active; });
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.matches` iteratee shorthand.
         * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
         * // => objects for ['pebbles']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.takeRightWhile(users, ['active', false]);
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.property` iteratee shorthand.
         * _.takeRightWhile(users, 'active');
         * // => []
         */
        function takeRightWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), false, true)
            : [];
        }

        /**
         * Creates a slice of `array` with elements taken from the beginning. Elements
         * are taken until `predicate` returns falsey. The predicate is invoked with
         * three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.takeWhile(users, function(o) { return !o.active; });
         * // => objects for ['barney', 'fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.takeWhile(users, { 'user': 'barney', 'active': false });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.takeWhile(users, ['active', false]);
         * // => objects for ['barney', 'fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.takeWhile(users, 'active');
         * // => []
         */
        function takeWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3))
            : [];
        }

        /**
         * Creates an array of unique values, in order, from all given arrays using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.union([2], [1, 2]);
         * // => [2, 1]
         */
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });

        /**
         * This method is like `_.union` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by
         * which uniqueness is computed. Result values are chosen from the first
         * array in which the value occurs. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.unionBy([2.1], [1.2, 2.3], Math.floor);
         * // => [2.1, 1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        var unionBy = baseRest(function(arrays) {
          var iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined$1;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
        });

        /**
         * This method is like `_.union` except that it accepts `comparator` which
         * is invoked to compare elements of `arrays`. Result values are chosen from
         * the first array in which the value occurs. The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.unionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
        });

        /**
         * Creates a duplicate-free version of an array, using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons, in which only the first occurrence of each element
         * is kept. The order of result values is determined by the order they occur
         * in the array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.uniq([2, 1, 2]);
         * // => [2, 1]
         */
        function uniq(array) {
          return (array && array.length) ? baseUniq(array) : [];
        }

        /**
         * This method is like `_.uniq` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * uniqueness is computed. The order of result values is determined by the
         * order they occur in the array. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
         * // => [2.1, 1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        function uniqBy(array, iteratee) {
          return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
        }

        /**
         * This method is like `_.uniq` except that it accepts `comparator` which
         * is invoked to compare elements of `array`. The order of result values is
         * determined by the order they occur in the array.The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.uniqWith(objects, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
         */
        function uniqWith(array, comparator) {
          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
        }

        /**
         * This method is like `_.zip` except that it accepts an array of grouped
         * elements and creates an array regrouping the elements to their pre-zip
         * configuration.
         *
         * @static
         * @memberOf _
         * @since 1.2.0
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
         * // => [['a', 1, true], ['b', 2, false]]
         *
         * _.unzip(zipped);
         * // => [['a', 'b'], [1, 2], [true, false]]
         */
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }

        /**
         * This method is like `_.unzip` except that it accepts `iteratee` to specify
         * how regrouped values should be combined. The iteratee is invoked with the
         * elements of each group: (...group).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @param {Function} [iteratee=_.identity] The function to combine
         *  regrouped values.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
         * // => [[1, 10, 100], [2, 20, 200]]
         *
         * _.unzipWith(zipped, _.add);
         * // => [3, 30, 300]
         */
        function unzipWith(array, iteratee) {
          if (!(array && array.length)) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          return arrayMap(result, function(group) {
            return apply(iteratee, undefined$1, group);
          });
        }

        /**
         * Creates an array excluding all given values using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.pull`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...*} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.difference, _.xor
         * @example
         *
         * _.without([2, 1, 2, 3], 1, 2);
         * // => [3]
         */
        var without = baseRest(function(array, values) {
          return isArrayLikeObject(array)
            ? baseDifference(array, values)
            : [];
        });

        /**
         * Creates an array of unique values that is the
         * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
         * of the given arrays. The order of result values is determined by the order
         * they occur in the arrays.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.difference, _.without
         * @example
         *
         * _.xor([2, 1], [2, 3]);
         * // => [1, 3]
         */
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });

        /**
         * This method is like `_.xor` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by
         * which by which they're compared. The order of result values is determined
         * by the order they occur in the arrays. The iteratee is invoked with one
         * argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [1.2, 3.4]
         *
         * // The `_.property` iteratee shorthand.
         * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        var xorBy = baseRest(function(arrays) {
          var iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined$1;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
        });

        /**
         * This method is like `_.xor` except that it accepts `comparator` which is
         * invoked to compare elements of `arrays`. The order of result values is
         * determined by the order they occur in the arrays. The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.xorWith(objects, others, _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        });

        /**
         * Creates an array of grouped elements, the first of which contains the
         * first elements of the given arrays, the second of which contains the
         * second elements of the given arrays, and so on.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zip(['a', 'b'], [1, 2], [true, false]);
         * // => [['a', 1, true], ['b', 2, false]]
         */
        var zip = baseRest(unzip);

        /**
         * This method is like `_.fromPairs` except that it accepts two arrays,
         * one of property identifiers and one of corresponding values.
         *
         * @static
         * @memberOf _
         * @since 0.4.0
         * @category Array
         * @param {Array} [props=[]] The property identifiers.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObject(['a', 'b'], [1, 2]);
         * // => { 'a': 1, 'b': 2 }
         */
        function zipObject(props, values) {
          return baseZipObject(props || [], values || [], assignValue);
        }

        /**
         * This method is like `_.zipObject` except that it supports property paths.
         *
         * @static
         * @memberOf _
         * @since 4.1.0
         * @category Array
         * @param {Array} [props=[]] The property identifiers.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
         * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
         */
        function zipObjectDeep(props, values) {
          return baseZipObject(props || [], values || [], baseSet);
        }

        /**
         * This method is like `_.zip` except that it accepts `iteratee` to specify
         * how grouped values should be combined. The iteratee is invoked with the
         * elements of each group: (...group).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @param {Function} [iteratee=_.identity] The function to combine
         *  grouped values.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
         *   return a + b + c;
         * });
         * // => [111, 222]
         */
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length,
              iteratee = length > 1 ? arrays[length - 1] : undefined$1;

          iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
          return unzipWith(arrays, iteratee);
        });

        /*------------------------------------------------------------------------*/

        /**
         * Creates a `lodash` wrapper instance that wraps `value` with explicit method
         * chain sequences enabled. The result of such sequences must be unwrapped
         * with `_#value`.
         *
         * @static
         * @memberOf _
         * @since 1.3.0
         * @category Seq
         * @param {*} value The value to wrap.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36 },
         *   { 'user': 'fred',    'age': 40 },
         *   { 'user': 'pebbles', 'age': 1 }
         * ];
         *
         * var youngest = _
         *   .chain(users)
         *   .sortBy('age')
         *   .map(function(o) {
         *     return o.user + ' is ' + o.age;
         *   })
         *   .head()
         *   .value();
         * // => 'pebbles is 1'
         */
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }

        /**
         * This method invokes `interceptor` and returns `value`. The interceptor
         * is invoked with one argument; (value). The purpose of this method is to
         * "tap into" a method chain sequence in order to modify intermediate results.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns `value`.
         * @example
         *
         * _([1, 2, 3])
         *  .tap(function(array) {
         *    // Mutate input array.
         *    array.pop();
         *  })
         *  .reverse()
         *  .value();
         * // => [2, 1]
         */
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }

        /**
         * This method is like `_.tap` except that it returns the result of `interceptor`.
         * The purpose of this method is to "pass thru" values replacing intermediate
         * results in a method chain sequence.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Seq
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns the result of `interceptor`.
         * @example
         *
         * _('  abc  ')
         *  .chain()
         *  .trim()
         *  .thru(function(value) {
         *    return [value];
         *  })
         *  .value();
         * // => ['abc']
         */
        function thru(value, interceptor) {
          return interceptor(value);
        }

        /**
         * This method is the wrapper version of `_.at`.
         *
         * @name at
         * @memberOf _
         * @since 1.0.0
         * @category Seq
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
         *
         * _(object).at(['a[0].b.c', 'a[1]']).value();
         * // => [3, 4]
         */
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length,
              start = length ? paths[0] : 0,
              value = this.__wrapped__,
              interceptor = function(object) { return baseAt(object, paths); };

          if (length > 1 || this.__actions__.length ||
              !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            'func': thru,
            'args': [interceptor],
            'thisArg': undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined$1);
            }
            return array;
          });
        });

        /**
         * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
         *
         * @name chain
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // A sequence without explicit chaining.
         * _(users).head();
         * // => { 'user': 'barney', 'age': 36 }
         *
         * // A sequence with explicit chaining.
         * _(users)
         *   .chain()
         *   .head()
         *   .pick('user')
         *   .value();
         * // => { 'user': 'barney' }
         */
        function wrapperChain() {
          return chain(this);
        }

        /**
         * Executes the chain sequence and returns the wrapped result.
         *
         * @name commit
         * @memberOf _
         * @since 3.2.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2];
         * var wrapped = _(array).push(3);
         *
         * console.log(array);
         * // => [1, 2]
         *
         * wrapped = wrapped.commit();
         * console.log(array);
         * // => [1, 2, 3]
         *
         * wrapped.last();
         * // => 3
         *
         * console.log(array);
         * // => [1, 2, 3]
         */
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }

        /**
         * Gets the next value on a wrapped object following the
         * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
         *
         * @name next
         * @memberOf _
         * @since 4.0.0
         * @category Seq
         * @returns {Object} Returns the next iterator value.
         * @example
         *
         * var wrapped = _([1, 2]);
         *
         * wrapped.next();
         * // => { 'done': false, 'value': 1 }
         *
         * wrapped.next();
         * // => { 'done': false, 'value': 2 }
         *
         * wrapped.next();
         * // => { 'done': true, 'value': undefined }
         */
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length,
              value = done ? undefined$1 : this.__values__[this.__index__++];

          return { 'done': done, 'value': value };
        }

        /**
         * Enables the wrapper to be iterable.
         *
         * @name Symbol.iterator
         * @memberOf _
         * @since 4.0.0
         * @category Seq
         * @returns {Object} Returns the wrapper object.
         * @example
         *
         * var wrapped = _([1, 2]);
         *
         * wrapped[Symbol.iterator]() === wrapped;
         * // => true
         *
         * Array.from(wrapped);
         * // => [1, 2]
         */
        function wrapperToIterator() {
          return this;
        }

        /**
         * Creates a clone of the chain sequence planting `value` as the wrapped value.
         *
         * @name plant
         * @memberOf _
         * @since 3.2.0
         * @category Seq
         * @param {*} value The value to plant.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var wrapped = _([1, 2]).map(square);
         * var other = wrapped.plant([3, 4]);
         *
         * other.value();
         * // => [9, 16]
         *
         * wrapped.value();
         * // => [1, 4]
         */
        function wrapperPlant(value) {
          var result,
              parent = this;

          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            clone.__index__ = 0;
            clone.__values__ = undefined$1;
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }

        /**
         * This method is the wrapper version of `_.reverse`.
         *
         * **Note:** This method mutates the wrapped array.
         *
         * @name reverse
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _(array).reverse().value()
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              'func': thru,
              'args': [reverse],
              'thisArg': undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }

        /**
         * Executes the chain sequence to resolve the unwrapped value.
         *
         * @name value
         * @memberOf _
         * @since 0.1.0
         * @alias toJSON, valueOf
         * @category Seq
         * @returns {*} Returns the resolved unwrapped value.
         * @example
         *
         * _([1, 2, 3]).value();
         * // => [1, 2, 3]
         */
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The corresponding value of
         * each key is the number of times the key was returned by `iteratee`. The
         * iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.countBy([6.1, 4.2, 6.3], Math.floor);
         * // => { '4': 1, '6': 2 }
         *
         * // The `_.property` iteratee shorthand.
         * _.countBy(['one', 'two', 'three'], 'length');
         * // => { '3': 2, '5': 1 }
         */
        var countBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            ++result[key];
          } else {
            baseAssignValue(result, key, 1);
          }
        });

        /**
         * Checks if `predicate` returns truthy for **all** elements of `collection`.
         * Iteration is stopped once `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index|key, collection).
         *
         * **Note:** This method returns `true` for
         * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
         * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
         * elements of empty collections.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         * @example
         *
         * _.every([true, 1, null, 'yes'], Boolean);
         * // => false
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.every(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.every(users, ['active', false]);
         * // => true
         *
         * // The `_.property` iteratee shorthand.
         * _.every(users, 'active');
         * // => false
         */
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Iterates over elements of `collection`, returning an array of all elements
         * `predicate` returns truthy for. The predicate is invoked with three
         * arguments: (value, index|key, collection).
         *
         * **Note:** Unlike `_.remove`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         * @see _.reject
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * _.filter(users, function(o) { return !o.active; });
         * // => objects for ['fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.filter(users, { 'age': 36, 'active': true });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.filter(users, ['active', false]);
         * // => objects for ['fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.filter(users, 'active');
         * // => objects for ['barney']
         *
         * // Combining several predicates using `_.overEvery` or `_.overSome`.
         * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
         * // => objects for ['fred', 'barney']
         */
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Iterates over elements of `collection`, returning the first element
         * `predicate` returns truthy for. The predicate is invoked with three
         * arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': true },
         *   { 'user': 'fred',    'age': 40, 'active': false },
         *   { 'user': 'pebbles', 'age': 1,  'active': true }
         * ];
         *
         * _.find(users, function(o) { return o.age < 40; });
         * // => object for 'barney'
         *
         * // The `_.matches` iteratee shorthand.
         * _.find(users, { 'age': 1, 'active': true });
         * // => object for 'pebbles'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.find(users, ['active', false]);
         * // => object for 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.find(users, 'active');
         * // => object for 'barney'
         */
        var find = createFind(findIndex);

        /**
         * This method is like `_.find` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=collection.length-1] The index to search from.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * _.findLast([1, 2, 3, 4], function(n) {
         *   return n % 2 == 1;
         * });
         * // => 3
         */
        var findLast = createFind(findLastIndex);

        /**
         * Creates a flattened array of values by running each element in `collection`
         * thru `iteratee` and flattening the mapped results. The iteratee is invoked
         * with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [n, n];
         * }
         *
         * _.flatMap([1, 2], duplicate);
         * // => [1, 1, 2, 2]
         */
        function flatMap(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), 1);
        }

        /**
         * This method is like `_.flatMap` except that it recursively flattens the
         * mapped results.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [[[n, n]]];
         * }
         *
         * _.flatMapDeep([1, 2], duplicate);
         * // => [1, 1, 2, 2]
         */
        function flatMapDeep(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), INFINITY);
        }

        /**
         * This method is like `_.flatMap` except that it recursively flattens the
         * mapped results up to `depth` times.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {number} [depth=1] The maximum recursion depth.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [[[n, n]]];
         * }
         *
         * _.flatMapDepth([1, 2], duplicate, 2);
         * // => [[1, 1], [2, 2]]
         */
        function flatMapDepth(collection, iteratee, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee), depth);
        }

        /**
         * Iterates over elements of `collection` and invokes `iteratee` for each element.
         * The iteratee is invoked with three arguments: (value, index|key, collection).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * **Note:** As with other "Collections" methods, objects with a "length"
         * property are iterated like arrays. To avoid this behavior use `_.forIn`
         * or `_.forOwn` for object iteration.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @alias each
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @see _.forEachRight
         * @example
         *
         * _.forEach([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => Logs `1` then `2`.
         *
         * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forEach(collection, iteratee) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.forEach` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @alias eachRight
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @see _.forEach
         * @example
         *
         * _.forEachRight([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => Logs `2` then `1`.
         */
        function forEachRight(collection, iteratee) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The order of grouped values
         * is determined by the order they occur in `collection`. The corresponding
         * value of each key is an array of elements responsible for generating the
         * key. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.groupBy([6.1, 4.2, 6.3], Math.floor);
         * // => { '4': [4.2], '6': [6.1, 6.3] }
         *
         * // The `_.property` iteratee shorthand.
         * _.groupBy(['one', 'two', 'three'], 'length');
         * // => { '3': ['one', 'two'], '5': ['three'] }
         */
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            baseAssignValue(result, key, [value]);
          }
        });

        /**
         * Checks if `value` is in `collection`. If `collection` is a string, it's
         * checked for a substring of `value`, otherwise
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * is used for equality comparisons. If `fromIndex` is negative, it's used as
         * the offset from the end of `collection`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
         * @returns {boolean} Returns `true` if `value` is found, else `false`.
         * @example
         *
         * _.includes([1, 2, 3], 1);
         * // => true
         *
         * _.includes([1, 2, 3], 1, 2);
         * // => false
         *
         * _.includes({ 'a': 1, 'b': 2 }, 1);
         * // => true
         *
         * _.includes('abcd', 'bc');
         * // => true
         */
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection)
            ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
            : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
        }

        /**
         * Invokes the method at `path` of each element in `collection`, returning
         * an array of the results of each invoked method. Any additional arguments
         * are provided to each invoked method. If `path` is a function, it's invoked
         * for, and `this` bound to, each element in `collection`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Array|Function|string} path The path of the method to invoke or
         *  the function invoked per iteration.
         * @param {...*} [args] The arguments to invoke each method with.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
         * // => [[1, 5, 7], [1, 2, 3]]
         *
         * _.invokeMap([123, 456], String.prototype.split, '');
         * // => [['1', '2', '3'], ['4', '5', '6']]
         */
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              result = isArrayLike(collection) ? Array(collection.length) : [];

          baseEach(collection, function(value) {
            result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result;
        });

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The corresponding value of
         * each key is the last element responsible for generating the key. The
         * iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * var array = [
         *   { 'dir': 'left', 'code': 97 },
         *   { 'dir': 'right', 'code': 100 }
         * ];
         *
         * _.keyBy(array, function(o) {
         *   return String.fromCharCode(o.code);
         * });
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         *
         * _.keyBy(array, 'dir');
         * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
         */
        var keyBy = createAggregator(function(result, value, key) {
          baseAssignValue(result, key, value);
        });

        /**
         * Creates an array of values by running each element in `collection` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
         * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
         * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
         * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * _.map([4, 8], square);
         * // => [16, 64]
         *
         * _.map({ 'a': 4, 'b': 8 }, square);
         * // => [16, 64] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map(collection, iteratee) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.sortBy` except that it allows specifying the sort
         * orders of the iteratees to sort by. If `orders` is unspecified, all values
         * are sorted in ascending order. Otherwise, specify an order of "desc" for
         * descending or "asc" for ascending sort order of corresponding values.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
         *  The iteratees to sort by.
         * @param {string[]} [orders] The sort orders of `iteratees`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 34 },
         *   { 'user': 'fred',   'age': 40 },
         *   { 'user': 'barney', 'age': 36 }
         * ];
         *
         * // Sort by `user` in ascending order and by `age` in descending order.
         * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
         */
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }

        /**
         * Creates an array of elements split into two groups, the first of which
         * contains elements `predicate` returns truthy for, the second of which
         * contains elements `predicate` returns falsey for. The predicate is
         * invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the array of grouped elements.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': false },
         *   { 'user': 'fred',    'age': 40, 'active': true },
         *   { 'user': 'pebbles', 'age': 1,  'active': false }
         * ];
         *
         * _.partition(users, function(o) { return o.active; });
         * // => objects for [['fred'], ['barney', 'pebbles']]
         *
         * // The `_.matches` iteratee shorthand.
         * _.partition(users, { 'age': 1, 'active': false });
         * // => objects for [['pebbles'], ['barney', 'fred']]
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.partition(users, ['active', false]);
         * // => objects for [['barney', 'pebbles'], ['fred']]
         *
         * // The `_.property` iteratee shorthand.
         * _.partition(users, 'active');
         * // => objects for [['fred'], ['barney', 'pebbles']]
         */
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() { return [[], []]; });

        /**
         * Reduces `collection` to a value which is the accumulated result of running
         * each element in `collection` thru `iteratee`, where each successive
         * invocation is supplied the return value of the previous. If `accumulator`
         * is not given, the first element of `collection` is used as the initial
         * value. The iteratee is invoked with four arguments:
         * (accumulator, value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.reduce`, `_.reduceRight`, and `_.transform`.
         *
         * The guarded methods are:
         * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
         * and `sortBy`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @returns {*} Returns the accumulated value.
         * @see _.reduceRight
         * @example
         *
         * _.reduce([1, 2], function(sum, n) {
         *   return sum + n;
         * }, 0);
         * // => 3
         *
         * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         *   return result;
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
         */
        function reduce(collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce,
              initAccum = arguments.length < 3;

          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
        }

        /**
         * This method is like `_.reduce` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @returns {*} Returns the accumulated value.
         * @see _.reduce
         * @example
         *
         * var array = [[0, 1], [2, 3], [4, 5]];
         *
         * _.reduceRight(array, function(flattened, other) {
         *   return flattened.concat(other);
         * }, []);
         * // => [4, 5, 2, 3, 0, 1]
         */
        function reduceRight(collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce,
              initAccum = arguments.length < 3;

          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
        }

        /**
         * The opposite of `_.filter`; this method returns the elements of `collection`
         * that `predicate` does **not** return truthy for.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         * @see _.filter
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': true }
         * ];
         *
         * _.reject(users, function(o) { return !o.active; });
         * // => objects for ['fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.reject(users, { 'age': 40, 'active': true });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.reject(users, ['active', false]);
         * // => objects for ['fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.reject(users, 'active');
         * // => objects for ['barney']
         */
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }

        /**
         * Gets a random element from `collection`.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to sample.
         * @returns {*} Returns the random element.
         * @example
         *
         * _.sample([1, 2, 3, 4]);
         * // => 2
         */
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }

        /**
         * Gets `n` random elements at unique keys from `collection` up to the
         * size of `collection`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to sample.
         * @param {number} [n=1] The number of elements to sample.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the random elements.
         * @example
         *
         * _.sampleSize([1, 2, 3], 2);
         * // => [3, 1]
         *
         * _.sampleSize([1, 2, 3], 4);
         * // => [2, 3, 1]
         */
        function sampleSize(collection, n, guard) {
          if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }

        /**
         * Creates an array of shuffled values, using a version of the
         * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         * @example
         *
         * _.shuffle([1, 2, 3, 4]);
         * // => [4, 1, 3, 2]
         */
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }

        /**
         * Gets the size of `collection` by returning its length for array-like
         * values or the number of own enumerable string keyed properties for objects.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @returns {number} Returns the collection size.
         * @example
         *
         * _.size([1, 2, 3]);
         * // => 3
         *
         * _.size({ 'a': 1, 'b': 2 });
         * // => 2
         *
         * _.size('pebbles');
         * // => 7
         */
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }

        /**
         * Checks if `predicate` returns truthy for **any** element of `collection`.
         * Iteration is stopped once `predicate` returns truthy. The predicate is
         * invoked with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         * @example
         *
         * _.some([null, 0, 'yes', false], Boolean);
         * // => true
         *
         * var users = [
         *   { 'user': 'barney', 'active': true },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.some(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.some(users, ['active', false]);
         * // => true
         *
         * // The `_.property` iteratee shorthand.
         * _.some(users, 'active');
         * // => true
         */
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection thru each iteratee. This method
         * performs a stable sort, that is, it preserves the original sort order of
         * equal elements. The iteratees are invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {...(Function|Function[])} [iteratees=[_.identity]]
         *  The iteratees to sort by.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 30 },
         *   { 'user': 'barney', 'age': 34 }
         * ];
         *
         * _.sortBy(users, [function(o) { return o.user; }]);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
         *
         * _.sortBy(users, ['user', 'age']);
         * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
         */
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });

        /*------------------------------------------------------------------------*/

        /**
         * Gets the timestamp of the number of milliseconds that have elapsed since
         * the Unix epoch (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Date
         * @returns {number} Returns the timestamp.
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => Logs the number of milliseconds it took for the deferred invocation.
         */
        var now = ctxNow || function() {
          return root.Date.now();
        };

        /*------------------------------------------------------------------------*/

        /**
         * The opposite of `_.before`; this method creates a function that invokes
         * `func` once it's called `n` or more times.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {number} n The number of calls before `func` is invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var saves = ['profile', 'settings'];
         *
         * var done = _.after(saves.length, function() {
         *   console.log('done saving!');
         * });
         *
         * _.forEach(saves, function(type) {
         *   asyncSave({ 'type': type, 'complete': done });
         * });
         * // => Logs 'done saving!' after the two async saves have completed.
         */
        function after(n, func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }

        /**
         * Creates a function that invokes `func`, with up to `n` arguments,
         * ignoring any additional arguments.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @param {number} [n=func.length] The arity cap.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new capped function.
         * @example
         *
         * _.map(['6', '8', '10'], _.ary(parseInt, 1));
         * // => [6, 8, 10]
         */
        function ary(func, n, guard) {
          n = guard ? undefined$1 : n;
          n = (func && n == null) ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
        }

        /**
         * Creates a function that invokes `func`, with the `this` binding and arguments
         * of the created function, while it's called less than `n` times. Subsequent
         * calls to the created function return the result of the last `func` invocation.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {number} n The number of calls at which `func` is no longer invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * jQuery(element).on('click', _.before(5, addContactToList));
         * // => Allows adding up to 4 contacts to the list.
         */
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined$1;
            }
            return result;
          };
        }

        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and `partials` prepended to the arguments it receives.
         *
         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for partially applied arguments.
         *
         * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
         * property of bound functions.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * function greet(greeting, punctuation) {
         *   return greeting + ' ' + this.user + punctuation;
         * }
         *
         * var object = { 'user': 'fred' };
         *
         * var bound = _.bind(greet, object, 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * // Bound with placeholders.
         * var bound = _.bind(greet, object, _, '!');
         * bound('hi');
         * // => 'hi fred!'
         */
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });

        /**
         * Creates a function that invokes the method at `object[key]` with `partials`
         * prepended to the arguments it receives.
         *
         * This method differs from `_.bind` by allowing bound functions to reference
         * methods that may be redefined or don't yet exist. See
         * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
         * for more details.
         *
         * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * @static
         * @memberOf _
         * @since 0.10.0
         * @category Function
         * @param {Object} object The object to invoke the method on.
         * @param {string} key The key of the method.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var object = {
         *   'user': 'fred',
         *   'greet': function(greeting, punctuation) {
         *     return greeting + ' ' + this.user + punctuation;
         *   }
         * };
         *
         * var bound = _.bindKey(object, 'greet', 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * object.greet = function(greeting, punctuation) {
         *   return greeting + 'ya ' + this.user + punctuation;
         * };
         *
         * bound('!');
         * // => 'hiya fred!'
         *
         * // Bound with placeholders.
         * var bound = _.bindKey(object, 'greet', _, '!');
         * bound('hi');
         * // => 'hiya fred!'
         */
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });

        /**
         * Creates a function that accepts arguments of `func` and either invokes
         * `func` returning its result, if at least `arity` number of arguments have
         * been provided, or returns a function that accepts the remaining `func`
         * arguments, and so on. The arity of `func` may be specified if `func.length`
         * is not sufficient.
         *
         * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for provided arguments.
         *
         * **Note:** This method doesn't set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curry(abc);
         *
         * curried(1)(2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // Curried with placeholders.
         * curried(1)(_, 3)(2);
         * // => [1, 2, 3]
         */
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result.placeholder = curry.placeholder;
          return result;
        }

        /**
         * This method is like `_.curry` except that arguments are applied to `func`
         * in the manner of `_.partialRight` instead of `_.partial`.
         *
         * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for provided arguments.
         *
         * **Note:** This method doesn't set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curryRight(abc);
         *
         * curried(3)(2)(1);
         * // => [1, 2, 3]
         *
         * curried(2, 3)(1);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // Curried with placeholders.
         * curried(3)(1, _)(2);
         * // => [1, 2, 3]
         */
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result.placeholder = curryRight.placeholder;
          return result;
        }

        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed `func` invocations and a `flush` method to immediately invoke them.
         * Provide `options` to indicate whether `func` should be invoked on the
         * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
         * with the last arguments provided to the debounced function. Subsequent
         * calls to the debounced function return the result of the last `func`
         * invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the debounced function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=false]
         *  Specify invoking on the leading edge of the timeout.
         * @param {number} [options.maxWait]
         *  The maximum time `func` is allowed to be delayed before it's invoked.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // Avoid costly calculations while the window size is in flux.
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // Invoke `sendMail` when clicked, debouncing subsequent calls.
         * jQuery(element).on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', debounced);
         *
         * // Cancel the trailing debounced invocation.
         * jQuery(window).on('popstate', debounced.cancel);
         */
        function debounce(func, wait, options) {
          var lastArgs,
              lastThis,
              maxWait,
              result,
              timerId,
              lastCallTime,
              lastInvokeTime = 0,
              leading = false,
              maxing = false,
              trailing = true;

          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = 'maxWait' in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }

          function invokeFunc(time) {
            var args = lastArgs,
                thisArg = lastThis;

            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
          }

          function leadingEdge(time) {
            // Reset any `maxWait` timer.
            lastInvokeTime = time;
            // Start the timer for the trailing edge.
            timerId = setTimeout(timerExpired, wait);
            // Invoke the leading edge.
            return leading ? invokeFunc(time) : result;
          }

          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime,
                timeWaiting = wait - timeSinceLastCall;

            return maxing
              ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
              : timeWaiting;
          }

          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime;

            // Either this is the first call, activity has stopped and we're at the
            // trailing edge, the system time has gone backwards and we're treating
            // it as the trailing edge, or we've hit the `maxWait` limit.
            return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
              (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
          }

          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            // Restart the timer.
            timerId = setTimeout(timerExpired, remainingWait(time));
          }

          function trailingEdge(time) {
            timerId = undefined$1;

            // Only invoke if we have `lastArgs` which means `func` has been
            // debounced at least once.
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result;
          }

          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }

          function flush() {
            return timerId === undefined$1 ? result : trailingEdge(now());
          }

          function debounced() {
            var time = now(),
                isInvoking = shouldInvoke(time);

            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;

            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                // Handle invocations in a tight loop.
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }

        /**
         * Defers invoking the `func` until the current call stack has cleared. Any
         * additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to defer.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.defer(function(text) {
         *   console.log(text);
         * }, 'deferred');
         * // => Logs 'deferred' after one millisecond.
         */
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });

        /**
         * Invokes `func` after `wait` milliseconds. Any additional arguments are
         * provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.delay(function(text) {
         *   console.log(text);
         * }, 1000, 'later');
         * // => Logs 'later' after one second.
         */
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });

        /**
         * Creates a function that invokes `func` with arguments reversed.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to flip arguments for.
         * @returns {Function} Returns the new flipped function.
         * @example
         *
         * var flipped = _.flip(function() {
         *   return _.toArray(arguments);
         * });
         *
         * flipped('a', 'b', 'c', 'd');
         * // => ['d', 'c', 'b', 'a']
         */
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }

        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided, it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is used as the map cache key. The `func`
         * is invoked with the `this` binding of the memoized function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the
         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoized function.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         * var other = { 'c': 3, 'd': 4 };
         *
         * var values = _.memoize(_.values);
         * values(object);
         * // => [1, 2]
         *
         * values(other);
         * // => [3, 4]
         *
         * object.a = 2;
         * values(object);
         * // => [1, 2]
         *
         * // Modify the result cache.
         * values.cache.set(object, ['a', 'b']);
         * values(object);
         * // => ['a', 'b']
         *
         * // Replace `_.memoize.Cache`.
         * _.memoize.Cache = WeakMap;
         */
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;

            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result) || cache;
            return result;
          };
          memoized.cache = new (memoize.Cache || MapCache);
          return memoized;
        }

        // Expose `MapCache`.
        memoize.Cache = MapCache;

        /**
         * Creates a function that negates the result of the predicate `func`. The
         * `func` predicate is invoked with the `this` binding and arguments of the
         * created function.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} predicate The predicate to negate.
         * @returns {Function} Returns the new negated function.
         * @example
         *
         * function isEven(n) {
         *   return n % 2 == 0;
         * }
         *
         * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
         * // => [1, 3, 5]
         */
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0: return !predicate.call(this);
              case 1: return !predicate.call(this, args[0]);
              case 2: return !predicate.call(this, args[0], args[1]);
              case 3: return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }

        /**
         * Creates a function that is restricted to invoking `func` once. Repeat calls
         * to the function return the value of the first invocation. The `func` is
         * invoked with the `this` binding and arguments of the created function.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var initialize = _.once(createApplication);
         * initialize();
         * initialize();
         * // => `createApplication` is invoked once
         */
        function once(func) {
          return before(2, func);
        }

        /**
         * Creates a function that invokes `func` with its arguments transformed.
         *
         * @static
         * @since 4.0.0
         * @memberOf _
         * @category Function
         * @param {Function} func The function to wrap.
         * @param {...(Function|Function[])} [transforms=[_.identity]]
         *  The argument transforms.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function doubled(n) {
         *   return n * 2;
         * }
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var func = _.overArgs(function(x, y) {
         *   return [x, y];
         * }, [square, doubled]);
         *
         * func(9, 3);
         * // => [81, 6]
         *
         * func(10, 5);
         * // => [100, 10]
         */
        var overArgs = castRest(function(func, transforms) {
          transforms = (transforms.length == 1 && isArray(transforms[0]))
            ? arrayMap(transforms[0], baseUnary(getIteratee()))
            : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1,
                length = nativeMin(args.length, funcsLength);

            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });

        /**
         * Creates a function that invokes `func` with `partials` prepended to the
         * arguments it receives. This method is like `_.bind` except it does **not**
         * alter the `this` binding.
         *
         * The `_.partial.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method doesn't set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @since 0.2.0
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * function greet(greeting, name) {
         *   return greeting + ' ' + name;
         * }
         *
         * var sayHelloTo = _.partial(greet, 'hello');
         * sayHelloTo('fred');
         * // => 'hello fred'
         *
         * // Partially applied with placeholders.
         * var greetFred = _.partial(greet, _, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         */
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });

        /**
         * This method is like `_.partial` except that partially applied arguments
         * are appended to the arguments it receives.
         *
         * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method doesn't set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * function greet(greeting, name) {
         *   return greeting + ' ' + name;
         * }
         *
         * var greetFred = _.partialRight(greet, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         *
         * // Partially applied with placeholders.
         * var sayHelloTo = _.partialRight(greet, 'hello', _);
         * sayHelloTo('fred');
         * // => 'hello fred'
         */
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });

        /**
         * Creates a function that invokes `func` with arguments arranged according
         * to the specified `indexes` where the argument value at the first index is
         * provided as the first argument, the argument value at the second index is
         * provided as the second argument, and so on.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to rearrange arguments for.
         * @param {...(number|number[])} indexes The arranged argument indexes.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var rearged = _.rearg(function(a, b, c) {
         *   return [a, b, c];
         * }, [2, 0, 1]);
         *
         * rearged('b', 'c', 'a')
         * // => ['a', 'b', 'c']
         */
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });

        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * created function and arguments from `start` and beyond provided as
         * an array.
         *
         * **Note:** This method is based on the
         * [rest parameter](https://mdn.io/rest_parameters).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.rest(function(what, names) {
         *   return what + ' ' + _.initial(names).join(', ') +
         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
         * });
         *
         * say('hello', 'fred', 'barney', 'pebbles');
         * // => 'hello fred, barney, & pebbles'
         */
        function rest(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start === undefined$1 ? start : toInteger(start);
          return baseRest(func, start);
        }

        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * create function and an array of arguments much like
         * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
         *
         * **Note:** This method is based on the
         * [spread operator](https://mdn.io/spread_operator).
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Function
         * @param {Function} func The function to spread arguments over.
         * @param {number} [start=0] The start position of the spread.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.spread(function(who, what) {
         *   return who + ' says ' + what;
         * });
         *
         * say(['fred', 'hello']);
         * // => 'fred says hello'
         *
         * var numbers = Promise.all([
         *   Promise.resolve(40),
         *   Promise.resolve(36)
         * ]);
         *
         * numbers.then(_.spread(function(x, y) {
         *   return x + y;
         * }));
         * // => a Promise of 76
         */
        function spread(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start],
                otherArgs = castSlice(args, 0, start);

            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }

        /**
         * Creates a throttled function that only invokes `func` at most once per
         * every `wait` milliseconds. The throttled function comes with a `cancel`
         * method to cancel delayed `func` invocations and a `flush` method to
         * immediately invoke them. Provide `options` to indicate whether `func`
         * should be invoked on the leading and/or trailing edge of the `wait`
         * timeout. The `func` is invoked with the last arguments provided to the
         * throttled function. Subsequent calls to the throttled function return the
         * result of the last `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the throttled function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.throttle` and `_.debounce`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to throttle.
         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=true]
         *  Specify invoking on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         * @example
         *
         * // Avoid excessively updating the position while scrolling.
         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
         *
         * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
         * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
         * jQuery(element).on('click', throttled);
         *
         * // Cancel the trailing throttled invocation.
         * jQuery(window).on('popstate', throttled.cancel);
         */
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;

          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            'leading': leading,
            'maxWait': wait,
            'trailing': trailing
          });
        }

        /**
         * Creates a function that accepts up to one argument, ignoring any
         * additional arguments.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         * @example
         *
         * _.map(['6', '8', '10'], _.unary(parseInt));
         * // => [6, 8, 10]
         */
        function unary(func) {
          return ary(func, 1);
        }

        /**
         * Creates a function that provides `value` to `wrapper` as its first
         * argument. Any additional arguments provided to the function are appended
         * to those provided to the `wrapper`. The wrapper is invoked with the `this`
         * binding of the created function.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {*} value The value to wrap.
         * @param {Function} [wrapper=identity] The wrapper function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var p = _.wrap(_.escape, function(func, text) {
         *   return '<p>' + func(text) + '</p>';
         * });
         *
         * p('fred, barney, & pebbles');
         * // => '<p>fred, barney, &amp; pebbles</p>'
         */
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Casts `value` as an array if it's not one.
         *
         * @static
         * @memberOf _
         * @since 4.4.0
         * @category Lang
         * @param {*} value The value to inspect.
         * @returns {Array} Returns the cast array.
         * @example
         *
         * _.castArray(1);
         * // => [1]
         *
         * _.castArray({ 'a': 1 });
         * // => [{ 'a': 1 }]
         *
         * _.castArray('abc');
         * // => ['abc']
         *
         * _.castArray(null);
         * // => [null]
         *
         * _.castArray(undefined);
         * // => [undefined]
         *
         * _.castArray();
         * // => []
         *
         * var array = [1, 2, 3];
         * console.log(_.castArray(array) === array);
         * // => true
         */
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }

        /**
         * Creates a shallow clone of `value`.
         *
         * **Note:** This method is loosely based on the
         * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
         * and supports cloning arrays, array buffers, booleans, date objects, maps,
         * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
         * arrays. The own enumerable properties of `arguments` objects are cloned
         * as plain objects. An empty object is returned for uncloneable values such
         * as error objects, functions, DOM nodes, and WeakMaps.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to clone.
         * @returns {*} Returns the cloned value.
         * @see _.cloneDeep
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var shallow = _.clone(objects);
         * console.log(shallow[0] === objects[0]);
         * // => true
         */
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }

        /**
         * This method is like `_.clone` except that it accepts `customizer` which
         * is invoked to produce the cloned value. If `customizer` returns `undefined`,
         * cloning is handled by the method instead. The `customizer` is invoked with
         * up to four arguments; (value [, index|key, object, stack]).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to clone.
         * @param {Function} [customizer] The function to customize cloning.
         * @returns {*} Returns the cloned value.
         * @see _.cloneDeepWith
         * @example
         *
         * function customizer(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(false);
         *   }
         * }
         *
         * var el = _.cloneWith(document.body, customizer);
         *
         * console.log(el === document.body);
         * // => false
         * console.log(el.nodeName);
         * // => 'BODY'
         * console.log(el.childNodes.length);
         * // => 0
         */
        function cloneWith(value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }

        /**
         * This method is like `_.clone` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @returns {*} Returns the deep cloned value.
         * @see _.clone
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var deep = _.cloneDeep(objects);
         * console.log(deep[0] === objects[0]);
         * // => false
         */
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }

        /**
         * This method is like `_.cloneWith` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @param {Function} [customizer] The function to customize cloning.
         * @returns {*} Returns the deep cloned value.
         * @see _.cloneWith
         * @example
         *
         * function customizer(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(true);
         *   }
         * }
         *
         * var el = _.cloneDeepWith(document.body, customizer);
         *
         * console.log(el === document.body);
         * // => false
         * console.log(el.nodeName);
         * // => 'BODY'
         * console.log(el.childNodes.length);
         * // => 20
         */
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }

        /**
         * Checks if `object` conforms to `source` by invoking the predicate
         * properties of `source` with the corresponding property values of `object`.
         *
         * **Note:** This method is equivalent to `_.conforms` when `source` is
         * partially applied.
         *
         * @static
         * @memberOf _
         * @since 4.14.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property predicates to conform to.
         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         *
         * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
         * // => true
         *
         * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
         * // => false
         */
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }

        /**
         * Performs a
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */
        function eq(value, other) {
          return value === other || (value !== value && other !== other);
        }

        /**
         * Checks if `value` is greater than `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`,
         *  else `false`.
         * @see _.lt
         * @example
         *
         * _.gt(3, 1);
         * // => true
         *
         * _.gt(3, 3);
         * // => false
         *
         * _.gt(1, 3);
         * // => false
         */
        var gt = createRelationalOperation(baseGt);

        /**
         * Checks if `value` is greater than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than or equal to
         *  `other`, else `false`.
         * @see _.lte
         * @example
         *
         * _.gte(3, 1);
         * // => true
         *
         * _.gte(3, 3);
         * // => true
         *
         * _.gte(1, 3);
         * // => false
         */
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });

        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         *  else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
            !propertyIsEnumerable.call(value, 'callee');
        };

        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */
        var isArray = Array.isArray;

        /**
         * Checks if `value` is classified as an `ArrayBuffer` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
         * @example
         *
         * _.isArrayBuffer(new ArrayBuffer(2));
         * // => true
         *
         * _.isArrayBuffer(new Array(2));
         * // => false
         */
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }

        /**
         * This method is like `_.isArrayLike` except that it also checks if `value`
         * is an object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array-like object,
         *  else `false`.
         * @example
         *
         * _.isArrayLikeObject([1, 2, 3]);
         * // => true
         *
         * _.isArrayLikeObject(document.body.children);
         * // => true
         *
         * _.isArrayLikeObject('abc');
         * // => false
         *
         * _.isArrayLikeObject(_.noop);
         * // => false
         */
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }

        /**
         * Checks if `value` is classified as a boolean primitive or object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
         * @example
         *
         * _.isBoolean(false);
         * // => true
         *
         * _.isBoolean(null);
         * // => false
         */
        function isBoolean(value) {
          return value === true || value === false ||
            (isObjectLike(value) && baseGetTag(value) == boolTag);
        }

        /**
         * Checks if `value` is a buffer.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
         * @example
         *
         * _.isBuffer(new Buffer(2));
         * // => true
         *
         * _.isBuffer(new Uint8Array(2));
         * // => false
         */
        var isBuffer = nativeIsBuffer || stubFalse;

        /**
         * Checks if `value` is classified as a `Date` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
         * @example
         *
         * _.isDate(new Date);
         * // => true
         *
         * _.isDate('Mon April 23 2012');
         * // => false
         */
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

        /**
         * Checks if `value` is likely a DOM element.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
         * @example
         *
         * _.isElement(document.body);
         * // => true
         *
         * _.isElement('<body>');
         * // => false
         */
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }

        /**
         * Checks if `value` is an empty object, collection, map, or set.
         *
         * Objects are considered empty if they have no own enumerable string keyed
         * properties.
         *
         * Array-like values such as `arguments` objects, arrays, buffers, strings, or
         * jQuery-like collections are considered empty if they have a `length` of `0`.
         * Similarly, maps and sets are considered empty if they have a `size` of `0`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is empty, else `false`.
         * @example
         *
         * _.isEmpty(null);
         * // => true
         *
         * _.isEmpty(true);
         * // => true
         *
         * _.isEmpty(1);
         * // => true
         *
         * _.isEmpty([1, 2, 3]);
         * // => false
         *
         * _.isEmpty({ 'a': 1 });
         * // => false
         */
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) &&
              (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
                isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }

        /**
         * Performs a deep comparison between two values to determine if they are
         * equivalent.
         *
         * **Note:** This method supports comparing arrays, array buffers, booleans,
         * date objects, error objects, maps, numbers, `Object` objects, regexes,
         * sets, strings, symbols, and typed arrays. `Object` objects are compared
         * by their own, not inherited, enumerable properties. Functions and DOM
         * nodes are compared by strict equality, i.e. `===`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.isEqual(object, other);
         * // => true
         *
         * object === other;
         * // => false
         */
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }

        /**
         * This method is like `_.isEqual` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
         * are handled by the method instead. The `customizer` is invoked with up to
         * six arguments: (objValue, othValue [, index|key, object, other, stack]).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, othValue) {
         *   if (isGreeting(objValue) && isGreeting(othValue)) {
         *     return true;
         *   }
         * }
         *
         * var array = ['hello', 'goodbye'];
         * var other = ['hi', 'goodbye'];
         *
         * _.isEqualWith(array, other, customizer);
         * // => true
         */
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          var result = customizer ? customizer(value, other) : undefined$1;
          return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
        }

        /**
         * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
         * `SyntaxError`, `TypeError`, or `URIError` object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
         * @example
         *
         * _.isError(new Error);
         * // => true
         *
         * _.isError(Error);
         * // => false
         */
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag ||
            (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
        }

        /**
         * Checks if `value` is a finite primitive number.
         *
         * **Note:** This method is based on
         * [`Number.isFinite`](https://mdn.io/Number/isFinite).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
         * @example
         *
         * _.isFinite(3);
         * // => true
         *
         * _.isFinite(Number.MIN_VALUE);
         * // => true
         *
         * _.isFinite(Infinity);
         * // => false
         *
         * _.isFinite('3');
         * // => false
         */
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }

        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          // The use of `Object#toString` avoids issues with the `typeof` operator
          // in Safari 9 which returns 'object' for typed arrays and other constructors.
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }

        /**
         * Checks if `value` is an integer.
         *
         * **Note:** This method is based on
         * [`Number.isInteger`](https://mdn.io/Number/isInteger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
         * @example
         *
         * _.isInteger(3);
         * // => true
         *
         * _.isInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isInteger(Infinity);
         * // => false
         *
         * _.isInteger('3');
         * // => false
         */
        function isInteger(value) {
          return typeof value == 'number' && value == toInteger(value);
        }

        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This method is loosely based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */
        function isLength(value) {
          return typeof value == 'number' &&
            value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }

        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == 'object' || type == 'function');
        }

        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike(value) {
          return value != null && typeof value == 'object';
        }

        /**
         * Checks if `value` is classified as a `Map` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         * @example
         *
         * _.isMap(new Map);
         * // => true
         *
         * _.isMap(new WeakMap);
         * // => false
         */
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

        /**
         * Performs a partial deep comparison between `object` and `source` to
         * determine if `object` contains equivalent property values.
         *
         * **Note:** This method is equivalent to `_.matches` when `source` is
         * partially applied.
         *
         * Partial comparisons will match empty array and empty object `source`
         * values against any array or object value, respectively. See `_.isEqual`
         * for a list of supported value comparisons.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         *
         * _.isMatch(object, { 'b': 2 });
         * // => true
         *
         * _.isMatch(object, { 'b': 1 });
         * // => false
         */
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }

        /**
         * This method is like `_.isMatch` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
         * are handled by the method instead. The `customizer` is invoked with five
         * arguments: (objValue, srcValue, index|key, object, source).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, srcValue) {
         *   if (isGreeting(objValue) && isGreeting(srcValue)) {
         *     return true;
         *   }
         * }
         *
         * var object = { 'greeting': 'hello' };
         * var source = { 'greeting': 'hi' };
         *
         * _.isMatchWith(object, source, customizer);
         * // => true
         */
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }

        /**
         * Checks if `value` is `NaN`.
         *
         * **Note:** This method is based on
         * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
         * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
         * `undefined` and other non-number values.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
         * @example
         *
         * _.isNaN(NaN);
         * // => true
         *
         * _.isNaN(new Number(NaN));
         * // => true
         *
         * isNaN(undefined);
         * // => true
         *
         * _.isNaN(undefined);
         * // => false
         */
        function isNaN(value) {
          // An `NaN` primitive is the only value that is not equal to itself.
          // Perform the `toStringTag` check first to avoid errors with some
          // ActiveX objects in IE.
          return isNumber(value) && value != +value;
        }

        /**
         * Checks if `value` is a pristine native function.
         *
         * **Note:** This method can't reliably detect native functions in the presence
         * of the core-js package because core-js circumvents this kind of detection.
         * Despite multiple requests, the core-js maintainer has made it clear: any
         * attempt to fix the detection will be obstructed. As a result, we're left
         * with little choice but to throw an error. Unfortunately, this also affects
         * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
         * which rely on core-js.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         * @example
         *
         * _.isNative(Array.prototype.push);
         * // => true
         *
         * _.isNative(_);
         * // => false
         */
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }

        /**
         * Checks if `value` is `null`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
         * @example
         *
         * _.isNull(null);
         * // => true
         *
         * _.isNull(void 0);
         * // => false
         */
        function isNull(value) {
          return value === null;
        }

        /**
         * Checks if `value` is `null` or `undefined`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
         * @example
         *
         * _.isNil(null);
         * // => true
         *
         * _.isNil(void 0);
         * // => true
         *
         * _.isNil(NaN);
         * // => false
         */
        function isNil(value) {
          return value == null;
        }

        /**
         * Checks if `value` is classified as a `Number` primitive or object.
         *
         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
         * classified as numbers, use the `_.isFinite` method.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a number, else `false`.
         * @example
         *
         * _.isNumber(3);
         * // => true
         *
         * _.isNumber(Number.MIN_VALUE);
         * // => true
         *
         * _.isNumber(Infinity);
         * // => true
         *
         * _.isNumber('3');
         * // => false
         */
        function isNumber(value) {
          return typeof value == 'number' ||
            (isObjectLike(value) && baseGetTag(value) == numberTag);
        }

        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @since 0.8.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
          return typeof Ctor == 'function' && Ctor instanceof Ctor &&
            funcToString.call(Ctor) == objectCtorString;
        }

        /**
         * Checks if `value` is classified as a `RegExp` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
         * @example
         *
         * _.isRegExp(/abc/);
         * // => true
         *
         * _.isRegExp('/abc/');
         * // => false
         */
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

        /**
         * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
         * double precision number which isn't the result of a rounded unsafe integer.
         *
         * **Note:** This method is based on
         * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
         * @example
         *
         * _.isSafeInteger(3);
         * // => true
         *
         * _.isSafeInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isSafeInteger(Infinity);
         * // => false
         *
         * _.isSafeInteger('3');
         * // => false
         */
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }

        /**
         * Checks if `value` is classified as a `Set` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         * @example
         *
         * _.isSet(new Set);
         * // => true
         *
         * _.isSet(new WeakSet);
         * // => false
         */
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

        /**
         * Checks if `value` is classified as a `String` primitive or object.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a string, else `false`.
         * @example
         *
         * _.isString('abc');
         * // => true
         *
         * _.isString(1);
         * // => false
         */
        function isString(value) {
          return typeof value == 'string' ||
            (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
        }

        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        function isSymbol(value) {
          return typeof value == 'symbol' ||
            (isObjectLike(value) && baseGetTag(value) == symbolTag);
        }

        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

        /**
         * Checks if `value` is `undefined`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
         * @example
         *
         * _.isUndefined(void 0);
         * // => true
         *
         * _.isUndefined(null);
         * // => false
         */
        function isUndefined(value) {
          return value === undefined$1;
        }

        /**
         * Checks if `value` is classified as a `WeakMap` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
         * @example
         *
         * _.isWeakMap(new WeakMap);
         * // => true
         *
         * _.isWeakMap(new Map);
         * // => false
         */
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }

        /**
         * Checks if `value` is classified as a `WeakSet` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
         * @example
         *
         * _.isWeakSet(new WeakSet);
         * // => true
         *
         * _.isWeakSet(new Set);
         * // => false
         */
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }

        /**
         * Checks if `value` is less than `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`,
         *  else `false`.
         * @see _.gt
         * @example
         *
         * _.lt(1, 3);
         * // => true
         *
         * _.lt(3, 3);
         * // => false
         *
         * _.lt(3, 1);
         * // => false
         */
        var lt = createRelationalOperation(baseLt);

        /**
         * Checks if `value` is less than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than or equal to
         *  `other`, else `false`.
         * @see _.gte
         * @example
         *
         * _.lte(1, 3);
         * // => true
         *
         * _.lte(3, 3);
         * // => true
         *
         * _.lte(3, 1);
         * // => false
         */
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });

        /**
         * Converts `value` to an array.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Array} Returns the converted array.
         * @example
         *
         * _.toArray({ 'a': 1, 'b': 2 });
         * // => [1, 2]
         *
         * _.toArray('abc');
         * // => ['a', 'b', 'c']
         *
         * _.toArray(1);
         * // => []
         *
         * _.toArray(null);
         * // => []
         */
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value),
              func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

          return func(value);
        }

        /**
         * Converts `value` to a finite number.
         *
         * @static
         * @memberOf _
         * @since 4.12.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted number.
         * @example
         *
         * _.toFinite(3.2);
         * // => 3.2
         *
         * _.toFinite(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toFinite(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toFinite('3.2');
         * // => 3.2
         */
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = (value < 0 ? -1 : 1);
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }

        /**
         * Converts `value` to an integer.
         *
         * **Note:** This method is loosely based on
         * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toInteger(3.2);
         * // => 3
         *
         * _.toInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toInteger(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toInteger('3.2');
         * // => 3
         */
        function toInteger(value) {
          var result = toFinite(value),
              remainder = result % 1;

          return result === result ? (remainder ? result - remainder : result) : 0;
        }

        /**
         * Converts `value` to an integer suitable for use as the length of an
         * array-like object.
         *
         * **Note:** This method is based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toLength(3.2);
         * // => 3
         *
         * _.toLength(Number.MIN_VALUE);
         * // => 0
         *
         * _.toLength(Infinity);
         * // => 4294967295
         *
         * _.toLength('3.2');
         * // => 3
         */
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }

        /**
         * Converts `value` to a number.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         * @example
         *
         * _.toNumber(3.2);
         * // => 3.2
         *
         * _.toNumber(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toNumber(Infinity);
         * // => Infinity
         *
         * _.toNumber('3.2');
         * // => 3.2
         */
        function toNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
            value = isObject(other) ? (other + '') : other;
          }
          if (typeof value != 'string') {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return (isBinary || reIsOctal.test(value))
            ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
            : (reIsBadHex.test(value) ? NAN : +value);
        }

        /**
         * Converts `value` to a plain object flattening inherited enumerable string
         * keyed properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }

        /**
         * Converts `value` to a safe integer. A safe integer can be compared and
         * represented correctly.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toSafeInteger(3.2);
         * // => 3
         *
         * _.toSafeInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toSafeInteger(Infinity);
         * // => 9007199254740991
         *
         * _.toSafeInteger('3.2');
         * // => 3
         */
        function toSafeInteger(value) {
          return value
            ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
            : (value === 0 ? value : 0);
        }

        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */
        function toString(value) {
          return value == null ? '' : baseToString(value);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Assigns own enumerable string keyed properties of source objects to the
         * destination object. Source objects are applied from left to right.
         * Subsequent sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object` and is loosely based on
         * [`Object.assign`](https://mdn.io/Object/assign).
         *
         * @static
         * @memberOf _
         * @since 0.10.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.assignIn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * function Bar() {
         *   this.c = 3;
         * }
         *
         * Foo.prototype.b = 2;
         * Bar.prototype.d = 4;
         *
         * _.assign({ 'a': 0 }, new Foo, new Bar);
         * // => { 'a': 1, 'c': 3 }
         */
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });

        /**
         * This method is like `_.assign` except that it iterates over own and
         * inherited source properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias extend
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.assign
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * function Bar() {
         *   this.c = 3;
         * }
         *
         * Foo.prototype.b = 2;
         * Bar.prototype.d = 4;
         *
         * _.assignIn({ 'a': 0 }, new Foo, new Bar);
         * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
         */
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });

        /**
         * This method is like `_.assignIn` except that it accepts `customizer`
         * which is invoked to produce the assigned values. If `customizer` returns
         * `undefined`, assignment is handled by the method instead. The `customizer`
         * is invoked with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias extendWith
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @see _.assignWith
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignInWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });

        /**
         * This method is like `_.assign` except that it accepts `customizer`
         * which is invoked to produce the assigned values. If `customizer` returns
         * `undefined`, assignment is handled by the method instead. The `customizer`
         * is invoked with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @see _.assignInWith
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });

        /**
         * Creates an array of values corresponding to `paths` of `object`.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Array} Returns the picked values.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
         *
         * _.at(object, ['a[0].b.c', 'a[1]']);
         * // => [3, 4]
         */
        var at = flatRest(baseAt);

        /**
         * Creates an object that inherits from the `prototype` object. If a
         * `properties` object is given, its own enumerable string keyed properties
         * are assigned to the created object.
         *
         * @static
         * @memberOf _
         * @since 2.3.0
         * @category Object
         * @param {Object} prototype The object to inherit from.
         * @param {Object} [properties] The properties to assign to the object.
         * @returns {Object} Returns the new object.
         * @example
         *
         * function Shape() {
         *   this.x = 0;
         *   this.y = 0;
         * }
         *
         * function Circle() {
         *   Shape.call(this);
         * }
         *
         * Circle.prototype = _.create(Shape.prototype, {
         *   'constructor': Circle
         * });
         *
         * var circle = new Circle;
         * circle instanceof Circle;
         * // => true
         *
         * circle instanceof Shape;
         * // => true
         */
        function create(prototype, properties) {
          var result = baseCreate(prototype);
          return properties == null ? result : baseAssign(result, properties);
        }

        /**
         * Assigns own and inherited enumerable string keyed properties of source
         * objects to the destination object for all destination properties that
         * resolve to `undefined`. Source objects are applied from left to right.
         * Once a property is set, additional values of the same property are ignored.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.defaultsDeep
         * @example
         *
         * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var defaults = baseRest(function(object, sources) {
          object = Object(object);

          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined$1;

          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }

          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;

            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];

              if (value === undefined$1 ||
                  (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                object[key] = source[key];
              }
            }
          }

          return object;
        });

        /**
         * This method is like `_.defaults` except that it recursively assigns
         * default properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.defaults
         * @example
         *
         * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
         * // => { 'a': { 'b': 2, 'c': 3 } }
         */
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply(mergeWith, undefined$1, args);
        });

        /**
         * This method is like `_.find` except that it returns the key of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {string|undefined} Returns the key of the matched element,
         *  else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findKey(users, function(o) { return o.age < 40; });
         * // => 'barney' (iteration order is not guaranteed)
         *
         * // The `_.matches` iteratee shorthand.
         * _.findKey(users, { 'age': 1, 'active': true });
         * // => 'pebbles'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findKey(users, ['active', false]);
         * // => 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.findKey(users, 'active');
         * // => 'barney'
         */
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }

        /**
         * This method is like `_.findKey` except that it iterates over elements of
         * a collection in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {string|undefined} Returns the key of the matched element,
         *  else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findLastKey(users, function(o) { return o.age < 40; });
         * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
         *
         * // The `_.matches` iteratee shorthand.
         * _.findLastKey(users, { 'age': 36, 'active': true });
         * // => 'barney'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findLastKey(users, ['active', false]);
         * // => 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.findLastKey(users, 'active');
         * // => 'pebbles'
         */
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }

        /**
         * Iterates over own and inherited enumerable string keyed properties of an
         * object and invokes `iteratee` for each property. The iteratee is invoked
         * with three arguments: (value, key, object). Iteratee functions may exit
         * iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 0.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forInRight
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forIn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
         */
        function forIn(object, iteratee) {
          return object == null
            ? object
            : baseFor(object, getIteratee(iteratee, 3), keysIn);
        }

        /**
         * This method is like `_.forIn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forIn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forInRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
         */
        function forInRight(object, iteratee) {
          return object == null
            ? object
            : baseForRight(object, getIteratee(iteratee, 3), keysIn);
        }

        /**
         * Iterates over own enumerable string keyed properties of an object and
         * invokes `iteratee` for each property. The iteratee is invoked with three
         * arguments: (value, key, object). Iteratee functions may exit iteration
         * early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 0.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forOwnRight
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forOwn(object, iteratee) {
          return object && baseForOwn(object, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.forOwn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forOwn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwnRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
         */
        function forOwnRight(object, iteratee) {
          return object && baseForOwnRight(object, getIteratee(iteratee, 3));
        }

        /**
         * Creates an array of function property names from own enumerable properties
         * of `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the function names.
         * @see _.functionsIn
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functions(new Foo);
         * // => ['a', 'b']
         */
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }

        /**
         * Creates an array of function property names from own and inherited
         * enumerable properties of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the function names.
         * @see _.functions
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functionsIn(new Foo);
         * // => ['a', 'b', 'c']
         */
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }

        /**
         * Gets the value at `path` of `object`. If the resolved value is
         * `undefined`, the `defaultValue` is returned in its place.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */
        function get(object, path, defaultValue) {
          var result = object == null ? undefined$1 : baseGet(object, path);
          return result === undefined$1 ? defaultValue : result;
        }

        /**
         * Checks if `path` is a direct property of `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = { 'a': { 'b': 2 } };
         * var other = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.has(object, 'a');
         * // => true
         *
         * _.has(object, 'a.b');
         * // => true
         *
         * _.has(object, ['a', 'b']);
         * // => true
         *
         * _.has(other, 'a');
         * // => false
         */
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }

        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b');
         * // => true
         *
         * _.hasIn(object, ['a', 'b']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }

        /**
         * Creates an object composed of the inverted keys and values of `object`.
         * If `object` contains duplicate values, subsequent values overwrite
         * property assignments of previous values.
         *
         * @static
         * @memberOf _
         * @since 0.7.0
         * @category Object
         * @param {Object} object The object to invert.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invert(object);
         * // => { '1': 'c', '2': 'b' }
         */
        var invert = createInverter(function(result, value, key) {
          if (value != null &&
              typeof value.toString != 'function') {
            value = nativeObjectToString.call(value);
          }

          result[value] = key;
        }, constant(identity));

        /**
         * This method is like `_.invert` except that the inverted object is generated
         * from the results of running each element of `object` thru `iteratee`. The
         * corresponding inverted value of each inverted key is an array of keys
         * responsible for generating the inverted value. The iteratee is invoked
         * with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.1.0
         * @category Object
         * @param {Object} object The object to invert.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invertBy(object);
         * // => { '1': ['a', 'c'], '2': ['b'] }
         *
         * _.invertBy(object, function(value) {
         *   return 'group' + value;
         * });
         * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
         */
        var invertBy = createInverter(function(result, value, key) {
          if (value != null &&
              typeof value.toString != 'function') {
            value = nativeObjectToString.call(value);
          }

          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }, getIteratee);

        /**
         * Invokes the method at `path` of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
         *
         * _.invoke(object, 'a[0].b.c.slice', 1, 3);
         * // => [2, 3]
         */
        var invoke = baseRest(baseInvoke);

        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }

        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }

        /**
         * The opposite of `_.mapValues`; this method creates an object with the
         * same values as `object` and keys generated by running each own enumerable
         * string keyed property of `object` thru `iteratee`. The iteratee is invoked
         * with three arguments: (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapValues
         * @example
         *
         * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
         *   return key + value;
         * });
         * // => { 'a1': 1, 'b2': 2 }
         */
        function mapKeys(object, iteratee) {
          var result = {};
          iteratee = getIteratee(iteratee, 3);

          baseForOwn(object, function(value, key, object) {
            baseAssignValue(result, iteratee(value, key, object), value);
          });
          return result;
        }

        /**
         * Creates an object with the same keys as `object` and values generated
         * by running each own enumerable string keyed property of `object` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapKeys
         * @example
         *
         * var users = {
         *   'fred':    { 'user': 'fred',    'age': 40 },
         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
         * };
         *
         * _.mapValues(users, function(o) { return o.age; });
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         *
         * // The `_.property` iteratee shorthand.
         * _.mapValues(users, 'age');
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         */
        function mapValues(object, iteratee) {
          var result = {};
          iteratee = getIteratee(iteratee, 3);

          baseForOwn(object, function(value, key, object) {
            baseAssignValue(result, key, iteratee(value, key, object));
          });
          return result;
        }

        /**
         * This method is like `_.assign` except that it recursively merges own and
         * inherited enumerable string keyed properties of source objects into the
         * destination object. Source properties that resolve to `undefined` are
         * skipped if a destination value exists. Array and plain object properties
         * are merged recursively. Other objects and value types are overridden by
         * assignment. Source objects are applied from left to right. Subsequent
         * sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {
         *   'a': [{ 'b': 2 }, { 'd': 4 }]
         * };
         *
         * var other = {
         *   'a': [{ 'c': 3 }, { 'e': 5 }]
         * };
         *
         * _.merge(object, other);
         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
         */
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });

        /**
         * This method is like `_.merge` except that it accepts `customizer` which
         * is invoked to produce the merged values of the destination and source
         * properties. If `customizer` returns `undefined`, merging is handled by the
         * method instead. The `customizer` is invoked with six arguments:
         * (objValue, srcValue, key, object, source, stack).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   if (_.isArray(objValue)) {
         *     return objValue.concat(srcValue);
         *   }
         * }
         *
         * var object = { 'a': [1], 'b': [2] };
         * var other = { 'a': [3], 'b': [4] };
         *
         * _.mergeWith(object, other, customizer);
         * // => { 'a': [1, 3], 'b': [2, 4] }
         */
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });

        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable property paths of `object` that are not omitted.
         *
         * **Note:** This method is considerably slower than `_.pick`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to omit.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omit(object, ['a', 'c']);
         * // => { 'b': '2' }
         */
        var omit = flatRest(function(object, paths) {
          var result = {};
          if (object == null) {
            return result;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result);
          if (isDeep) {
            result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result, paths[length]);
          }
          return result;
        });

        /**
         * The opposite of `_.pickBy`; this method creates an object composed of
         * the own and inherited enumerable string keyed properties of `object` that
         * `predicate` doesn't return truthy for. The predicate is invoked with two
         * arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The source object.
         * @param {Function} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omitBy(object, _.isNumber);
         * // => { 'b': '2' }
         */
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }

        /**
         * Creates an object composed of the picked `object` properties.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pick(object, ['a', 'c']);
         * // => { 'a': 1, 'c': 3 }
         */
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });

        /**
         * Creates an object composed of the `object` properties `predicate` returns
         * truthy for. The predicate is invoked with two arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The source object.
         * @param {Function} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pickBy(object, _.isNumber);
         * // => { 'a': 1, 'c': 3 }
         */
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }

        /**
         * This method is like `_.get` except that if the resolved value is a
         * function it's invoked with the `this` binding of its parent object and
         * its result is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to resolve.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
         *
         * _.result(object, 'a[0].b.c1');
         * // => 3
         *
         * _.result(object, 'a[0].b.c2');
         * // => 4
         *
         * _.result(object, 'a[0].b.c3', 'default');
         * // => 'default'
         *
         * _.result(object, 'a[0].b.c3', _.constant('default'));
         * // => 'default'
         */
        function result(object, path, defaultValue) {
          path = castPath(path, object);

          var index = -1,
              length = path.length;

          // Ensure the loop is entered when path is empty.
          if (!length) {
            length = 1;
            object = undefined$1;
          }
          while (++index < length) {
            var value = object == null ? undefined$1 : object[toKey(path[index])];
            if (value === undefined$1) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }

        /**
         * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
         * it's created. Arrays are created for missing index properties while objects
         * are created for all other missing properties. Use `_.setWith` to customize
         * `path` creation.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.set(object, 'a[0].b.c', 4);
         * console.log(object.a[0].b.c);
         * // => 4
         *
         * _.set(object, ['x', '0', 'y', 'z'], 5);
         * console.log(object.x[0].y.z);
         * // => 5
         */
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }

        /**
         * This method is like `_.set` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.setWith(object, '[0][1]', 'a', Object);
         * // => { '0': { '1': 'a' } }
         */
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return object == null ? object : baseSet(object, path, value, customizer);
        }

        /**
         * Creates an array of own enumerable string keyed-value pairs for `object`
         * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
         * entries are returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias entries
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the key-value pairs.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.toPairs(new Foo);
         * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
         */
        var toPairs = createToPairs(keys);

        /**
         * Creates an array of own and inherited enumerable string keyed-value pairs
         * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
         * or set, its entries are returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias entriesIn
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the key-value pairs.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.toPairsIn(new Foo);
         * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
         */
        var toPairsIn = createToPairs(keysIn);

        /**
         * An alternative to `_.reduce`; this method transforms `object` to a new
         * `accumulator` object which is the result of running each of its own
         * enumerable string keyed properties thru `iteratee`, with each invocation
         * potentially mutating the `accumulator` object. If `accumulator` is not
         * provided, a new object with the same `[[Prototype]]` will be used. The
         * iteratee is invoked with four arguments: (accumulator, value, key, object).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 1.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The custom accumulator value.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.transform([2, 3, 4], function(result, n) {
         *   result.push(n *= n);
         *   return n % 2 == 0;
         * }, []);
         * // => [4, 9]
         *
         * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] }
         */
        function transform(object, iteratee, accumulator) {
          var isArr = isArray(object),
              isArrLike = isArr || isBuffer(object) || isTypedArray(object);

          iteratee = getIteratee(iteratee, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor : [];
            }
            else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            }
            else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }

        /**
         * Removes the property at `path` of `object`.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 7 } }] };
         * _.unset(object, 'a[0].b.c');
         * // => true
         *
         * console.log(object);
         * // => { 'a': [{ 'b': {} }] };
         *
         * _.unset(object, ['a', '0', 'b', 'c']);
         * // => true
         *
         * console.log(object);
         * // => { 'a': [{ 'b': {} }] };
         */
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }

        /**
         * This method is like `_.set` except that accepts `updater` to produce the
         * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
         * is invoked with one argument: (value).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {Function} updater The function to produce the updated value.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.update(object, 'a[0].b.c', function(n) { return n * n; });
         * console.log(object.a[0].b.c);
         * // => 9
         *
         * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
         * console.log(object.x[0].y.z);
         * // => 0
         */
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }

        /**
         * This method is like `_.update` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {Function} updater The function to produce the updated value.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.updateWith(object, '[0][1]', _.constant('a'), Object);
         * // => { '0': { '1': 'a' } }
         */
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }

        /**
         * Creates an array of the own enumerable string keyed property values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.values(new Foo);
         * // => [1, 2] (iteration order is not guaranteed)
         *
         * _.values('hi');
         * // => ['h', 'i']
         */
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }

        /**
         * Creates an array of the own and inherited enumerable string keyed property
         * values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.valuesIn(new Foo);
         * // => [1, 2, 3] (iteration order is not guaranteed)
         */
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }

        /*------------------------------------------------------------------------*/

        /**
         * Clamps `number` within the inclusive `lower` and `upper` bounds.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Number
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         * @example
         *
         * _.clamp(-10, -5, 5);
         * // => -5
         *
         * _.clamp(10, -5, 5);
         * // => 5
         */
        function clamp(number, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }

        /**
         * Checks if `n` is between `start` and up to, but not including, `end`. If
         * `end` is not specified, it's set to `start` with `start` then set to `0`.
         * If `start` is greater than `end` the params are swapped to support
         * negative ranges.
         *
         * @static
         * @memberOf _
         * @since 3.3.0
         * @category Number
         * @param {number} number The number to check.
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
         * @see _.range, _.rangeRight
         * @example
         *
         * _.inRange(3, 2, 4);
         * // => true
         *
         * _.inRange(4, 8);
         * // => true
         *
         * _.inRange(4, 2);
         * // => false
         *
         * _.inRange(2, 2);
         * // => false
         *
         * _.inRange(1.2, 2);
         * // => true
         *
         * _.inRange(5.2, 4);
         * // => false
         *
         * _.inRange(-3, -2, -6);
         * // => true
         */
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }

        /**
         * Produces a random number between the inclusive `lower` and `upper` bounds.
         * If only one argument is provided a number between `0` and the given number
         * is returned. If `floating` is `true`, or either `lower` or `upper` are
         * floats, a floating-point number is returned instead of an integer.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @memberOf _
         * @since 0.7.0
         * @category Number
         * @param {number} [lower=0] The lower bound.
         * @param {number} [upper=1] The upper bound.
         * @param {boolean} [floating] Specify returning a floating-point number.
         * @returns {number} Returns the random number.
         * @example
         *
         * _.random(0, 5);
         * // => an integer between 0 and 5
         *
         * _.random(5);
         * // => also an integer between 0 and 5
         *
         * _.random(5, true);
         * // => a floating-point number between 0 and 5
         *
         * _.random(1.2, 5.2);
         * // => a floating-point number between 1.2 and 5.2
         */
        function random(lower, upper, floating) {
          if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == 'boolean') {
              floating = upper;
              upper = undefined$1;
            }
            else if (typeof lower == 'boolean') {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          }
          else {
            lower = toFinite(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
          }
          return baseRandom(lower, upper);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the camel cased string.
         * @example
         *
         * _.camelCase('Foo Bar');
         * // => 'fooBar'
         *
         * _.camelCase('--foo-bar--');
         * // => 'fooBar'
         *
         * _.camelCase('__FOO_BAR__');
         * // => 'fooBar'
         */
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? capitalize(word) : word);
        });

        /**
         * Converts the first character of `string` to upper case and the remaining
         * to lower case.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to capitalize.
         * @returns {string} Returns the capitalized string.
         * @example
         *
         * _.capitalize('FRED');
         * // => 'Fred'
         */
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }

        /**
         * Deburrs `string` by converting
         * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
         * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
         * letters to basic Latin letters and removing
         * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to deburr.
         * @returns {string} Returns the deburred string.
         * @example
         *
         * _.deburr('déjà vu');
         * // => 'deja vu'
         */
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
        }

        /**
         * Checks if `string` ends with the given target string.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {string} [target] The string to search for.
         * @param {number} [position=string.length] The position to search up to.
         * @returns {boolean} Returns `true` if `string` ends with `target`,
         *  else `false`.
         * @example
         *
         * _.endsWith('abc', 'c');
         * // => true
         *
         * _.endsWith('abc', 'b');
         * // => false
         *
         * _.endsWith('abc', 'b', 2);
         * // => true
         */
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);

          var length = string.length;
          position = position === undefined$1
            ? length
            : baseClamp(toInteger(position), 0, length);

          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }

        /**
         * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
         * corresponding HTML entities.
         *
         * **Note:** No other characters are escaped. To escape additional
         * characters use a third-party library like [_he_](https://mths.be/he).
         *
         * Though the ">" character is escaped for symmetry, characters like
         * ">" and "/" don't need escaping in HTML and have no special meaning
         * unless they're part of a tag or unquoted attribute value. See
         * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
         * (under "semi-related fun fact") for more details.
         *
         * When working with HTML you should always
         * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
         * XSS vectors.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escape('fred, barney, & pebbles');
         * // => 'fred, barney, &amp; pebbles'
         */
        function escape(string) {
          string = toString(string);
          return (string && reHasUnescapedHtml.test(string))
            ? string.replace(reUnescapedHtml, escapeHtmlChar)
            : string;
        }

        /**
         * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
         * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escapeRegExp('[lodash](https://lodash.com/)');
         * // => '\[lodash\]\(https://lodash\.com/\)'
         */
        function escapeRegExp(string) {
          string = toString(string);
          return (string && reHasRegExpChar.test(string))
            ? string.replace(reRegExpChar, '\\$&')
            : string;
        }

        /**
         * Converts `string` to
         * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the kebab cased string.
         * @example
         *
         * _.kebabCase('Foo Bar');
         * // => 'foo-bar'
         *
         * _.kebabCase('fooBar');
         * // => 'foo-bar'
         *
         * _.kebabCase('__FOO_BAR__');
         * // => 'foo-bar'
         */
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });

        /**
         * Converts `string`, as space separated words, to lower case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the lower cased string.
         * @example
         *
         * _.lowerCase('--Foo-Bar--');
         * // => 'foo bar'
         *
         * _.lowerCase('fooBar');
         * // => 'foo bar'
         *
         * _.lowerCase('__FOO_BAR__');
         * // => 'foo bar'
         */
        var lowerCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + word.toLowerCase();
        });

        /**
         * Converts the first character of `string` to lower case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.lowerFirst('Fred');
         * // => 'fred'
         *
         * _.lowerFirst('FRED');
         * // => 'fRED'
         */
        var lowerFirst = createCaseFirst('toLowerCase');

        /**
         * Pads `string` on the left and right sides if it's shorter than `length`.
         * Padding characters are truncated if they can't be evenly divided by `length`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.pad('abc', 8);
         * // => '  abc   '
         *
         * _.pad('abc', 8, '_-');
         * // => '_-abc_-_'
         *
         * _.pad('abc', 3);
         * // => 'abc'
         */
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return (
            createPadding(nativeFloor(mid), chars) +
            string +
            createPadding(nativeCeil(mid), chars)
          );
        }

        /**
         * Pads `string` on the right side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padEnd('abc', 6);
         * // => 'abc   '
         *
         * _.padEnd('abc', 6, '_-');
         * // => 'abc_-_'
         *
         * _.padEnd('abc', 3);
         * // => 'abc'
         */
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          return (length && strLength < length)
            ? (string + createPadding(length - strLength, chars))
            : string;
        }

        /**
         * Pads `string` on the left side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padStart('abc', 6);
         * // => '   abc'
         *
         * _.padStart('abc', 6, '_-');
         * // => '_-_abc'
         *
         * _.padStart('abc', 3);
         * // => 'abc'
         */
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          return (length && strLength < length)
            ? (createPadding(length - strLength, chars) + string)
            : string;
        }

        /**
         * Converts `string` to an integer of the specified radix. If `radix` is
         * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
         * hexadecimal, in which case a `radix` of `16` is used.
         *
         * **Note:** This method aligns with the
         * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category String
         * @param {string} string The string to convert.
         * @param {number} [radix=10] The radix to interpret `value` by.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.parseInt('08');
         * // => 8
         *
         * _.map(['6', '08', '10'], _.parseInt);
         * // => [6, 8, 10]
         */
        function parseInt(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
        }

        /**
         * Repeats the given string `n` times.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to repeat.
         * @param {number} [n=1] The number of times to repeat the string.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the repeated string.
         * @example
         *
         * _.repeat('*', 3);
         * // => '***'
         *
         * _.repeat('abc', 2);
         * // => 'abcabc'
         *
         * _.repeat('abc', 0);
         * // => ''
         */
        function repeat(string, n, guard) {
          if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }

        /**
         * Replaces matches for `pattern` in `string` with `replacement`.
         *
         * **Note:** This method is based on
         * [`String#replace`](https://mdn.io/String/replace).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to modify.
         * @param {RegExp|string} pattern The pattern to replace.
         * @param {Function|string} replacement The match replacement.
         * @returns {string} Returns the modified string.
         * @example
         *
         * _.replace('Hi Fred', 'Fred', 'Barney');
         * // => 'Hi Barney'
         */
        function replace() {
          var args = arguments,
              string = toString(args[0]);

          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }

        /**
         * Converts `string` to
         * [snake case](https://en.wikipedia.org/wiki/Snake_case).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the snake cased string.
         * @example
         *
         * _.snakeCase('Foo Bar');
         * // => 'foo_bar'
         *
         * _.snakeCase('fooBar');
         * // => 'foo_bar'
         *
         * _.snakeCase('--FOO-BAR--');
         * // => 'foo_bar'
         */
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });

        /**
         * Splits `string` by `separator`.
         *
         * **Note:** This method is based on
         * [`String#split`](https://mdn.io/String/split).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to split.
         * @param {RegExp|string} separator The separator pattern to split by.
         * @param {number} [limit] The length to truncate results to.
         * @returns {Array} Returns the string segments.
         * @example
         *
         * _.split('a-b-c', '-', 2);
         * // => ['a', 'b']
         */
        function split(string, separator, limit) {
          if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (
                typeof separator == 'string' ||
                (separator != null && !isRegExp(separator))
              )) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }

        /**
         * Converts `string` to
         * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
         *
         * @static
         * @memberOf _
         * @since 3.1.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the start cased string.
         * @example
         *
         * _.startCase('--foo-bar--');
         * // => 'Foo Bar'
         *
         * _.startCase('fooBar');
         * // => 'Foo Bar'
         *
         * _.startCase('__FOO_BAR__');
         * // => 'FOO BAR'
         */
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + upperFirst(word);
        });

        /**
         * Checks if `string` starts with the given target string.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {string} [target] The string to search for.
         * @param {number} [position=0] The position to search from.
         * @returns {boolean} Returns `true` if `string` starts with `target`,
         *  else `false`.
         * @example
         *
         * _.startsWith('abc', 'a');
         * // => true
         *
         * _.startsWith('abc', 'b');
         * // => false
         *
         * _.startsWith('abc', 'b', 1);
         * // => true
         */
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null
            ? 0
            : baseClamp(toInteger(position), 0, string.length);

          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }

        /**
         * Creates a compiled template function that can interpolate data properties
         * in "interpolate" delimiters, HTML-escape interpolated data properties in
         * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
         * properties may be accessed as free variables in the template. If a setting
         * object is given, it takes precedence over `_.templateSettings` values.
         *
         * **Note:** In the development build `_.template` utilizes
         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
         * for easier debugging.
         *
         * For more information on precompiling templates see
         * [lodash's custom builds documentation](https://lodash.com/custom-builds).
         *
         * For more information on Chrome extension sandboxes see
         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category String
         * @param {string} [string=''] The template string.
         * @param {Object} [options={}] The options object.
         * @param {RegExp} [options.escape=_.templateSettings.escape]
         *  The HTML "escape" delimiter.
         * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
         *  The "evaluate" delimiter.
         * @param {Object} [options.imports=_.templateSettings.imports]
         *  An object to import into the template as free variables.
         * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
         *  The "interpolate" delimiter.
         * @param {string} [options.sourceURL='lodash.templateSources[n]']
         *  The sourceURL of the compiled template.
         * @param {string} [options.variable='obj']
         *  The data object variable name.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the compiled template function.
         * @example
         *
         * // Use the "interpolate" delimiter to create a compiled template.
         * var compiled = _.template('hello <%= user %>!');
         * compiled({ 'user': 'fred' });
         * // => 'hello fred!'
         *
         * // Use the HTML "escape" delimiter to escape data property values.
         * var compiled = _.template('<b><%- value %></b>');
         * compiled({ 'value': '<script>' });
         * // => '<b>&lt;script&gt;</b>'
         *
         * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
         * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the internal `print` function in "evaluate" delimiters.
         * var compiled = _.template('<% print("hello " + user); %>!');
         * compiled({ 'user': 'barney' });
         * // => 'hello barney!'
         *
         * // Use the ES template literal delimiter as an "interpolate" delimiter.
         * // Disable support by replacing the "interpolate" delimiter.
         * var compiled = _.template('hello ${ user }!');
         * compiled({ 'user': 'pebbles' });
         * // => 'hello pebbles!'
         *
         * // Use backslashes to treat delimiters as plain text.
         * var compiled = _.template('<%= "\\<%- value %\\>" %>');
         * compiled({ 'value': 'ignored' });
         * // => '<%- value %>'
         *
         * // Use the `imports` option to import `jQuery` as `jq`.
         * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
         * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the `sourceURL` option to specify a custom sourceURL for the template.
         * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
         * compiled(data);
         * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
         *
         * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
         * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
         * compiled.source;
         * // => function(data) {
         * //   var __t, __p = '';
         * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
         * //   return __p;
         * // }
         *
         * // Use custom template delimiters.
         * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
         * var compiled = _.template('hello {{ user }}!');
         * compiled({ 'user': 'mustache' });
         * // => 'hello mustache!'
         *
         * // Use the `source` property to inline compiled templates for meaningful
         * // line numbers in error messages and stack traces.
         * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
         *   var JST = {\
         *     "main": ' + _.template(mainText).source + '\
         *   };\
         * ');
         */
        function template(string, options, guard) {
          // Based on John Resig's `tmpl` implementation
          // (http://ejohn.org/blog/javascript-micro-templating/)
          // and Laura Doktorova's doT.js (https://github.com/olado/doT).
          var settings = lodash.templateSettings;

          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined$1;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);

          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);

          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";

          // Compile the regexp to match each delimiter.
          var reDelimiters = RegExp(
            (options.escape || reNoMatch).source + '|' +
            interpolate.source + '|' +
            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
            (options.evaluate || reNoMatch).source + '|$'
          , 'g');

          // Use a sourceURL for easier debugging.
          // The sourceURL gets injected into the source that's eval-ed, so be careful
          // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
          // and escape the comment, thus injecting code that gets evaled.
          var sourceURL = '//# sourceURL=' +
            (hasOwnProperty.call(options, 'sourceURL')
              ? (options.sourceURL + '').replace(/\s/g, ' ')
              : ('lodash.templateSources[' + (++templateCounter) + ']')
            ) + '\n';

          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);

            // Escape characters that can't be included in string literals.
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

            // Replace delimiters with snippets.
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;

            // The JS engine embedded in Adobe products needs `match` returned in
            // order to produce the correct `offset` value.
            return match;
          });

          source += "';\n";

          // If `variable` is not specified wrap a with-statement around the generated
          // code to add the data object to the top of the scope chain.
          var variable = hasOwnProperty.call(options, 'variable') && options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          // Throw an error if a forbidden character was found in `variable`, to prevent
          // potential command injection attacks.
          else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
          }

          // Cleanup code by stripping empty strings.
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
            .replace(reEmptyStringMiddle, '$1')
            .replace(reEmptyStringTrailing, '$1;');

          // Frame code as the function body.
          source = 'function(' + (variable || 'obj') + ') {\n' +
            (variable
              ? ''
              : 'obj || (obj = {});\n'
            ) +
            "var __t, __p = ''" +
            (isEscaping
               ? ', __e = _.escape'
               : ''
            ) +
            (isEvaluating
              ? ', __j = Array.prototype.join;\n' +
                "function print() { __p += __j.call(arguments, '') }\n"
              : ';\n'
            ) +
            source +
            'return __p\n}';

          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source)
              .apply(undefined$1, importsValues);
          });

          // Provide the compiled function's source by its `toString` method or
          // the `source` property as a convenience for inlining compiled templates.
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }

        /**
         * Converts `string`, as a whole, to lower case just like
         * [String#toLowerCase](https://mdn.io/toLowerCase).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the lower cased string.
         * @example
         *
         * _.toLower('--Foo-Bar--');
         * // => '--foo-bar--'
         *
         * _.toLower('fooBar');
         * // => 'foobar'
         *
         * _.toLower('__FOO_BAR__');
         * // => '__foo_bar__'
         */
        function toLower(value) {
          return toString(value).toLowerCase();
        }

        /**
         * Converts `string`, as a whole, to upper case just like
         * [String#toUpperCase](https://mdn.io/toUpperCase).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the upper cased string.
         * @example
         *
         * _.toUpper('--foo-bar--');
         * // => '--FOO-BAR--'
         *
         * _.toUpper('fooBar');
         * // => 'FOOBAR'
         *
         * _.toUpper('__foo_bar__');
         * // => '__FOO_BAR__'
         */
        function toUpper(value) {
          return toString(value).toUpperCase();
        }

        /**
         * Removes leading and trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trim('  abc  ');
         * // => 'abc'
         *
         * _.trim('-_-abc-_-', '_-');
         * // => 'abc'
         *
         * _.map(['  foo  ', '  bar  '], _.trim);
         * // => ['foo', 'bar']
         */
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              chrSymbols = stringToArray(chars),
              start = charsStartIndex(strSymbols, chrSymbols),
              end = charsEndIndex(strSymbols, chrSymbols) + 1;

          return castSlice(strSymbols, start, end).join('');
        }

        /**
         * Removes trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimEnd('  abc  ');
         * // => '  abc'
         *
         * _.trimEnd('-_-abc-_-', '_-');
         * // => '-_-abc'
         */
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

          return castSlice(strSymbols, 0, end).join('');
        }

        /**
         * Removes leading whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimStart('  abc  ');
         * // => 'abc  '
         *
         * _.trimStart('-_-abc-_-', '_-');
         * // => 'abc-_-'
         */
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimStart, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              start = charsStartIndex(strSymbols, stringToArray(chars));

          return castSlice(strSymbols, start).join('');
        }

        /**
         * Truncates `string` if it's longer than the given maximum string length.
         * The last characters of the truncated string are replaced with the omission
         * string which defaults to "...".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to truncate.
         * @param {Object} [options={}] The options object.
         * @param {number} [options.length=30] The maximum string length.
         * @param {string} [options.omission='...'] The string to indicate text is omitted.
         * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
         * @returns {string} Returns the truncated string.
         * @example
         *
         * _.truncate('hi-diddly-ho there, neighborino');
         * // => 'hi-diddly-ho there, neighbo...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': ' '
         * });
         * // => 'hi-diddly-ho there,...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': /,? +/
         * });
         * // => 'hi-diddly-ho there...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'omission': ' [...]'
         * });
         * // => 'hi-diddly-ho there, neig [...]'
         */
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;

          if (isObject(options)) {
            var separator = 'separator' in options ? options.separator : separator;
            length = 'length' in options ? toInteger(options.length) : length;
            omission = 'omission' in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);

          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result = strSymbols
            ? castSlice(strSymbols, 0, end).join('')
            : string.slice(0, end);

          if (separator === undefined$1) {
            return result + omission;
          }
          if (strSymbols) {
            end += (result.length - end);
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  substring = result;

              if (!separator.global) {
                separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                var newEnd = match.index;
              }
              result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }

        /**
         * The inverse of `_.escape`; this method converts the HTML entities
         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
         * their corresponding characters.
         *
         * **Note:** No other HTML entities are unescaped. To unescape additional
         * HTML entities use a third-party library like [_he_](https://mths.be/he).
         *
         * @static
         * @memberOf _
         * @since 0.6.0
         * @category String
         * @param {string} [string=''] The string to unescape.
         * @returns {string} Returns the unescaped string.
         * @example
         *
         * _.unescape('fred, barney, &amp; pebbles');
         * // => 'fred, barney, & pebbles'
         */
        function unescape(string) {
          string = toString(string);
          return (string && reHasEscapedHtml.test(string))
            ? string.replace(reEscapedHtml, unescapeHtmlChar)
            : string;
        }

        /**
         * Converts `string`, as space separated words, to upper case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the upper cased string.
         * @example
         *
         * _.upperCase('--foo-bar');
         * // => 'FOO BAR'
         *
         * _.upperCase('fooBar');
         * // => 'FOO BAR'
         *
         * _.upperCase('__foo_bar__');
         * // => 'FOO BAR'
         */
        var upperCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + word.toUpperCase();
        });

        /**
         * Converts the first character of `string` to upper case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.upperFirst('fred');
         * // => 'Fred'
         *
         * _.upperFirst('FRED');
         * // => 'FRED'
         */
        var upperFirst = createCaseFirst('toUpperCase');

        /**
         * Splits `string` into an array of its words.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {RegExp|string} [pattern] The pattern to match words.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the words of `string`.
         * @example
         *
         * _.words('fred, barney, & pebbles');
         * // => ['fred', 'barney', 'pebbles']
         *
         * _.words('fred, barney, & pebbles', /[^, ]+/g);
         * // => ['fred', 'barney', '&', 'pebbles']
         */
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined$1 : pattern;

          if (pattern === undefined$1) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }

        /*------------------------------------------------------------------------*/

        /**
         * Attempts to invoke `func`, returning either the result or the caught error
         * object. Any additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Function} func The function to attempt.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {*} Returns the `func` result or error object.
         * @example
         *
         * // Avoid throwing errors for invalid selectors.
         * var elements = _.attempt(function(selector) {
         *   return document.querySelectorAll(selector);
         * }, '>_>');
         *
         * if (_.isError(elements)) {
         *   elements = [];
         * }
         */
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });

        /**
         * Binds methods of an object to the object itself, overwriting the existing
         * method.
         *
         * **Note:** This method doesn't set the "length" property of bound functions.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {Object} object The object to bind and assign the bound methods to.
         * @param {...(string|string[])} methodNames The object method names to bind.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var view = {
         *   'label': 'docs',
         *   'click': function() {
         *     console.log('clicked ' + this.label);
         *   }
         * };
         *
         * _.bindAll(view, ['click']);
         * jQuery(element).on('click', view.click);
         * // => Logs 'clicked docs' when clicked.
         */
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });

        /**
         * Creates a function that iterates over `pairs` and invokes the corresponding
         * function of the first predicate to return truthy. The predicate-function
         * pairs are invoked with the `this` binding and arguments of the created
         * function.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {Array} pairs The predicate-function pairs.
         * @returns {Function} Returns the new composite function.
         * @example
         *
         * var func = _.cond([
         *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
         *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
         *   [_.stubTrue,                      _.constant('no match')]
         * ]);
         *
         * func({ 'a': 1, 'b': 2 });
         * // => 'matches A'
         *
         * func({ 'a': 0, 'b': 1 });
         * // => 'matches B'
         *
         * func({ 'a': '1', 'b': '2' });
         * // => 'no match'
         */
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length,
              toIteratee = getIteratee();

          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });

          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }

        /**
         * Creates a function that invokes the predicate properties of `source` with
         * the corresponding property values of a given object, returning `true` if
         * all predicates return truthy, else `false`.
         *
         * **Note:** The created function is equivalent to `_.conformsTo` with
         * `source` partially applied.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {Object} source The object of property predicates to conform to.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 2, 'b': 1 },
         *   { 'a': 1, 'b': 2 }
         * ];
         *
         * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
         * // => [{ 'a': 1, 'b': 2 }]
         */
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new constant function.
         * @example
         *
         * var objects = _.times(2, _.constant({ 'a': 1 }));
         *
         * console.log(objects);
         * // => [{ 'a': 1 }, { 'a': 1 }]
         *
         * console.log(objects[0] === objects[1]);
         * // => true
         */
        function constant(value) {
          return function() {
            return value;
          };
        }

        /**
         * Checks `value` to determine whether a default value should be returned in
         * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
         * or `undefined`.
         *
         * @static
         * @memberOf _
         * @since 4.14.0
         * @category Util
         * @param {*} value The value to check.
         * @param {*} defaultValue The default value.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * _.defaultTo(1, 10);
         * // => 1
         *
         * _.defaultTo(undefined, 10);
         * // => 10
         */
        function defaultTo(value, defaultValue) {
          return (value == null || value !== value) ? defaultValue : value;
        }

        /**
         * Creates a function that returns the result of invoking the given functions
         * with the `this` binding of the created function, where each successive
         * invocation is supplied the return value of the previous.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {...(Function|Function[])} [funcs] The functions to invoke.
         * @returns {Function} Returns the new composite function.
         * @see _.flowRight
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flow([_.add, square]);
         * addSquare(1, 2);
         * // => 9
         */
        var flow = createFlow();

        /**
         * This method is like `_.flow` except that it creates a function that
         * invokes the given functions from right to left.
         *
         * @static
         * @since 3.0.0
         * @memberOf _
         * @category Util
         * @param {...(Function|Function[])} [funcs] The functions to invoke.
         * @returns {Function} Returns the new composite function.
         * @see _.flow
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flowRight([square, _.add]);
         * addSquare(1, 2);
         * // => 9
         */
        var flowRight = createFlow(true);

        /**
         * This method returns the first argument it receives.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'a': 1 };
         *
         * console.log(_.identity(object) === object);
         * // => true
         */
        function identity(value) {
          return value;
        }

        /**
         * Creates a function that invokes `func` with the arguments of the created
         * function. If `func` is a property name, the created function returns the
         * property value for a given element. If `func` is an array or object, the
         * created function returns `true` for elements that contain the equivalent
         * source properties, otherwise it returns `false`.
         *
         * @static
         * @since 4.0.0
         * @memberOf _
         * @category Util
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @returns {Function} Returns the callback.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
         * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.filter(users, _.iteratee(['user', 'fred']));
         * // => [{ 'user': 'fred', 'age': 40 }]
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, _.iteratee('user'));
         * // => ['barney', 'fred']
         *
         * // Create custom iteratee shorthands.
         * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
         *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
         *     return func.test(string);
         *   };
         * });
         *
         * _.filter(['abc', 'def'], /ef/);
         * // => ['def']
         */
        function iteratee(func) {
          return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that performs a partial deep comparison between a given
         * object and `source`, returning `true` if the given object has equivalent
         * property values, else `false`.
         *
         * **Note:** The created function is equivalent to `_.isMatch` with `source`
         * partially applied.
         *
         * Partial comparisons will match empty array and empty object `source`
         * values against any array or object value, respectively. See `_.isEqual`
         * for a list of supported value comparisons.
         *
         * **Note:** Multiple values can be checked by combining several matchers
         * using `_.overSome`
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 1, 'b': 2, 'c': 3 },
         *   { 'a': 4, 'b': 5, 'c': 6 }
         * ];
         *
         * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
         * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
         *
         * // Checking for several possible values
         * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
         * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
         */
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that performs a partial deep comparison between the
         * value at `path` of a given object to `srcValue`, returning `true` if the
         * object value is equivalent, else `false`.
         *
         * **Note:** Partial comparisons will match empty array and empty object
         * `srcValue` values against any array or object value, respectively. See
         * `_.isEqual` for a list of supported value comparisons.
         *
         * **Note:** Multiple values can be checked by combining several matchers
         * using `_.overSome`
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 1, 'b': 2, 'c': 3 },
         *   { 'a': 4, 'b': 5, 'c': 6 }
         * ];
         *
         * _.find(objects, _.matchesProperty('a', 4));
         * // => { 'a': 4, 'b': 5, 'c': 6 }
         *
         * // Checking for several possible values
         * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
         * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
         */
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that invokes the method at `path` of a given object.
         * Any additional arguments are provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Util
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new invoker function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': _.constant(2) } },
         *   { 'a': { 'b': _.constant(1) } }
         * ];
         *
         * _.map(objects, _.method('a.b'));
         * // => [2, 1]
         *
         * _.map(objects, _.method(['a', 'b']));
         * // => [2, 1]
         */
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });

        /**
         * The opposite of `_.method`; this method creates a function that invokes
         * the method at a given path of `object`. Any additional arguments are
         * provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Util
         * @param {Object} object The object to query.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new invoker function.
         * @example
         *
         * var array = _.times(3, _.constant),
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.methodOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
         * // => [2, 0]
         */
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });

        /**
         * Adds all own enumerable string keyed function properties of a source
         * object to the destination object. If `object` is a function, then methods
         * are added to its prototype as well.
         *
         * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
         * avoid conflicts caused by modifying the original.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {Function|Object} [object=lodash] The destination object.
         * @param {Object} source The object of functions to add.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
         * @returns {Function|Object} Returns `object`.
         * @example
         *
         * function vowels(string) {
         *   return _.filter(string, function(v) {
         *     return /[aeiou]/i.test(v);
         *   });
         * }
         *
         * _.mixin({ 'vowels': vowels });
         * _.vowels('fred');
         * // => ['e']
         *
         * _('fred').vowels().value();
         * // => ['e']
         *
         * _.mixin({ 'vowels': vowels }, { 'chain': false });
         * _('fred').vowels();
         * // => ['e']
         */
        function mixin(object, source, options) {
          var props = keys(source),
              methodNames = baseFunctions(source, props);

          if (options == null &&
              !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
              isFunc = isFunction(object);

          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain || chainAll) {
                  var result = object(this.__wrapped__),
                      actions = result.__actions__ = copyArray(this.__actions__);

                  actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                  result.__chain__ = chainAll;
                  return result;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });

          return object;
        }

        /**
         * Reverts the `_` variable to its previous value and returns a reference to
         * the `lodash` function.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @returns {Function} Returns the `lodash` function.
         * @example
         *
         * var lodash = _.noConflict();
         */
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }

        /**
         * This method returns `undefined`.
         *
         * @static
         * @memberOf _
         * @since 2.3.0
         * @category Util
         * @example
         *
         * _.times(2, _.noop);
         * // => [undefined, undefined]
         */
        function noop() {
          // No operation performed.
        }

        /**
         * Creates a function that gets the argument at index `n`. If `n` is negative,
         * the nth argument from the end is returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {number} [n=0] The index of the argument to return.
         * @returns {Function} Returns the new pass-thru function.
         * @example
         *
         * var func = _.nthArg(1);
         * func('a', 'b', 'c', 'd');
         * // => 'b'
         *
         * var func = _.nthArg(-2);
         * func('a', 'b', 'c', 'd');
         * // => 'c'
         */
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }

        /**
         * Creates a function that invokes `iteratees` with the arguments it receives
         * and returns their results.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [iteratees=[_.identity]]
         *  The iteratees to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.over([Math.max, Math.min]);
         *
         * func(1, 2, 3, 4);
         * // => [4, 1]
         */
        var over = createOver(arrayMap);

        /**
         * Creates a function that checks if **all** of the `predicates` return
         * truthy when invoked with the arguments it receives.
         *
         * Following shorthands are possible for providing predicates.
         * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
         * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [predicates=[_.identity]]
         *  The predicates to check.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.overEvery([Boolean, isFinite]);
         *
         * func('1');
         * // => true
         *
         * func(null);
         * // => false
         *
         * func(NaN);
         * // => false
         */
        var overEvery = createOver(arrayEvery);

        /**
         * Creates a function that checks if **any** of the `predicates` return
         * truthy when invoked with the arguments it receives.
         *
         * Following shorthands are possible for providing predicates.
         * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
         * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [predicates=[_.identity]]
         *  The predicates to check.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.overSome([Boolean, isFinite]);
         *
         * func('1');
         * // => true
         *
         * func(null);
         * // => true
         *
         * func(NaN);
         * // => false
         *
         * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
         * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
         */
        var overSome = createOver(arraySome);

        /**
         * Creates a function that returns the value at `path` of a given object.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': 2 } },
         *   { 'a': { 'b': 1 } }
         * ];
         *
         * _.map(objects, _.property('a.b'));
         * // => [2, 1]
         *
         * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
         * // => [1, 2]
         */
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }

        /**
         * The opposite of `_.property`; this method creates a function that returns
         * the value at a given path of `object`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var array = [0, 1, 2],
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
         * // => [2, 0]
         */
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined$1 : baseGet(object, path);
          };
        }

        /**
         * Creates an array of numbers (positive and/or negative) progressing from
         * `start` up to, but not including, `end`. A step of `-1` is used if a negative
         * `start` is specified without an `end` or `step`. If `end` is not specified,
         * it's set to `start` with `start` then set to `0`.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.rangeRight
         * @example
         *
         * _.range(4);
         * // => [0, 1, 2, 3]
         *
         * _.range(-4);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 5);
         * // => [1, 2, 3, 4]
         *
         * _.range(0, 20, 5);
         * // => [0, 5, 10, 15]
         *
         * _.range(0, -4, -1);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.range(0);
         * // => []
         */
        var range = createRange();

        /**
         * This method is like `_.range` except that it populates values in
         * descending order.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.range
         * @example
         *
         * _.rangeRight(4);
         * // => [3, 2, 1, 0]
         *
         * _.rangeRight(-4);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 5);
         * // => [4, 3, 2, 1]
         *
         * _.rangeRight(0, 20, 5);
         * // => [15, 10, 5, 0]
         *
         * _.rangeRight(0, -4, -1);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.rangeRight(0);
         * // => []
         */
        var rangeRight = createRange(true);

        /**
         * This method returns a new empty array.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Array} Returns the new empty array.
         * @example
         *
         * var arrays = _.times(2, _.stubArray);
         *
         * console.log(arrays);
         * // => [[], []]
         *
         * console.log(arrays[0] === arrays[1]);
         * // => false
         */
        function stubArray() {
          return [];
        }

        /**
         * This method returns `false`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `false`.
         * @example
         *
         * _.times(2, _.stubFalse);
         * // => [false, false]
         */
        function stubFalse() {
          return false;
        }

        /**
         * This method returns a new empty object.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Object} Returns the new empty object.
         * @example
         *
         * var objects = _.times(2, _.stubObject);
         *
         * console.log(objects);
         * // => [{}, {}]
         *
         * console.log(objects[0] === objects[1]);
         * // => false
         */
        function stubObject() {
          return {};
        }

        /**
         * This method returns an empty string.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {string} Returns the empty string.
         * @example
         *
         * _.times(2, _.stubString);
         * // => ['', '']
         */
        function stubString() {
          return '';
        }

        /**
         * This method returns `true`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `true`.
         * @example
         *
         * _.times(2, _.stubTrue);
         * // => [true, true]
         */
        function stubTrue() {
          return true;
        }

        /**
         * Invokes the iteratee `n` times, returning an array of the results of
         * each invocation. The iteratee is invoked with one argument; (index).
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.times(3, String);
         * // => ['0', '1', '2']
         *
         *  _.times(4, _.constant(0));
         * // => [0, 0, 0, 0]
         */
        function times(n, iteratee) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH,
              length = nativeMin(n, MAX_ARRAY_LENGTH);

          iteratee = getIteratee(iteratee);
          n -= MAX_ARRAY_LENGTH;

          var result = baseTimes(length, iteratee);
          while (++index < n) {
            iteratee(index);
          }
          return result;
        }

        /**
         * Converts `value` to a property path array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {*} value The value to convert.
         * @returns {Array} Returns the new property path array.
         * @example
         *
         * _.toPath('a.b.c');
         * // => ['a', 'b', 'c']
         *
         * _.toPath('a[0].b.c');
         * // => ['a', '0', 'b', 'c']
         */
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }

        /**
         * Generates a unique ID. If `prefix` is given, the ID is appended to it.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {string} [prefix=''] The value to prefix the ID with.
         * @returns {string} Returns the unique ID.
         * @example
         *
         * _.uniqueId('contact_');
         * // => 'contact_104'
         *
         * _.uniqueId();
         * // => '105'
         */
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }

        /*------------------------------------------------------------------------*/

        /**
         * Adds two numbers.
         *
         * @static
         * @memberOf _
         * @since 3.4.0
         * @category Math
         * @param {number} augend The first number in an addition.
         * @param {number} addend The second number in an addition.
         * @returns {number} Returns the total.
         * @example
         *
         * _.add(6, 4);
         * // => 10
         */
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);

        /**
         * Computes `number` rounded up to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round up.
         * @param {number} [precision=0] The precision to round up to.
         * @returns {number} Returns the rounded up number.
         * @example
         *
         * _.ceil(4.006);
         * // => 5
         *
         * _.ceil(6.004, 2);
         * // => 6.01
         *
         * _.ceil(6040, -2);
         * // => 6100
         */
        var ceil = createRound('ceil');

        /**
         * Divide two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {number} dividend The first number in a division.
         * @param {number} divisor The second number in a division.
         * @returns {number} Returns the quotient.
         * @example
         *
         * _.divide(6, 4);
         * // => 1.5
         */
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);

        /**
         * Computes `number` rounded down to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round down.
         * @param {number} [precision=0] The precision to round down to.
         * @returns {number} Returns the rounded down number.
         * @example
         *
         * _.floor(4.006);
         * // => 4
         *
         * _.floor(0.046, 2);
         * // => 0.04
         *
         * _.floor(4060, -2);
         * // => 4000
         */
        var floor = createRound('floor');

        /**
         * Computes the maximum value of `array`. If `array` is empty or falsey,
         * `undefined` is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * _.max([4, 2, 8, 6]);
         * // => 8
         *
         * _.max([]);
         * // => undefined
         */
        function max(array) {
          return (array && array.length)
            ? baseExtremum(array, identity, baseGt)
            : undefined$1;
        }

        /**
         * This method is like `_.max` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.maxBy(objects, function(o) { return o.n; });
         * // => { 'n': 2 }
         *
         * // The `_.property` iteratee shorthand.
         * _.maxBy(objects, 'n');
         * // => { 'n': 2 }
         */
        function maxBy(array, iteratee) {
          return (array && array.length)
            ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
            : undefined$1;
        }

        /**
         * Computes the mean of the values in `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the mean.
         * @example
         *
         * _.mean([4, 2, 8, 6]);
         * // => 5
         */
        function mean(array) {
          return baseMean(array, identity);
        }

        /**
         * This method is like `_.mean` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the value to be averaged.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the mean.
         * @example
         *
         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
         *
         * _.meanBy(objects, function(o) { return o.n; });
         * // => 5
         *
         * // The `_.property` iteratee shorthand.
         * _.meanBy(objects, 'n');
         * // => 5
         */
        function meanBy(array, iteratee) {
          return baseMean(array, getIteratee(iteratee, 2));
        }

        /**
         * Computes the minimum value of `array`. If `array` is empty or falsey,
         * `undefined` is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * _.min([4, 2, 8, 6]);
         * // => 2
         *
         * _.min([]);
         * // => undefined
         */
        function min(array) {
          return (array && array.length)
            ? baseExtremum(array, identity, baseLt)
            : undefined$1;
        }

        /**
         * This method is like `_.min` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.minBy(objects, function(o) { return o.n; });
         * // => { 'n': 1 }
         *
         * // The `_.property` iteratee shorthand.
         * _.minBy(objects, 'n');
         * // => { 'n': 1 }
         */
        function minBy(array, iteratee) {
          return (array && array.length)
            ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
            : undefined$1;
        }

        /**
         * Multiply two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {number} multiplier The first number in a multiplication.
         * @param {number} multiplicand The second number in a multiplication.
         * @returns {number} Returns the product.
         * @example
         *
         * _.multiply(6, 4);
         * // => 24
         */
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);

        /**
         * Computes `number` rounded to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round.
         * @param {number} [precision=0] The precision to round to.
         * @returns {number} Returns the rounded number.
         * @example
         *
         * _.round(4.006);
         * // => 4
         *
         * _.round(4.006, 2);
         * // => 4.01
         *
         * _.round(4060, -2);
         * // => 4100
         */
        var round = createRound('round');

        /**
         * Subtract two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {number} minuend The first number in a subtraction.
         * @param {number} subtrahend The second number in a subtraction.
         * @returns {number} Returns the difference.
         * @example
         *
         * _.subtract(6, 4);
         * // => 2
         */
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);

        /**
         * Computes the sum of the values in `array`.
         *
         * @static
         * @memberOf _
         * @since 3.4.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the sum.
         * @example
         *
         * _.sum([4, 2, 8, 6]);
         * // => 20
         */
        function sum(array) {
          return (array && array.length)
            ? baseSum(array, identity)
            : 0;
        }

        /**
         * This method is like `_.sum` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the value to be summed.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the sum.
         * @example
         *
         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
         *
         * _.sumBy(objects, function(o) { return o.n; });
         * // => 20
         *
         * // The `_.property` iteratee shorthand.
         * _.sumBy(objects, 'n');
         * // => 20
         */
        function sumBy(array, iteratee) {
          return (array && array.length)
            ? baseSum(array, getIteratee(iteratee, 2))
            : 0;
        }

        /*------------------------------------------------------------------------*/

        // Add methods that return wrapped values in chain sequences.
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;

        // Add aliases.
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;

        // Add methods to `lodash.prototype`.
        mixin(lodash, lodash);

        /*------------------------------------------------------------------------*/

        // Add methods that return unwrapped values in chain sequences.
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;

        // Add aliases.
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;

        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }()), { 'chain': false });

        /*------------------------------------------------------------------------*/

        /**
         * The semantic version number.
         *
         * @static
         * @memberOf _
         * @type {string}
         */
        lodash.VERSION = VERSION;

        // Assign default placeholders.
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });

        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

            var result = (this.__filtered__ && !index)
              ? new LazyWrapper(this)
              : this.clone();

            if (result.__filtered__) {
              result.__takeCount__ = nativeMin(n, result.__takeCount__);
            } else {
              result.__views__.push({
                'size': nativeMin(n, MAX_ARRAY_LENGTH),
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };

          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });

        // Add `LazyWrapper` methods that accept an `iteratee` value.
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

          LazyWrapper.prototype[methodName] = function(iteratee) {
            var result = this.clone();
            result.__iteratees__.push({
              'iteratee': getIteratee(iteratee, 3),
              'type': type
            });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });

        // Add `LazyWrapper` methods for `_.head` and `_.last`.
        arrayEach(['head', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');

          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });

        // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
        arrayEach(['initial', 'tail'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');

          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });

        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };

        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };

        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };

        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == 'function') {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });

        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };

        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);

          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };

        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };

        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };

        // Add `LazyWrapper` methods to `lodash.prototype`.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
              isTaker = /^(?:head|last)$/.test(methodName),
              lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
              retUnwrapped = isTaker || /^find/.test(methodName);

          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__,
                args = isTaker ? [1] : arguments,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);

            var interceptor = function(value) {
              var result = lodashFunc.apply(lodash, arrayPush([value], args));
              return (isTaker && chainAll) ? result[0] : result;
            };

            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              // Avoid lazy use if the iteratee has a "length" value other than `1`.
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__,
                isHybrid = !!this.__actions__.length,
                isUnwrapped = retUnwrapped && !chainAll,
                onlyLazy = isLazy && !isHybrid;

            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
              return new LodashWrapper(result, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result = this.thru(interceptor);
            return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
          };
        });

        // Add `Array` methods to `lodash.prototype`.
        arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
          var func = arrayProto[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:pop|shift)$/.test(methodName);

          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value) {
              return func.apply(isArray(value) ? value : [], args);
            });
          };
        });

        // Map minified method names to their real names.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + '';
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ 'name': methodName, 'func': lodashFunc });
          }
        });

        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          'name': 'wrapper',
          'func': undefined$1
        }];

        // Add methods to `LazyWrapper`.
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;

        // Add chain sequence methods to the `lodash` wrapper.
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

        // Add lazy aliases.
        lodash.prototype.first = lodash.prototype.head;

        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      });

      /*--------------------------------------------------------------------------*/

      // Export lodash.
      var _ = runInContext();

      // Some AMD build optimizers, like r.js, check for condition patterns like:
      if (freeModule) {
        // Export for Node.js.
        (freeModule.exports = _)._ = _;
        // Export for CommonJS support.
        freeExports._ = _;
      }
      else {
        // Export to the global object.
        root._ = _;
      }
    }.call(commonjsGlobal));
    });

    /* src/flowCanvas/controls/ColumnControlToggle.svelte generated by Svelte v3.44.2 */

    const { console: console_1$1 } = globals;
    const file$g = "src/flowCanvas/controls/ColumnControlToggle.svelte";

    function create_fragment$h(ctx) {
    	let div;
    	let input;
    	let input_id_value;
    	let input_name_value;
    	let t0;
    	let label;
    	let t1;
    	let label_for_value;
    	let t2;
    	let span;
    	let t3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t0 = space();
    			label = element("label");
    			t1 = text(/*displayChar*/ ctx[4]);
    			t2 = space();
    			span = element("span");
    			t3 = text(/*tooltip*/ ctx[3]);
    			attr_dev(input, "id", input_id_value = `is${lodash.capitalize(/*name*/ ctx[2])}_${/*id*/ ctx[1]}`);
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "name", input_name_value = /*name*/ ctx[2].replace(" ", "_"));
    			attr_dev(input, "class", "svelte-15270yy");
    			add_location(input, file$g, 12, 2, 335);
    			attr_dev(label, "for", label_for_value = `is${lodash.capitalize(/*name*/ ctx[2])}_${/*id*/ ctx[1]}`);
    			attr_dev(label, "class", "svelte-15270yy");
    			add_location(label, file$g, 18, 2, 467);
    			attr_dev(span, "class", "tooltip svelte-15270yy");
    			add_location(span, file$g, 19, 2, 534);
    			attr_dev(div, "class", "noGrow svelte-15270yy");
    			add_location(div, file$g, 11, 0, 312);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			input.checked = /*value*/ ctx[0];
    			append_dev(div, t0);
    			append_dev(div, label);
    			append_dev(label, t1);
    			append_dev(div, t2);
    			append_dev(div, span);
    			append_dev(span, t3);

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[5]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*name, id*/ 6 && input_id_value !== (input_id_value = `is${lodash.capitalize(/*name*/ ctx[2])}_${/*id*/ ctx[1]}`)) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty & /*name*/ 4 && input_name_value !== (input_name_value = /*name*/ ctx[2].replace(" ", "_"))) {
    				attr_dev(input, "name", input_name_value);
    			}

    			if (dirty & /*value*/ 1) {
    				input.checked = /*value*/ ctx[0];
    			}

    			if (dirty & /*displayChar*/ 16) set_data_dev(t1, /*displayChar*/ ctx[4]);

    			if (dirty & /*name, id*/ 6 && label_for_value !== (label_for_value = `is${lodash.capitalize(/*name*/ ctx[2])}_${/*id*/ ctx[1]}`)) {
    				attr_dev(label, "for", label_for_value);
    			}

    			if (dirty & /*tooltip*/ 8) set_data_dev(t3, /*tooltip*/ ctx[3]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ColumnControlToggle', slots, []);
    	console.debug("toggle");
    	let { id = nanoid() } = $$props;
    	let { value } = $$props;
    	let { name } = $$props;
    	let { tooltip = `${lodash.capitalize(name)}?` } = $$props;
    	let { displayChar = name[0].toUpperCase() } = $$props;
    	const writable_props = ['id', 'value', 'name', 'tooltip', 'displayChar'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<ColumnControlToggle> was created with unknown prop '${key}'`);
    	});

    	function input_change_handler() {
    		value = this.checked;
    		$$invalidate(0, value);
    	}

    	$$self.$$set = $$props => {
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('name' in $$props) $$invalidate(2, name = $$props.name);
    		if ('tooltip' in $$props) $$invalidate(3, tooltip = $$props.tooltip);
    		if ('displayChar' in $$props) $$invalidate(4, displayChar = $$props.displayChar);
    	};

    	$$self.$capture_state = () => ({
    		capitalize: lodash.capitalize,
    		nanoid,
    		id,
    		value,
    		name,
    		tooltip,
    		displayChar
    	});

    	$$self.$inject_state = $$props => {
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('name' in $$props) $$invalidate(2, name = $$props.name);
    		if ('tooltip' in $$props) $$invalidate(3, tooltip = $$props.tooltip);
    		if ('displayChar' in $$props) $$invalidate(4, displayChar = $$props.displayChar);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 1) {
    			console.log(value);
    		}
    	};

    	return [value, id, name, tooltip, displayChar, input_change_handler];
    }

    class ColumnControlToggle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {
    			id: 1,
    			value: 0,
    			name: 2,
    			tooltip: 3,
    			displayChar: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ColumnControlToggle",
    			options,
    			id: create_fragment$h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[0] === undefined && !('value' in props)) {
    			console_1$1.warn("<ColumnControlToggle> was created without expected prop 'value'");
    		}

    		if (/*name*/ ctx[2] === undefined && !('name' in props)) {
    			console_1$1.warn("<ColumnControlToggle> was created without expected prop 'name'");
    		}
    	}

    	get id() {
    		throw new Error("<ColumnControlToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<ColumnControlToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<ColumnControlToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<ColumnControlToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<ColumnControlToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<ColumnControlToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<ColumnControlToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<ColumnControlToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get displayChar() {
    		throw new Error("<ColumnControlToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set displayChar(value) {
    		throw new Error("<ColumnControlToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/flowCanvas/controls/ColumnControlGroup.svelte generated by Svelte v3.44.2 */
    const file$f = "src/flowCanvas/controls/ColumnControlGroup.svelte";

    // (20:4) {:else}
    function create_else_block$1(ctx) {
    	let label;
    	let t0;
    	let label_for_value;
    	let t1;
    	let input;
    	let input_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			label = element("label");
    			t0 = text("Column: Datatype");
    			t1 = space();
    			input = element("input");
    			attr_dev(label, "for", label_for_value = `datatype_${/*id*/ ctx[2]}`);
    			attr_dev(label, "class", "textLabel svelte-181fm5q");
    			add_location(label, file$f, 20, 6, 556);
    			attr_dev(input, "id", input_id_value = `datatype_${/*id*/ ctx[2]}`);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "name", "datatype");
    			input.disabled = /*disabled*/ ctx[1];
    			attr_dev(input, "class", "svelte-181fm5q");
    			add_location(input, file$f, 21, 6, 635);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*columnDefinition*/ ctx[0]["datatype"]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler_1*/ ctx[5]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*id*/ 4 && label_for_value !== (label_for_value = `datatype_${/*id*/ ctx[2]}`)) {
    				attr_dev(label, "for", label_for_value);
    			}

    			if (dirty & /*id*/ 4 && input_id_value !== (input_id_value = `datatype_${/*id*/ ctx[2]}`)) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty & /*disabled*/ 2) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[1]);
    			}

    			if (dirty & /*columnDefinition*/ 1 && input.value !== /*columnDefinition*/ ctx[0]["datatype"]) {
    				set_input_value(input, /*columnDefinition*/ ctx[0]["datatype"]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(20:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (10:4) {#if toggleDatatype === false}
    function create_if_block$3(ctx) {
    	let label;
    	let t0;
    	let label_for_value;
    	let t1;
    	let input;
    	let input_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			label = element("label");
    			t0 = text("Column: Name");
    			t1 = space();
    			input = element("input");
    			attr_dev(label, "for", label_for_value = `name_${/*id*/ ctx[2]}`);
    			attr_dev(label, "class", "textLabel svelte-181fm5q");
    			add_location(label, file$f, 10, 6, 278);
    			attr_dev(input, "id", input_id_value = `name_${/*id*/ ctx[2]}`);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "name", "name");
    			attr_dev(input, "pattern", "[A-Za-z_]+[A-Za-z0-9_]*");
    			input.disabled = /*disabled*/ ctx[1];
    			attr_dev(input, "class", "svelte-181fm5q");
    			add_location(input, file$f, 11, 6, 349);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*columnDefinition*/ ctx[0]["name"]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[4]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*id*/ 4 && label_for_value !== (label_for_value = `name_${/*id*/ ctx[2]}`)) {
    				attr_dev(label, "for", label_for_value);
    			}

    			if (dirty & /*id*/ 4 && input_id_value !== (input_id_value = `name_${/*id*/ ctx[2]}`)) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty & /*disabled*/ 2) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[1]);
    			}

    			if (dirty & /*columnDefinition*/ 1 && input.value !== /*columnDefinition*/ ctx[0]["name"]) {
    				set_input_value(input, /*columnDefinition*/ ctx[0]["name"]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(10:4) {#if toggleDatatype === false}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let columncontroltoggle0;
    	let updating_value;
    	let t1;
    	let columncontroltoggle1;
    	let updating_value_1;
    	let t2;
    	let columncontroltoggle2;
    	let updating_value_2;
    	let t3;
    	let columncontroltoggle3;
    	let updating_value_3;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (/*toggleDatatype*/ ctx[3] === false) return create_if_block$3;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	function columncontroltoggle0_value_binding(value) {
    		/*columncontroltoggle0_value_binding*/ ctx[6](value);
    	}

    	let columncontroltoggle0_props = {
    		name: "set datatype",
    		tooltip: "set datatype...",
    		displayChar: "D",
    		id: /*id*/ ctx[2]
    	};

    	if (/*toggleDatatype*/ ctx[3] !== void 0) {
    		columncontroltoggle0_props.value = /*toggleDatatype*/ ctx[3];
    	}

    	columncontroltoggle0 = new ColumnControlToggle({
    			props: columncontroltoggle0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(columncontroltoggle0, 'value', columncontroltoggle0_value_binding));

    	function columncontroltoggle1_value_binding(value) {
    		/*columncontroltoggle1_value_binding*/ ctx[7](value);
    	}

    	let columncontroltoggle1_props = { name: "primary key", id: /*id*/ ctx[2] };

    	if (/*columnDefinition*/ ctx[0]["primaryKey"] !== void 0) {
    		columncontroltoggle1_props.value = /*columnDefinition*/ ctx[0]["primaryKey"];
    	}

    	columncontroltoggle1 = new ColumnControlToggle({
    			props: columncontroltoggle1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(columncontroltoggle1, 'value', columncontroltoggle1_value_binding));

    	function columncontroltoggle2_value_binding(value) {
    		/*columncontroltoggle2_value_binding*/ ctx[8](value);
    	}

    	let columncontroltoggle2_props = { name: "nullable", id: /*id*/ ctx[2] };

    	if (/*columnDefinition*/ ctx[0]["nullable"] !== void 0) {
    		columncontroltoggle2_props.value = /*columnDefinition*/ ctx[0]["nullable"];
    	}

    	columncontroltoggle2 = new ColumnControlToggle({
    			props: columncontroltoggle2_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(columncontroltoggle2, 'value', columncontroltoggle2_value_binding));

    	function columncontroltoggle3_value_binding(value) {
    		/*columncontroltoggle3_value_binding*/ ctx[9](value);
    	}

    	let columncontroltoggle3_props = { name: "unique", id: /*id*/ ctx[2] };

    	if (/*columnDefinition*/ ctx[0]["unique"] !== void 0) {
    		columncontroltoggle3_props.value = /*columnDefinition*/ ctx[0]["unique"];
    	}

    	columncontroltoggle3 = new ColumnControlToggle({
    			props: columncontroltoggle3_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(columncontroltoggle3, 'value', columncontroltoggle3_value_binding));

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if_block.c();
    			t0 = space();
    			create_component(columncontroltoggle0.$$.fragment);
    			t1 = space();
    			create_component(columncontroltoggle1.$$.fragment);
    			t2 = space();
    			create_component(columncontroltoggle2.$$.fragment);
    			t3 = space();
    			create_component(columncontroltoggle3.$$.fragment);
    			attr_dev(div0, "class", "grow svelte-181fm5q");
    			add_location(div0, file$f, 8, 2, 218);
    			attr_dev(div1, "class", "wrapper svelte-181fm5q");
    			add_location(div1, file$f, 7, 0, 194);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if_block.m(div0, null);
    			append_dev(div1, t0);
    			mount_component(columncontroltoggle0, div1, null);
    			append_dev(div1, t1);
    			mount_component(columncontroltoggle1, div1, null);
    			append_dev(div1, t2);
    			mount_component(columncontroltoggle2, div1, null);
    			append_dev(div1, t3);
    			mount_component(columncontroltoggle3, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			}

    			const columncontroltoggle0_changes = {};
    			if (dirty & /*id*/ 4) columncontroltoggle0_changes.id = /*id*/ ctx[2];

    			if (!updating_value && dirty & /*toggleDatatype*/ 8) {
    				updating_value = true;
    				columncontroltoggle0_changes.value = /*toggleDatatype*/ ctx[3];
    				add_flush_callback(() => updating_value = false);
    			}

    			columncontroltoggle0.$set(columncontroltoggle0_changes);
    			const columncontroltoggle1_changes = {};
    			if (dirty & /*id*/ 4) columncontroltoggle1_changes.id = /*id*/ ctx[2];

    			if (!updating_value_1 && dirty & /*columnDefinition*/ 1) {
    				updating_value_1 = true;
    				columncontroltoggle1_changes.value = /*columnDefinition*/ ctx[0]["primaryKey"];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			columncontroltoggle1.$set(columncontroltoggle1_changes);
    			const columncontroltoggle2_changes = {};
    			if (dirty & /*id*/ 4) columncontroltoggle2_changes.id = /*id*/ ctx[2];

    			if (!updating_value_2 && dirty & /*columnDefinition*/ 1) {
    				updating_value_2 = true;
    				columncontroltoggle2_changes.value = /*columnDefinition*/ ctx[0]["nullable"];
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			columncontroltoggle2.$set(columncontroltoggle2_changes);
    			const columncontroltoggle3_changes = {};
    			if (dirty & /*id*/ 4) columncontroltoggle3_changes.id = /*id*/ ctx[2];

    			if (!updating_value_3 && dirty & /*columnDefinition*/ 1) {
    				updating_value_3 = true;
    				columncontroltoggle3_changes.value = /*columnDefinition*/ ctx[0]["unique"];
    				add_flush_callback(() => updating_value_3 = false);
    			}

    			columncontroltoggle3.$set(columncontroltoggle3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(columncontroltoggle0.$$.fragment, local);
    			transition_in(columncontroltoggle1.$$.fragment, local);
    			transition_in(columncontroltoggle2.$$.fragment, local);
    			transition_in(columncontroltoggle3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(columncontroltoggle0.$$.fragment, local);
    			transition_out(columncontroltoggle1.$$.fragment, local);
    			transition_out(columncontroltoggle2.$$.fragment, local);
    			transition_out(columncontroltoggle3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if_block.d();
    			destroy_component(columncontroltoggle0);
    			destroy_component(columncontroltoggle1);
    			destroy_component(columncontroltoggle2);
    			destroy_component(columncontroltoggle3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ColumnControlGroup', slots, []);
    	let { columnDefinition } = $$props;
    	let { disabled = false } = $$props;
    	let { id } = $$props;
    	let toggleDatatype = false;
    	const writable_props = ['columnDefinition', 'disabled', 'id'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ColumnControlGroup> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		columnDefinition["name"] = this.value;
    		$$invalidate(0, columnDefinition);
    	}

    	function input_input_handler_1() {
    		columnDefinition["datatype"] = this.value;
    		$$invalidate(0, columnDefinition);
    	}

    	function columncontroltoggle0_value_binding(value) {
    		toggleDatatype = value;
    		$$invalidate(3, toggleDatatype);
    	}

    	function columncontroltoggle1_value_binding(value) {
    		if ($$self.$$.not_equal(columnDefinition["primaryKey"], value)) {
    			columnDefinition["primaryKey"] = value;
    			$$invalidate(0, columnDefinition);
    		}
    	}

    	function columncontroltoggle2_value_binding(value) {
    		if ($$self.$$.not_equal(columnDefinition["nullable"], value)) {
    			columnDefinition["nullable"] = value;
    			$$invalidate(0, columnDefinition);
    		}
    	}

    	function columncontroltoggle3_value_binding(value) {
    		if ($$self.$$.not_equal(columnDefinition["unique"], value)) {
    			columnDefinition["unique"] = value;
    			$$invalidate(0, columnDefinition);
    		}
    	}

    	$$self.$$set = $$props => {
    		if ('columnDefinition' in $$props) $$invalidate(0, columnDefinition = $$props.columnDefinition);
    		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
    		if ('id' in $$props) $$invalidate(2, id = $$props.id);
    	};

    	$$self.$capture_state = () => ({
    		ColumnControlToggle,
    		columnDefinition,
    		disabled,
    		id,
    		toggleDatatype
    	});

    	$$self.$inject_state = $$props => {
    		if ('columnDefinition' in $$props) $$invalidate(0, columnDefinition = $$props.columnDefinition);
    		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
    		if ('id' in $$props) $$invalidate(2, id = $$props.id);
    		if ('toggleDatatype' in $$props) $$invalidate(3, toggleDatatype = $$props.toggleDatatype);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		columnDefinition,
    		disabled,
    		id,
    		toggleDatatype,
    		input_input_handler,
    		input_input_handler_1,
    		columncontroltoggle0_value_binding,
    		columncontroltoggle1_value_binding,
    		columncontroltoggle2_value_binding,
    		columncontroltoggle3_value_binding
    	];
    }

    class ColumnControlGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { columnDefinition: 0, disabled: 1, id: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ColumnControlGroup",
    			options,
    			id: create_fragment$g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*columnDefinition*/ ctx[0] === undefined && !('columnDefinition' in props)) {
    			console.warn("<ColumnControlGroup> was created without expected prop 'columnDefinition'");
    		}

    		if (/*id*/ ctx[2] === undefined && !('id' in props)) {
    			console.warn("<ColumnControlGroup> was created without expected prop 'id'");
    		}
    	}

    	get columnDefinition() {
    		throw new Error("<ColumnControlGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set columnDefinition(value) {
    		throw new Error("<ColumnControlGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<ColumnControlGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<ColumnControlGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<ColumnControlGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<ColumnControlGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/flowCanvas/controls/ButtonControl.svelte generated by Svelte v3.44.2 */
    const file$e = "src/flowCanvas/controls/ButtonControl.svelte";

    function create_fragment$f(ctx) {
    	let button;
    	let button_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();

    			attr_dev(button, "class", button_class_value = "" + (null_to_empty(`${/*variant*/ ctx[0]} ${/*fontSize*/ ctx[1] === "large"
			? "text-large"
			: "text-regular"}`) + " svelte-1xwf7kj"));

    			add_location(button, file$e, 6, 0, 147);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					prevent_default(function () {
    						if (is_function(/*handleClick*/ ctx[2])) /*handleClick*/ ctx[2].apply(this, arguments);
    					}),
    					false,
    					true,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*variant, fontSize*/ 3 && button_class_value !== (button_class_value = "" + (null_to_empty(`${/*variant*/ ctx[0]} ${/*fontSize*/ ctx[1] === "large"
			? "text-large"
			: "text-regular"}`) + " svelte-1xwf7kj"))) {
    				attr_dev(button, "class", button_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ButtonControl', slots, ['default']);
    	let { variant = "primary" } = $$props;
    	let { fontSize = "regular" } = $$props;

    	let { handleClick = () => {
    		
    	} } = $$props;

    	const writable_props = ['variant', 'fontSize', 'handleClick'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ButtonControl> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('variant' in $$props) $$invalidate(0, variant = $$props.variant);
    		if ('fontSize' in $$props) $$invalidate(1, fontSize = $$props.fontSize);
    		if ('handleClick' in $$props) $$invalidate(2, handleClick = $$props.handleClick);
    		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ variant, fontSize, handleClick });

    	$$self.$inject_state = $$props => {
    		if ('variant' in $$props) $$invalidate(0, variant = $$props.variant);
    		if ('fontSize' in $$props) $$invalidate(1, fontSize = $$props.fontSize);
    		if ('handleClick' in $$props) $$invalidate(2, handleClick = $$props.handleClick);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [variant, fontSize, handleClick, $$scope, slots];
    }

    class ButtonControl extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { variant: 0, fontSize: 1, handleClick: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ButtonControl",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get variant() {
    		throw new Error("<ButtonControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error("<ButtonControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontSize() {
    		throw new Error("<ButtonControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontSize(value) {
    		throw new Error("<ButtonControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get handleClick() {
    		throw new Error("<ButtonControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set handleClick(value) {
    		throw new Error("<ButtonControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function cleanTableDefinition(tableDefinition) {
        var _a, _b, _c;
        tableDefinition.schema = (_a = tableDefinition.schema) !== null && _a !== void 0 ? _a : "";
        tableDefinition.database = (_b = tableDefinition.database) !== null && _b !== void 0 ? _b : "";
        tableDefinition.materialised = (_c = tableDefinition.materialised) !== null && _c !== void 0 ? _c : false;
        tableDefinition.columns = tableDefinition.columns.map((c) => {
            var _a;
            return Object.assign(Object.assign({}, c), { id: (_a = c.id) !== null && _a !== void 0 ? _a : safeid() });
        });
        return tableDefinition;
    }

    /* src/flowCanvas/components/TableForm.svelte generated by Svelte v3.44.2 */
    const file$d = "src/flowCanvas/components/TableForm.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[7] = list;
    	child_ctx[8] = i;
    	return child_ctx;
    }

    // (48:4) <Connectable id={`col_${column.id}`}>
    function create_default_slot_1$2(ctx) {
    	let columncontrolgroup;
    	let updating_columnDefinition;
    	let current;

    	function columncontrolgroup_columnDefinition_binding(value) {
    		/*columncontrolgroup_columnDefinition_binding*/ ctx[5](value, /*idx*/ ctx[8]);
    	}

    	let columncontrolgroup_props = { id: /*column*/ ctx[6].id };

    	if (/*formContext*/ ctx[0].columns[/*idx*/ ctx[8]] !== void 0) {
    		columncontrolgroup_props.columnDefinition = /*formContext*/ ctx[0].columns[/*idx*/ ctx[8]];
    	}

    	columncontrolgroup = new ColumnControlGroup({
    			props: columncontrolgroup_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(columncontrolgroup, 'columnDefinition', columncontrolgroup_columnDefinition_binding));

    	const block = {
    		c: function create() {
    			create_component(columncontrolgroup.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(columncontrolgroup, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const columncontrolgroup_changes = {};
    			if (dirty & /*formContext*/ 1) columncontrolgroup_changes.id = /*column*/ ctx[6].id;

    			if (!updating_columnDefinition && dirty & /*formContext*/ 1) {
    				updating_columnDefinition = true;
    				columncontrolgroup_changes.columnDefinition = /*formContext*/ ctx[0].columns[/*idx*/ ctx[8]];
    				add_flush_callback(() => updating_columnDefinition = false);
    			}

    			columncontrolgroup.$set(columncontrolgroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(columncontrolgroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(columncontrolgroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(columncontrolgroup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(48:4) <Connectable id={`col_${column.id}`}>",
    		ctx
    	});

    	return block;
    }

    // (47:2) {#each formContext.columns as column, idx}
    function create_each_block$3(ctx) {
    	let connectable;
    	let current;

    	connectable = new Connectable({
    			props: {
    				id: `col_${/*column*/ ctx[6].id}`,
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(connectable.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(connectable, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const connectable_changes = {};
    			if (dirty & /*formContext*/ 1) connectable_changes.id = `col_${/*column*/ ctx[6].id}`;

    			if (dirty & /*$$scope, formContext*/ 513) {
    				connectable_changes.$$scope = { dirty, ctx };
    			}

    			connectable.$set(connectable_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(connectable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(connectable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(connectable, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(47:2) {#each formContext.columns as column, idx}",
    		ctx
    	});

    	return block;
    }

    // (55:2) <ButtonControl fontSize="large" handleClick={handleAddColumn}     >
    function create_default_slot$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Add Column");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(55:2) <ButtonControl fontSize=\\\"large\\\" handleClick={handleAddColumn}     >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let form;
    	let inputcontrol0;
    	let updating_value;
    	let t0;
    	let inputcontrol1;
    	let updating_value_1;
    	let t1;
    	let inputcontrol2;
    	let updating_value_2;
    	let t2;
    	let t3;
    	let buttoncontrol;
    	let current;

    	function inputcontrol0_value_binding(value) {
    		/*inputcontrol0_value_binding*/ ctx[2](value);
    	}

    	let inputcontrol0_props = {
    		name: "table",
    		type: "text",
    		label: "Name"
    	};

    	if (/*formContext*/ ctx[0].name !== void 0) {
    		inputcontrol0_props.value = /*formContext*/ ctx[0].name;
    	}

    	inputcontrol0 = new InputControl({
    			props: inputcontrol0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(inputcontrol0, 'value', inputcontrol0_value_binding));

    	function inputcontrol1_value_binding(value) {
    		/*inputcontrol1_value_binding*/ ctx[3](value);
    	}

    	let inputcontrol1_props = {
    		name: "schema",
    		type: "text",
    		label: "Schema"
    	};

    	if (/*formContext*/ ctx[0].schema !== void 0) {
    		inputcontrol1_props.value = /*formContext*/ ctx[0].schema;
    	}

    	inputcontrol1 = new InputControl({
    			props: inputcontrol1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(inputcontrol1, 'value', inputcontrol1_value_binding));

    	function inputcontrol2_value_binding(value) {
    		/*inputcontrol2_value_binding*/ ctx[4](value);
    	}

    	let inputcontrol2_props = {
    		name: "database",
    		type: "text",
    		label: "Database"
    	};

    	if (/*formContext*/ ctx[0].database !== void 0) {
    		inputcontrol2_props.value = /*formContext*/ ctx[0].database;
    	}

    	inputcontrol2 = new InputControl({
    			props: inputcontrol2_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(inputcontrol2, 'value', inputcontrol2_value_binding));
    	let each_value = /*formContext*/ ctx[0].columns;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	buttoncontrol = new ButtonControl({
    			props: {
    				fontSize: "large",
    				handleClick: /*handleAddColumn*/ ctx[1],
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			form = element("form");
    			create_component(inputcontrol0.$$.fragment);
    			t0 = space();
    			create_component(inputcontrol1.$$.fragment);
    			t1 = space();
    			create_component(inputcontrol2.$$.fragment);
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			create_component(buttoncontrol.$$.fragment);
    			attr_dev(form, "class", "svelte-11ckd0c");
    			add_location(form, file$d, 27, 0, 875);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			mount_component(inputcontrol0, form, null);
    			append_dev(form, t0);
    			mount_component(inputcontrol1, form, null);
    			append_dev(form, t1);
    			mount_component(inputcontrol2, form, null);
    			append_dev(form, t2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(form, null);
    			}

    			append_dev(form, t3);
    			mount_component(buttoncontrol, form, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const inputcontrol0_changes = {};

    			if (!updating_value && dirty & /*formContext*/ 1) {
    				updating_value = true;
    				inputcontrol0_changes.value = /*formContext*/ ctx[0].name;
    				add_flush_callback(() => updating_value = false);
    			}

    			inputcontrol0.$set(inputcontrol0_changes);
    			const inputcontrol1_changes = {};

    			if (!updating_value_1 && dirty & /*formContext*/ 1) {
    				updating_value_1 = true;
    				inputcontrol1_changes.value = /*formContext*/ ctx[0].schema;
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			inputcontrol1.$set(inputcontrol1_changes);
    			const inputcontrol2_changes = {};

    			if (!updating_value_2 && dirty & /*formContext*/ 1) {
    				updating_value_2 = true;
    				inputcontrol2_changes.value = /*formContext*/ ctx[0].database;
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			inputcontrol2.$set(inputcontrol2_changes);

    			if (dirty & /*formContext*/ 1) {
    				each_value = /*formContext*/ ctx[0].columns;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(form, t3);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const buttoncontrol_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				buttoncontrol_changes.$$scope = { dirty, ctx };
    			}

    			buttoncontrol.$set(buttoncontrol_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inputcontrol0.$$.fragment, local);
    			transition_in(inputcontrol1.$$.fragment, local);
    			transition_in(inputcontrol2.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(buttoncontrol.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inputcontrol0.$$.fragment, local);
    			transition_out(inputcontrol1.$$.fragment, local);
    			transition_out(inputcontrol2.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(buttoncontrol.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(inputcontrol0);
    			destroy_component(inputcontrol1);
    			destroy_component(inputcontrol2);
    			destroy_each(each_blocks, detaching);
    			destroy_component(buttoncontrol);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TableForm', slots, []);
    	let { formContext } = $$props;

    	if (formContext !== undefined) {
    		formContext = cleanTableDefinition(formContext);
    	}

    	function handleAddColumn(event) {
    		const id = safeid();
    		const name = `col_${id}`;

    		const columnDefinition = {
    			id,
    			name,
    			primaryKey: false,
    			nullable: false,
    			unique: false,
    			datatype: "VARCHAR",
    			materialised: false
    		};

    		// for svelte auto update
    		$$invalidate(0, formContext.columns = [...formContext.columns, columnDefinition], formContext);
    	}

    	const writable_props = ['formContext'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TableForm> was created with unknown prop '${key}'`);
    	});

    	function inputcontrol0_value_binding(value) {
    		if ($$self.$$.not_equal(formContext.name, value)) {
    			formContext.name = value;
    			$$invalidate(0, formContext);
    		}
    	}

    	function inputcontrol1_value_binding(value) {
    		if ($$self.$$.not_equal(formContext.schema, value)) {
    			formContext.schema = value;
    			$$invalidate(0, formContext);
    		}
    	}

    	function inputcontrol2_value_binding(value) {
    		if ($$self.$$.not_equal(formContext.database, value)) {
    			formContext.database = value;
    			$$invalidate(0, formContext);
    		}
    	}

    	function columncontrolgroup_columnDefinition_binding(value, idx) {
    		if ($$self.$$.not_equal(formContext.columns[idx], value)) {
    			formContext.columns[idx] = value;
    			$$invalidate(0, formContext);
    		}
    	}

    	$$self.$$set = $$props => {
    		if ('formContext' in $$props) $$invalidate(0, formContext = $$props.formContext);
    	};

    	$$self.$capture_state = () => ({
    		safeid,
    		InputControl,
    		Connectable,
    		ColumnControlGroup,
    		ButtonControl,
    		cleanTableDefinition,
    		formContext,
    		handleAddColumn
    	});

    	$$self.$inject_state = $$props => {
    		if ('formContext' in $$props) $$invalidate(0, formContext = $$props.formContext);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		formContext,
    		handleAddColumn,
    		inputcontrol0_value_binding,
    		inputcontrol1_value_binding,
    		inputcontrol2_value_binding,
    		columncontrolgroup_columnDefinition_binding
    	];
    }

    class TableForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { formContext: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableForm",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*formContext*/ ctx[0] === undefined && !('formContext' in props)) {
    			console.warn("<TableForm> was created without expected prop 'formContext'");
    		}
    	}

    	get formContext() {
    		throw new Error("<TableForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set formContext(value) {
    		throw new Error("<TableForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/flowCanvas/components/TransformForm.svelte generated by Svelte v3.44.2 */
    const file$c = "src/flowCanvas/components/TransformForm.svelte";

    // (9:2) <Connectable id={`tx_${id}`}>
    function create_default_slot$5(ctx) {
    	let inputcontrol;
    	let updating_value;
    	let current;

    	function inputcontrol_value_binding(value) {
    		/*inputcontrol_value_binding*/ ctx[2](value);
    	}

    	let inputcontrol_props = {
    		name: "transform",
    		type: "text",
    		label: "Transform"
    	};

    	if (/*formContext*/ ctx[0].transform !== void 0) {
    		inputcontrol_props.value = /*formContext*/ ctx[0].transform;
    	}

    	inputcontrol = new InputControl({
    			props: inputcontrol_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(inputcontrol, 'value', inputcontrol_value_binding));

    	const block = {
    		c: function create() {
    			create_component(inputcontrol.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(inputcontrol, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const inputcontrol_changes = {};

    			if (!updating_value && dirty & /*formContext*/ 1) {
    				updating_value = true;
    				inputcontrol_changes.value = /*formContext*/ ctx[0].transform;
    				add_flush_callback(() => updating_value = false);
    			}

    			inputcontrol.$set(inputcontrol_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inputcontrol.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inputcontrol.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(inputcontrol, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(9:2) <Connectable id={`tx_${id}`}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let form;
    	let connectable;
    	let t;
    	let inputcontrol;
    	let updating_value;
    	let current;

    	connectable = new Connectable({
    			props: {
    				id: `tx_${/*id*/ ctx[1]}`,
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function inputcontrol_value_binding_1(value) {
    		/*inputcontrol_value_binding_1*/ ctx[3](value);
    	}

    	let inputcontrol_props = {
    		name: "filter",
    		type: "text",
    		label: "Filter"
    	};

    	if (/*formContext*/ ctx[0].filter !== void 0) {
    		inputcontrol_props.value = /*formContext*/ ctx[0].filter;
    	}

    	inputcontrol = new InputControl({
    			props: inputcontrol_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(inputcontrol, 'value', inputcontrol_value_binding_1));

    	const block = {
    		c: function create() {
    			form = element("form");
    			create_component(connectable.$$.fragment);
    			t = space();
    			create_component(inputcontrol.$$.fragment);
    			attr_dev(form, "id", /*id*/ ctx[1]);
    			attr_dev(form, "class", "svelte-11ckd0c");
    			add_location(form, file$c, 7, 0, 219);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			mount_component(connectable, form, null);
    			append_dev(form, t);
    			mount_component(inputcontrol, form, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const connectable_changes = {};
    			if (dirty & /*id*/ 2) connectable_changes.id = `tx_${/*id*/ ctx[1]}`;

    			if (dirty & /*$$scope, formContext*/ 17) {
    				connectable_changes.$$scope = { dirty, ctx };
    			}

    			connectable.$set(connectable_changes);
    			const inputcontrol_changes = {};

    			if (!updating_value && dirty & /*formContext*/ 1) {
    				updating_value = true;
    				inputcontrol_changes.value = /*formContext*/ ctx[0].filter;
    				add_flush_callback(() => updating_value = false);
    			}

    			inputcontrol.$set(inputcontrol_changes);

    			if (!current || dirty & /*id*/ 2) {
    				attr_dev(form, "id", /*id*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(connectable.$$.fragment, local);
    			transition_in(inputcontrol.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(connectable.$$.fragment, local);
    			transition_out(inputcontrol.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(connectable);
    			destroy_component(inputcontrol);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TransformForm', slots, []);
    	let { formContext } = $$props;
    	let { id = formContext.id } = $$props;
    	const writable_props = ['formContext', 'id'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TransformForm> was created with unknown prop '${key}'`);
    	});

    	function inputcontrol_value_binding(value) {
    		if ($$self.$$.not_equal(formContext.transform, value)) {
    			formContext.transform = value;
    			$$invalidate(0, formContext);
    		}
    	}

    	function inputcontrol_value_binding_1(value) {
    		if ($$self.$$.not_equal(formContext.filter, value)) {
    			formContext.filter = value;
    			$$invalidate(0, formContext);
    		}
    	}

    	$$self.$$set = $$props => {
    		if ('formContext' in $$props) $$invalidate(0, formContext = $$props.formContext);
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    	};

    	$$self.$capture_state = () => ({
    		InputControl,
    		Connectable,
    		formContext,
    		id
    	});

    	$$self.$inject_state = $$props => {
    		if ('formContext' in $$props) $$invalidate(0, formContext = $$props.formContext);
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [formContext, id, inputcontrol_value_binding, inputcontrol_value_binding_1];
    }

    class TransformForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { formContext: 0, id: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TransformForm",
    			options,
    			id: create_fragment$d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*formContext*/ ctx[0] === undefined && !('formContext' in props)) {
    			console.warn("<TransformForm> was created without expected prop 'formContext'");
    		}
    	}

    	get formContext() {
    		throw new Error("<TransformForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set formContext(value) {
    		throw new Error("<TransformForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<TransformForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<TransformForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function Resource(apiRoot, resName) {
        return {
            create: function create(data) {
                return fetch(`${apiRoot}/${resName}`, {
                    method: "POST",
                    body: JSON.stringify(data),
                    headers: { "Content-type": "application/json" },
                });
            },
            read: function read(id) {
                return fetch(`${apiRoot}/${resName}/${id}`, {
                    method: "GET",
                });
            },
            readall: function read() {
                return fetch(`${apiRoot}/${resName}`, {
                    method: "GET",
                });
            },
            update: function update(id, data) {
                return fetch(`${apiRoot}/${resName}/${id}`, {
                    method: "PUT",
                    body: JSON.stringify(data),
                    headers: { "Content-type": "application/json" },
                });
            },
            delete: function del(id) {
                return fetch(`${apiRoot}/${resName}/${id}`, {
                    method: "DELETE",
                });
            },
            command: function custom(path) {
                return fetch(`${apiRoot}/${path}`, {
                    method: "GET",
                });
            },
        };
    }

    let currentFlow$1;
    let jsPlumbInstance;
    let isPanning = false;
    currentFlowStore.subscribe((flow) => {
        currentFlow$1 = flow;
    });
    jsPlumbInstanceStore.subscribe((value) => {
        jsPlumbInstance = value;
        console.debug("jsPlumbInstance refreshed!");
    });
    async function compileCurrentFlow() {
        console.debug("compiling flow...");
        const client = Resource("http://localhost:8321", "flow/compile");
        const response = await client.create(currentFlow$1).then((r) => r.json());
        console.debug(response);
    }
    async function loadFlow(flow) {
        jsPlumbInstance.deleteEveryConnection();
        refreshStore.set(flow.id);
        await tick();
        currentFlowStore.set(flow);
        await tick();
        jsPlumbInstance.repaintEverything();
        console.debug(currentFlow$1.edges);
        currentFlow$1.edges.forEach((edge) => {
            if (jsPlumbInstance.connections.filter((c) => {
                return c.sourceId === edge.source && c.targetId === edge.target;
            }).length < 1) {
                const sourceElement = document.getElementById(edge.source);
                const sourceEndpoint = jsPlumbInstance
                    .getEndpoints(sourceElement)
                    .find((ep) => {
                    return ep.isSource === true;
                });
                const targetElement = document.getElementById(edge.target);
                const targetEndpoint = jsPlumbInstance
                    .getEndpoints(targetElement)
                    .find((ep) => {
                    return ep.isTarget === true;
                });
                jsPlumbInstance.connect({
                    source: sourceEndpoint,
                    target: targetEndpoint,
                });
            }
        });
        jsPlumbInstance.repaintEverything();
    }
    function addNode(newNode) {
        let id = newNode.id || safeid();
        currentFlowStore.set(Object.assign(Object.assign({}, currentFlow$1), { nodes: [...currentFlow$1.nodes, Object.assign({ id }, newNode)] }));
    }
    function addTable() {
        const newTable = {
            name: `table_${safeid(6)}`,
            schema: "",
            database: "",
            materialised: false,
            columns: [],
        };
        addNode(Object.assign(Object.assign({}, newTable), { type: "table" }));
    }
    function addTransform() {
        const newTransform = {
            transform: "{col}",
            filter: "1=1",
        };
        addNode(Object.assign(Object.assign({}, newTransform), { type: "transform" }));
    }
    function setZoom(zoom, transformOrigin = [0.0, 0.0]) {
        let el = jsPlumbInstance.getContainer();
        let s = `scale(${zoom})`;
        let oString = transformOrigin[0] + "% " + transformOrigin[1] + "%";
        el.style["transform"] = s;
        el.style["transformOrigin"] = oString;
        el.style["height"] = 100 / zoom + "%";
        el.style["width"] = 100 / zoom + "%";
        jsPlumbInstance.setZoom(zoom, true);
    }
    function panElements(el, deltaX, deltaY) {
        Array.from(el.children).forEach((child) => {
            const style = getComputedStyle(child);
            const top = parseInt(style["top"]) | 0;
            const left = parseInt(style["left"]) | 0;
            child.style["left"] = `${left + deltaX}px`;
            child.style["top"] = `${top + deltaY}px`;
        });
    }
    function handlePanning(event) {
        let el = jsPlumbInstance.getContainer();
        let deltaX = (event.x - currentFlow$1.pan.x) * (1 / currentFlow$1.zoom);
        let deltaY = (event.y - currentFlow$1.pan.y) * (1 / currentFlow$1.zoom);
        if (isPanning === false) {
            [deltaX, deltaY] = [0, 0];
        }
        currentFlow$1.pan = { x: event.x, y: event.y };
        panElements(el, deltaX, deltaY);
        jsPlumbInstance.repaintEverything();
        isPanning = true;
    }
    function handleEndPan() {
        isPanning = false;
    }
    function handleScroll(event) {
        if (event.deltaY > 0) {
            currentFlow$1.zoom -= 0.025;
        }
        else if (event.deltaY < 0) {
            currentFlow$1.zoom += 0.025;
        }
        currentFlow$1.zoom = Math.min(Math.max(0.25, currentFlow$1.zoom), 2);
        setZoom(currentFlow$1.zoom);
    }

    // initialise the flow, this acts as a local cache of flows
    let flowStore = writable([]);
    // initialise the tableStore, this acts as a local cache of defined tables
    let tableStore = writable([]);

    /* src/flowCanvas/components/DragInit.svelte generated by Svelte v3.44.2 */

    const file$b = "src/flowCanvas/components/DragInit.svelte";

    function create_fragment$c(ctx) {
    	let div;
    	let t_value = /*table*/ ctx[0].name + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "draggable", true);
    			attr_dev(div, "class", "svelte-1ntvzka");
    			add_location(div, file$b, 7, 0, 187);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(div, "dragstart", /*dragstart_handler*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*table*/ 1 && t_value !== (t_value = /*table*/ ctx[0].name + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function dragStart(event, table) {
    	event.dataTransfer.effectAllowed = "copy";
    	event.dataTransfer.setData("text/plain", table.id);
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DragInit', slots, []);
    	let { table } = $$props;
    	const writable_props = ['table'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DragInit> was created with unknown prop '${key}'`);
    	});

    	const dragstart_handler = event => {
    		dragStart(event, table);
    	};

    	$$self.$$set = $$props => {
    		if ('table' in $$props) $$invalidate(0, table = $$props.table);
    	};

    	$$self.$capture_state = () => ({ table, dragStart });

    	$$self.$inject_state = $$props => {
    		if ('table' in $$props) $$invalidate(0, table = $$props.table);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [table, dragstart_handler];
    }

    class DragInit extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { table: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DragInit",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*table*/ ctx[0] === undefined && !('table' in props)) {
    			console.warn("<DragInit> was created without expected prop 'table'");
    		}
    	}

    	get table() {
    		throw new Error("<DragInit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set table(value) {
    		throw new Error("<DragInit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/flowCanvas/components/canvasMenu/ExistingTableMenu.svelte generated by Svelte v3.44.2 */
    const file$a = "src/flowCanvas/components/canvasMenu/ExistingTableMenu.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (9:0) {#if tables.length > 0}
    function create_if_block$2(ctx) {
    	let h4;
    	let t1;
    	let each_1_anchor;
    	let current;
    	let each_value = /*tables*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "Existing Tables";
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			attr_dev(h4, "class", "svelte-1vxfkts");
    			add_location(h4, file$a, 9, 2, 213);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			insert_dev(target, t1, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*tables*/ 1) {
    				each_value = /*tables*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(9:0) {#if tables.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (11:2) {#each tables as table}
    function create_each_block$2(ctx) {
    	let draginit;
    	let current;

    	draginit = new DragInit({
    			props: { table: /*table*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(draginit.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(draginit, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const draginit_changes = {};
    			if (dirty & /*tables*/ 1) draginit_changes.table = /*table*/ ctx[1];
    			draginit.$set(draginit_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(draginit.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(draginit.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(draginit, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(11:2) {#each tables as table}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*tables*/ ctx[0].length > 0 && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*tables*/ ctx[0].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*tables*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ExistingTableMenu', slots, []);
    	let tables;

    	tableStore.subscribe(value => {
    		$$invalidate(0, tables = value);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ExistingTableMenu> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ tableStore, DragInit, tables });

    	$$self.$inject_state = $$props => {
    		if ('tables' in $$props) $$invalidate(0, tables = $$props.tables);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [tables];
    }

    class ExistingTableMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ExistingTableMenu",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src/flowCanvas/components/canvasMenu/MenuIcon.svelte generated by Svelte v3.44.2 */

    const file$9 = "src/flowCanvas/components/canvasMenu/MenuIcon.svelte";

    // (17:2) {:else}
    function create_else_block(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let path2;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			attr_dev(path0, "d", "M 2 2.5 L 20 2.5");
    			add_location(path0, file$9, 18, 6, 349);
    			attr_dev(path1, "d", "M 2 9.423 L 20 9.423");
    			add_location(path1, file$9, 19, 6, 385);
    			attr_dev(path2, "d", "M 2 16.346 L 20 16.346");
    			add_location(path2, file$9, 20, 6, 425);
    			attr_dev(svg, "viewBox", "0 0 23 23");
    			attr_dev(svg, "class", "svelte-17pbcy5");
    			add_location(svg, file$9, 17, 4, 317);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(17:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (12:2) {#if menuOpen}
    function create_if_block$1(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "d", "M 3 16.5 L 17 2.5");
    			add_location(path0, file$9, 13, 6, 222);
    			attr_dev(path1, "d", "M 3 2.5 L 17 16.346");
    			add_location(path1, file$9, 14, 6, 259);
    			attr_dev(svg, "viewBox", "0 0 23 23");
    			attr_dev(svg, "class", "svelte-17pbcy5");
    			add_location(svg, file$9, 12, 4, 190);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(12:2) {#if menuOpen}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*menuOpen*/ ctx[0]) return create_if_block$1;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			add_location(div, file$9, 6, 0, 114);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MenuIcon', slots, []);
    	let { menuOpen = false } = $$props;

    	function toggleMenuOpen() {
    		$$invalidate(0, menuOpen = !menuOpen);
    	}

    	const writable_props = ['menuOpen'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MenuIcon> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => {
    		toggleMenuOpen();
    	};

    	$$self.$$set = $$props => {
    		if ('menuOpen' in $$props) $$invalidate(0, menuOpen = $$props.menuOpen);
    	};

    	$$self.$capture_state = () => ({ menuOpen, toggleMenuOpen });

    	$$self.$inject_state = $$props => {
    		if ('menuOpen' in $$props) $$invalidate(0, menuOpen = $$props.menuOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [menuOpen, toggleMenuOpen, click_handler];
    }

    class MenuIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { menuOpen: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MenuIcon",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get menuOpen() {
    		throw new Error("<MenuIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set menuOpen(value) {
    		throw new Error("<MenuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const tableSyncService = (tableApi) => ({
        updateServerTables: async function updateServerTables(clientTables) {
            const apiTables = await tableApi
                .readall()
                .then((data) => data.json());
            lodash.differenceWith(clientTables, apiTables, lodash.isEqual).forEach((ct) => {
                if (apiTables.find((t) => {
                    return t.id === ct.id;
                }) === undefined) {
                    tableApi.create(ct);
                }
                else {
                    tableApi.update(ct.name, ct);
                }
            });
        },
        updateClientTables: async function updateClientTables() {
            const apiTables = await tableApi
                .readall()
                .then((data) => data.json());
            tableStore.update((clientTables) => {
                return [
                    ...clientTables,
                    ...lodash.differenceWith(apiTables, clientTables, lodash.isEqual),
                ];
            });
        },
    });

    /* src/flowCanvas/components/canvasMenu/MetadataMenu.svelte generated by Svelte v3.44.2 */
    const file$8 = "src/flowCanvas/components/canvasMenu/MetadataMenu.svelte";

    // (10:0) <ButtonControl handleClick={serviceTs.updateClientTables}>
    function create_default_slot$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Update Metadata...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(10:0) <ButtonControl handleClick={serviceTs.updateClientTables}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let h4;
    	let t1;
    	let buttoncontrol;
    	let current;

    	buttoncontrol = new ButtonControl({
    			props: {
    				handleClick: /*serviceTs*/ ctx[0].updateClientTables,
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "Metadata";
    			t1 = space();
    			create_component(buttoncontrol.$$.fragment);
    			attr_dev(h4, "class", "svelte-1vxfkts");
    			add_location(h4, file$8, 8, 0, 343);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(buttoncontrol, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const buttoncontrol_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				buttoncontrol_changes.$$scope = { dirty, ctx };
    			}

    			buttoncontrol.$set(buttoncontrol_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttoncontrol.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(buttoncontrol.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			destroy_component(buttoncontrol, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MetadataMenu', slots, []);
    	let { apiUrl = "http://localhost:8321" } = $$props;
    	const tableApi = Resource(apiUrl, "table");
    	const serviceTs = tableSyncService(tableApi);
    	const writable_props = ['apiUrl'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MetadataMenu> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('apiUrl' in $$props) $$invalidate(1, apiUrl = $$props.apiUrl);
    	};

    	$$self.$capture_state = () => ({
    		Resource,
    		tableSyncService,
    		ButtonControl,
    		apiUrl,
    		tableApi,
    		serviceTs
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiUrl' in $$props) $$invalidate(1, apiUrl = $$props.apiUrl);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [serviceTs, apiUrl];
    }

    class MetadataMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { apiUrl: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MetadataMenu",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get apiUrl() {
    		throw new Error("<MetadataMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set apiUrl(value) {
    		throw new Error("<MetadataMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/flowCanvas/components/canvasMenu/NewElementsMenu.svelte generated by Svelte v3.44.2 */
    const file$7 = "src/flowCanvas/components/canvasMenu/NewElementsMenu.svelte";

    // (6:0) <ButtonControl handleClick={addTable}>
    function create_default_slot_1$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("add Table");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(6:0) <ButtonControl handleClick={addTable}>",
    		ctx
    	});

    	return block;
    }

    // (7:0) <ButtonControl handleClick={addTransform}>
    function create_default_slot$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("add Transform");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(7:0) <ButtonControl handleClick={addTransform}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let h4;
    	let t1;
    	let buttoncontrol0;
    	let t2;
    	let buttoncontrol1;
    	let current;

    	buttoncontrol0 = new ButtonControl({
    			props: {
    				handleClick: addTable,
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	buttoncontrol1 = new ButtonControl({
    			props: {
    				handleClick: addTransform,
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "New Tables";
    			t1 = space();
    			create_component(buttoncontrol0.$$.fragment);
    			t2 = space();
    			create_component(buttoncontrol1.$$.fragment);
    			attr_dev(h4, "class", "svelte-1vxfkts");
    			add_location(h4, file$7, 4, 0, 160);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(buttoncontrol0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(buttoncontrol1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const buttoncontrol0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				buttoncontrol0_changes.$$scope = { dirty, ctx };
    			}

    			buttoncontrol0.$set(buttoncontrol0_changes);
    			const buttoncontrol1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				buttoncontrol1_changes.$$scope = { dirty, ctx };
    			}

    			buttoncontrol1.$set(buttoncontrol1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttoncontrol0.$$.fragment, local);
    			transition_in(buttoncontrol1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(buttoncontrol0.$$.fragment, local);
    			transition_out(buttoncontrol1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			destroy_component(buttoncontrol0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(buttoncontrol1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NewElementsMenu', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NewElementsMenu> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ ButtonControl, addTable, addTransform });
    	return [];
    }

    class NewElementsMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NewElementsMenu",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    let currentFlow;
    currentFlowStore.subscribe((flow) => {
        currentFlow = flow;
    });
    const flowSyncService = (flowApi) => ({
        saveFlow: async function saveFlow() {
            console.debug(currentFlow);
            console.debug(JSON.stringify(currentFlow));
            const existingFlow = flowApi.read(currentFlow.id);
            if (existingFlow !== undefined) {
                flowApi.update(currentFlow.id, currentFlow);
            }
            else {
                flowApi.create(currentFlow);
            }
        },
        updateClientFlows: async function updateClientFlows() {
            const apiFlows = await flowApi
                .readall()
                .then((data) => data.json());
            flowStore.update((clientFlows) => {
                return [
                    ...clientFlows,
                    ...lodash.differenceWith(apiFlows, clientFlows, lodash.isEqual),
                ];
            });
        },
    });

    /* src/flowCanvas/components/canvasMenu/SaveLoadMenu.svelte generated by Svelte v3.44.2 */
    const file$6 = "src/flowCanvas/components/canvasMenu/SaveLoadMenu.svelte";

    // (11:0) <ButtonControl   handleClick={() => {     flowService.saveFlow();   }}>
    function create_default_slot$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Save");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(11:0) <ButtonControl   handleClick={() => {     flowService.saveFlow();   }}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let h4;
    	let t1;
    	let buttoncontrol;
    	let current;

    	buttoncontrol = new ButtonControl({
    			props: {
    				handleClick: /*func*/ ctx[2],
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "Save Flow";
    			t1 = space();
    			create_component(buttoncontrol.$$.fragment);
    			attr_dev(h4, "class", "svelte-1vxfkts");
    			add_location(h4, file$6, 9, 0, 348);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(buttoncontrol, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const buttoncontrol_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				buttoncontrol_changes.$$scope = { dirty, ctx };
    			}

    			buttoncontrol.$set(buttoncontrol_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttoncontrol.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(buttoncontrol.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			destroy_component(buttoncontrol, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SaveLoadMenu', slots, []);
    	let { apiUrl = "http://localhost:8321" } = $$props;
    	const api = Resource(apiUrl, "flow");
    	const flowService = flowSyncService(api);
    	let currentFlow;
    	const writable_props = ['apiUrl'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SaveLoadMenu> was created with unknown prop '${key}'`);
    	});

    	const func = () => {
    		flowService.saveFlow();
    	};

    	$$self.$$set = $$props => {
    		if ('apiUrl' in $$props) $$invalidate(1, apiUrl = $$props.apiUrl);
    	};

    	$$self.$capture_state = () => ({
    		Resource,
    		flowSyncService,
    		ButtonControl,
    		apiUrl,
    		api,
    		flowService,
    		currentFlow
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiUrl' in $$props) $$invalidate(1, apiUrl = $$props.apiUrl);
    		if ('currentFlow' in $$props) currentFlow = $$props.currentFlow;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [flowService, apiUrl, func];
    }

    class SaveLoadMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { apiUrl: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SaveLoadMenu",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get apiUrl() {
    		throw new Error("<SaveLoadMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set apiUrl(value) {
    		throw new Error("<SaveLoadMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/flowCanvas/components/canvasMenu/CompileMenu.svelte generated by Svelte v3.44.2 */
    const file$5 = "src/flowCanvas/components/canvasMenu/CompileMenu.svelte";

    // (6:0) <ButtonControl handleClick={(e) => compileCurrentFlow()}>
    function create_default_slot$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Compile Flow");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(6:0) <ButtonControl handleClick={(e) => compileCurrentFlow()}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let h4;
    	let t1;
    	let buttoncontrol;
    	let current;

    	buttoncontrol = new ButtonControl({
    			props: {
    				handleClick: /*func*/ ctx[0],
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "Current Flow Options";
    			t1 = space();
    			create_component(buttoncontrol.$$.fragment);
    			attr_dev(h4, "class", "svelte-1vxfkts");
    			add_location(h4, file$5, 4, 0, 156);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(buttoncontrol, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const buttoncontrol_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				buttoncontrol_changes.$$scope = { dirty, ctx };
    			}

    			buttoncontrol.$set(buttoncontrol_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttoncontrol.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(buttoncontrol.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			destroy_component(buttoncontrol, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CompileMenu', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CompileMenu> was created with unknown prop '${key}'`);
    	});

    	const func = e => compileCurrentFlow();
    	$$self.$capture_state = () => ({ ButtonControl, compileCurrentFlow });
    	return [func];
    }

    class CompileMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CompileMenu",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src/flowCanvas/components/canvasMenu/CanvasMenu.svelte generated by Svelte v3.44.2 */
    const file$4 = "src/flowCanvas/components/canvasMenu/CanvasMenu.svelte";

    function create_fragment$5(ctx) {
    	let div0;
    	let menuicon;
    	let updating_menuOpen;
    	let t0;
    	let div2;
    	let div1;
    	let inputcontrol;
    	let updating_value;
    	let t1;
    	let newelementsmenu;
    	let t2;
    	let existingtablemenu;
    	let t3;
    	let saveloadmenu;
    	let t4;
    	let metadatamenu;
    	let t5;
    	let compilemenu;
    	let div2_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	function menuicon_menuOpen_binding(value) {
    		/*menuicon_menuOpen_binding*/ ctx[3](value);
    	}

    	let menuicon_props = {};

    	if (/*menuOpen*/ ctx[1] !== void 0) {
    		menuicon_props.menuOpen = /*menuOpen*/ ctx[1];
    	}

    	menuicon = new MenuIcon({ props: menuicon_props, $$inline: true });
    	binding_callbacks.push(() => bind(menuicon, 'menuOpen', menuicon_menuOpen_binding));

    	function inputcontrol_value_binding(value) {
    		/*inputcontrol_value_binding*/ ctx[4](value);
    	}

    	let inputcontrol_props = { type: "text", label: "Flow Name" };

    	if (/*flowName*/ ctx[0] !== void 0) {
    		inputcontrol_props.value = /*flowName*/ ctx[0];
    	}

    	inputcontrol = new InputControl({
    			props: inputcontrol_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(inputcontrol, 'value', inputcontrol_value_binding));
    	newelementsmenu = new NewElementsMenu({ $$inline: true });
    	existingtablemenu = new ExistingTableMenu({ $$inline: true });
    	saveloadmenu = new SaveLoadMenu({ $$inline: true });
    	metadatamenu = new MetadataMenu({ $$inline: true });
    	compilemenu = new CompileMenu({ $$inline: true });

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(menuicon.$$.fragment);
    			t0 = space();
    			div2 = element("div");
    			div1 = element("div");
    			create_component(inputcontrol.$$.fragment);
    			t1 = space();
    			create_component(newelementsmenu.$$.fragment);
    			t2 = space();
    			create_component(existingtablemenu.$$.fragment);
    			t3 = space();
    			create_component(saveloadmenu.$$.fragment);
    			t4 = space();
    			create_component(metadatamenu.$$.fragment);
    			t5 = space();
    			create_component(compilemenu.$$.fragment);
    			attr_dev(div0, "class", "menuToggleControl svelte-95qodh");
    			add_location(div0, file$4, 16, 0, 580);
    			attr_dev(div1, "class", "menuContent svelte-95qodh");
    			add_location(div1, file$4, 23, 2, 752);
    			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty(`menuBackdrop ${/*menuOpen*/ ctx[1] ? "visible" : "hidden"}`) + " svelte-95qodh"));
    			add_location(div2, file$4, 19, 0, 648);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(menuicon, div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			mount_component(inputcontrol, div1, null);
    			append_dev(div1, t1);
    			mount_component(newelementsmenu, div1, null);
    			append_dev(div1, t2);
    			mount_component(existingtablemenu, div1, null);
    			append_dev(div1, t3);
    			mount_component(saveloadmenu, div1, null);
    			append_dev(div1, t4);
    			mount_component(metadatamenu, div1, null);
    			append_dev(div1, t5);
    			mount_component(compilemenu, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div2, "mouseleave", /*handleMouseLeave*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const menuicon_changes = {};

    			if (!updating_menuOpen && dirty & /*menuOpen*/ 2) {
    				updating_menuOpen = true;
    				menuicon_changes.menuOpen = /*menuOpen*/ ctx[1];
    				add_flush_callback(() => updating_menuOpen = false);
    			}

    			menuicon.$set(menuicon_changes);
    			const inputcontrol_changes = {};

    			if (!updating_value && dirty & /*flowName*/ 1) {
    				updating_value = true;
    				inputcontrol_changes.value = /*flowName*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			inputcontrol.$set(inputcontrol_changes);

    			if (!current || dirty & /*menuOpen*/ 2 && div2_class_value !== (div2_class_value = "" + (null_to_empty(`menuBackdrop ${/*menuOpen*/ ctx[1] ? "visible" : "hidden"}`) + " svelte-95qodh"))) {
    				attr_dev(div2, "class", div2_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menuicon.$$.fragment, local);
    			transition_in(inputcontrol.$$.fragment, local);
    			transition_in(newelementsmenu.$$.fragment, local);
    			transition_in(existingtablemenu.$$.fragment, local);
    			transition_in(saveloadmenu.$$.fragment, local);
    			transition_in(metadatamenu.$$.fragment, local);
    			transition_in(compilemenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menuicon.$$.fragment, local);
    			transition_out(inputcontrol.$$.fragment, local);
    			transition_out(newelementsmenu.$$.fragment, local);
    			transition_out(existingtablemenu.$$.fragment, local);
    			transition_out(saveloadmenu.$$.fragment, local);
    			transition_out(metadatamenu.$$.fragment, local);
    			transition_out(compilemenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(menuicon);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			destroy_component(inputcontrol);
    			destroy_component(newelementsmenu);
    			destroy_component(existingtablemenu);
    			destroy_component(saveloadmenu);
    			destroy_component(metadatamenu);
    			destroy_component(compilemenu);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CanvasMenu', slots, []);
    	let { flowName = "" } = $$props;
    	let menuOpen = false;

    	function handleMouseLeave() {
    		$$invalidate(1, menuOpen = false);
    	}

    	const writable_props = ['flowName'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CanvasMenu> was created with unknown prop '${key}'`);
    	});

    	function menuicon_menuOpen_binding(value) {
    		menuOpen = value;
    		$$invalidate(1, menuOpen);
    	}

    	function inputcontrol_value_binding(value) {
    		flowName = value;
    		$$invalidate(0, flowName);
    	}

    	$$self.$$set = $$props => {
    		if ('flowName' in $$props) $$invalidate(0, flowName = $$props.flowName);
    	};

    	$$self.$capture_state = () => ({
    		InputControl,
    		ExistingTableMenu,
    		MenuIcon,
    		MetadataMenu,
    		NewElementsMenu,
    		SaveLoadMenu,
    		CompileMenu,
    		flowName,
    		menuOpen,
    		handleMouseLeave
    	});

    	$$self.$inject_state = $$props => {
    		if ('flowName' in $$props) $$invalidate(0, flowName = $$props.flowName);
    		if ('menuOpen' in $$props) $$invalidate(1, menuOpen = $$props.menuOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		flowName,
    		menuOpen,
    		handleMouseLeave,
    		menuicon_menuOpen_binding,
    		inputcontrol_value_binding
    	];
    }

    class CanvasMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { flowName: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CanvasMenu",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get flowName() {
    		throw new Error("<CanvasMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flowName(value) {
    		throw new Error("<CanvasMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/flowCanvas/Canvas.svelte generated by Svelte v3.44.2 */

    const { Object: Object_1, console: console_1 } = globals;

    const file$3 = "src/flowCanvas/Canvas.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	child_ctx[20] = list;
    	child_ctx[21] = i;
    	return child_ctx;
    }

    // (97:77) 
    function create_if_block_1(ctx) {
    	let switch_instance;
    	let updating_formContext;
    	let updating_top;
    	let updating_left;
    	let switch_instance_anchor;
    	let current;

    	function switch_instance_formContext_binding_1(value) {
    		/*switch_instance_formContext_binding_1*/ ctx[9](value, /*idx*/ ctx[21]);
    	}

    	function switch_instance_top_binding_1(value) {
    		/*switch_instance_top_binding_1*/ ctx[10](value, /*node*/ ctx[19]);
    	}

    	function switch_instance_left_binding_1(value) {
    		/*switch_instance_left_binding_1*/ ctx[11](value, /*node*/ ctx[19]);
    	}

    	var switch_value = Node;

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			form: TransformForm,
    			title: "Transform",
    			id: /*node*/ ctx[19].id
    		};

    		if (/*currentFlow*/ ctx[0].nodes[/*idx*/ ctx[21]] !== void 0) {
    			switch_instance_props.formContext = /*currentFlow*/ ctx[0].nodes[/*idx*/ ctx[21]];
    		}

    		if (/*node*/ ctx[19].top !== void 0) {
    			switch_instance_props.top = /*node*/ ctx[19].top;
    		}

    		if (/*node*/ ctx[19].left !== void 0) {
    			switch_instance_props.left = /*node*/ ctx[19].left;
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind(switch_instance, 'formContext', switch_instance_formContext_binding_1));
    		binding_callbacks.push(() => bind(switch_instance, 'top', switch_instance_top_binding_1));
    		binding_callbacks.push(() => bind(switch_instance, 'left', switch_instance_left_binding_1));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const switch_instance_changes = {};
    			if (dirty & /*currentFlow*/ 1) switch_instance_changes.id = /*node*/ ctx[19].id;

    			if (!updating_formContext && dirty & /*currentFlow*/ 1) {
    				updating_formContext = true;
    				switch_instance_changes.formContext = /*currentFlow*/ ctx[0].nodes[/*idx*/ ctx[21]];
    				add_flush_callback(() => updating_formContext = false);
    			}

    			if (!updating_top && dirty & /*currentFlow*/ 1) {
    				updating_top = true;
    				switch_instance_changes.top = /*node*/ ctx[19].top;
    				add_flush_callback(() => updating_top = false);
    			}

    			if (!updating_left && dirty & /*currentFlow*/ 1) {
    				updating_left = true;
    				switch_instance_changes.left = /*node*/ ctx[19].left;
    				add_flush_callback(() => updating_left = false);
    			}

    			if (switch_value !== (switch_value = Node)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind(switch_instance, 'formContext', switch_instance_formContext_binding_1));
    					binding_callbacks.push(() => bind(switch_instance, 'top', switch_instance_top_binding_1));
    					binding_callbacks.push(() => bind(switch_instance, 'left', switch_instance_left_binding_1));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(97:77) ",
    		ctx
    	});

    	return block;
    }

    // (78:6) {#if isITableDefinition(node) && node.name !== undefined}
    function create_if_block(ctx) {
    	let switch_instance;
    	let updating_formContext;
    	let updating_top;
    	let updating_left;
    	let switch_instance_anchor;
    	let current;

    	function switch_instance_formContext_binding(value) {
    		/*switch_instance_formContext_binding*/ ctx[6](value, /*idx*/ ctx[21]);
    	}

    	function switch_instance_top_binding(value) {
    		/*switch_instance_top_binding*/ ctx[7](value, /*node*/ ctx[19]);
    	}

    	function switch_instance_left_binding(value) {
    		/*switch_instance_left_binding*/ ctx[8](value, /*node*/ ctx[19]);
    	}

    	var switch_value = Node;

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			form: TableForm,
    			id: /*node*/ ctx[19].id || safeid(),
    			title: "Table",
    			$$slots: { footer: [create_footer_slot] },
    			$$scope: { ctx }
    		};

    		if (/*currentFlow*/ ctx[0].nodes[/*idx*/ ctx[21]] !== void 0) {
    			switch_instance_props.formContext = /*currentFlow*/ ctx[0].nodes[/*idx*/ ctx[21]];
    		}

    		if (/*node*/ ctx[19].top !== void 0) {
    			switch_instance_props.top = /*node*/ ctx[19].top;
    		}

    		if (/*node*/ ctx[19].left !== void 0) {
    			switch_instance_props.left = /*node*/ ctx[19].left;
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind(switch_instance, 'formContext', switch_instance_formContext_binding));
    		binding_callbacks.push(() => bind(switch_instance, 'top', switch_instance_top_binding));
    		binding_callbacks.push(() => bind(switch_instance, 'left', switch_instance_left_binding));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const switch_instance_changes = {};
    			if (dirty & /*currentFlow*/ 1) switch_instance_changes.id = /*node*/ ctx[19].id || safeid();

    			if (dirty & /*$$scope, currentFlow*/ 4194305) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_formContext && dirty & /*currentFlow*/ 1) {
    				updating_formContext = true;
    				switch_instance_changes.formContext = /*currentFlow*/ ctx[0].nodes[/*idx*/ ctx[21]];
    				add_flush_callback(() => updating_formContext = false);
    			}

    			if (!updating_top && dirty & /*currentFlow*/ 1) {
    				updating_top = true;
    				switch_instance_changes.top = /*node*/ ctx[19].top;
    				add_flush_callback(() => updating_top = false);
    			}

    			if (!updating_left && dirty & /*currentFlow*/ 1) {
    				updating_left = true;
    				switch_instance_changes.left = /*node*/ ctx[19].left;
    				add_flush_callback(() => updating_left = false);
    			}

    			if (switch_value !== (switch_value = Node)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind(switch_instance, 'formContext', switch_instance_formContext_binding));
    					binding_callbacks.push(() => bind(switch_instance, 'top', switch_instance_top_binding));
    					binding_callbacks.push(() => bind(switch_instance, 'left', switch_instance_left_binding));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(78:6) {#if isITableDefinition(node) && node.name !== undefined}",
    		ctx
    	});

    	return block;
    }

    // (88:10) <svelte:fragment slot="footer">
    function create_footer_slot(ctx) {
    	let span0;

    	let t0_value = (/*node*/ ctx[19].materialised
    	? "Materialised"
    	: "Unmaterialised") + "";

    	let t0;
    	let t1;
    	let span1;

    	let t2_value = (/*node*/ ctx[19].schema !== ""
    	? `[${/*node*/ ctx[19].schema}].[${/*node*/ ctx[19].name}]`
    	: `[${/*node*/ ctx[19].name}]`) + "";

    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			add_location(span0, file$3, 88, 12, 3044);
    			add_location(span1, file$3, 89, 12, 3125);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span0, anchor);
    			append_dev(span0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, span1, anchor);
    			append_dev(span1, t2);
    			insert_dev(target, t3, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentFlow*/ 1 && t0_value !== (t0_value = (/*node*/ ctx[19].materialised
    			? "Materialised"
    			: "Unmaterialised") + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*currentFlow*/ 1 && t2_value !== (t2_value = (/*node*/ ctx[19].schema !== ""
    			? `[${/*node*/ ctx[19].schema}].[${/*node*/ ctx[19].name}]`
    			: `[${/*node*/ ctx[19].name}]`) + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(span1);
    			if (detaching) detach_dev(t3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footer_slot.name,
    		type: "slot",
    		source: "(88:10) <svelte:fragment slot=\\\"footer\\\">",
    		ctx
    	});

    	return block;
    }

    // (77:4) {#each currentFlow.nodes as node, idx}
    function create_each_block$1(ctx) {
    	let show_if;
    	let show_if_1;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_if_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (show_if == null || dirty & /*currentFlow*/ 1) show_if = !!(isITableDefinition(/*node*/ ctx[19]) && /*node*/ ctx[19].name !== undefined);
    		if (show_if) return 0;
    		if (show_if_1 == null || dirty & /*currentFlow*/ 1) show_if_1 = !!(isITransformDefinition(/*node*/ ctx[19]) && /*node*/ ctx[19].transform !== undefined);
    		if (show_if_1) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx, -1))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(77:4) {#each currentFlow.nodes as node, idx}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let div1;
    	let canvasmenu;
    	let updating_flowName;
    	let t;
    	let div0;
    	let current;
    	let mounted;
    	let dispose;

    	function canvasmenu_flowName_binding(value) {
    		/*canvasmenu_flowName_binding*/ ctx[5](value);
    	}

    	let canvasmenu_props = {};

    	if (/*currentFlow*/ ctx[0].name !== void 0) {
    		canvasmenu_props.flowName = /*currentFlow*/ ctx[0].name;
    	}

    	canvasmenu = new CanvasMenu({ props: canvasmenu_props, $$inline: true });
    	binding_callbacks.push(() => bind(canvasmenu, 'flowName', canvasmenu_flowName_binding));
    	let each_value = /*currentFlow*/ ctx[0].nodes;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(canvasmenu.$$.fragment);
    			t = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "canvas svelte-1ksocx7");
    			add_location(div0, file$3, 63, 2, 2273);
    			attr_dev(div1, "class", "wrapper svelte-1ksocx7");
    			add_location(div1, file$3, 60, 0, 2140);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(canvasmenu, div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			/*div0_binding*/ ctx[12](div0);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "wheel", prevent_default(/*wheel_handler*/ ctx[13]), false, true, false),
    					listen_dev(div0, "mousedown", /*handleMouseDown*/ ctx[2], false, false, false),
    					listen_dev(div0, "mouseup", /*handleMouseUp*/ ctx[3], false, false, false),
    					listen_dev(div0, "mouseout", /*handleMouseUp*/ ctx[3], false, false, false),
    					listen_dev(div0, "drop", prevent_default(/*handleDragEnd*/ ctx[4]), false, true, false),
    					listen_dev(div0, "dragenter", prevent_default(dragenter_handler), false, true, false),
    					listen_dev(div0, "dragover", prevent_default(dragover_handler), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const canvasmenu_changes = {};

    			if (!updating_flowName && dirty & /*currentFlow*/ 1) {
    				updating_flowName = true;
    				canvasmenu_changes.flowName = /*currentFlow*/ ctx[0].name;
    				add_flush_callback(() => updating_flowName = false);
    			}

    			canvasmenu.$set(canvasmenu_changes);

    			if (dirty & /*Node, TableForm, currentFlow, safeid, isITableDefinition, undefined, TransformForm, isITransformDefinition*/ 1) {
    				each_value = /*currentFlow*/ ctx[0].nodes;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(canvasmenu.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(canvasmenu.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(canvasmenu);
    			destroy_each(each_blocks, detaching);
    			/*div0_binding*/ ctx[12](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const dragenter_handler = () => {
    	
    };

    const dragover_handler = () => {
    	
    };

    function instance$4($$self, $$props, $$invalidate) {
    	let $jsPlumbInstanceStore;
    	validate_store(jsPlumbInstanceStore, 'jsPlumbInstanceStore');
    	component_subscribe($$self, jsPlumbInstanceStore, $$value => $$invalidate(16, $jsPlumbInstanceStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Canvas', slots, []);
    	let canvasElement;
    	let tables;
    	let jsPlumbInstance;
    	let { currentFlow } = $$props;

    	tableStore.subscribe(value => {
    		tables = value;
    	});

    	jsPlumbInstanceStore.subscribe(value => {
    		jsPlumbInstance = value;
    	});

    	const thisHandlePanning = e => handlePanning(e);

    	onMount(() => {
    		canvasStore.set(canvasElement);
    		createJsPlumbInstance();
    		$jsPlumbInstanceStore.bind(EVENT_CONNECTION, handleConnection);
    	});

    	onDestroy(() => {
    		jsPlumbInstance.removeAllEndpoints(canvasElement);
    		jsPlumbInstance.deleteEveryConnection();
    	});

    	function handleConnection(params) {
    		$$invalidate(
    			0,
    			currentFlow.edges = [
    				...currentFlow.edges,
    				{
    					source: params.sourceId,
    					target: params.targetId
    				}
    			],
    			currentFlow
    		);
    	}

    	function handleMouseDown(event) {
    		if (event.target === canvasElement && event.button === 0) {
    			event.target.addEventListener("mousemove", thisHandlePanning);
    		}
    	}

    	function handleMouseUp(event) {
    		if (event.target === canvasElement && event.button === 0) {
    			event.target.removeEventListener("mousemove", thisHandlePanning);
    			handleEndPan();
    		}
    	}

    	async function handleDragEnd(event) {
    		console.debug(event);
    		const tableId = event.dataTransfer.getData("text/plain");
    		const table = tables.find(t => t.id === tableId);

    		if (table !== undefined) {
    			addNode(Object.assign(Object.assign({}, table), { left: event.x, top: event.y }));
    			await tick();
    			jsPlumbInstance.repaintEverything();
    		}
    	}

    	const writable_props = ['currentFlow'];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Canvas> was created with unknown prop '${key}'`);
    	});

    	function canvasmenu_flowName_binding(value) {
    		if ($$self.$$.not_equal(currentFlow.name, value)) {
    			currentFlow.name = value;
    			$$invalidate(0, currentFlow);
    		}
    	}

    	function switch_instance_formContext_binding(value, idx) {
    		if ($$self.$$.not_equal(currentFlow.nodes[idx], value)) {
    			currentFlow.nodes[idx] = value;
    			$$invalidate(0, currentFlow);
    		}
    	}

    	function switch_instance_top_binding(value, node) {
    		if ($$self.$$.not_equal(node.top, value)) {
    			node.top = value;
    			$$invalidate(0, currentFlow);
    		}
    	}

    	function switch_instance_left_binding(value, node) {
    		if ($$self.$$.not_equal(node.left, value)) {
    			node.left = value;
    			$$invalidate(0, currentFlow);
    		}
    	}

    	function switch_instance_formContext_binding_1(value, idx) {
    		if ($$self.$$.not_equal(currentFlow.nodes[idx], value)) {
    			currentFlow.nodes[idx] = value;
    			$$invalidate(0, currentFlow);
    		}
    	}

    	function switch_instance_top_binding_1(value, node) {
    		if ($$self.$$.not_equal(node.top, value)) {
    			node.top = value;
    			$$invalidate(0, currentFlow);
    		}
    	}

    	function switch_instance_left_binding_1(value, node) {
    		if ($$self.$$.not_equal(node.left, value)) {
    			node.left = value;
    			$$invalidate(0, currentFlow);
    		}
    	}

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			canvasElement = $$value;
    			$$invalidate(1, canvasElement);
    		});
    	}

    	const wheel_handler = e => {
    		handleScroll(e);
    	};

    	$$self.$$set = $$props => {
    		if ('currentFlow' in $$props) $$invalidate(0, currentFlow = $$props.currentFlow);
    	};

    	$$self.$capture_state = () => ({
    		onDestroy,
    		onMount,
    		tick,
    		isITableDefinition,
    		isITransformDefinition,
    		EVENT_CONNECTION,
    		safeid,
    		Node,
    		TableForm,
    		TransformForm,
    		handlePanning,
    		handleScroll,
    		addNode,
    		handleEndPan,
    		CanvasMenu,
    		tableStore,
    		canvasStore,
    		createJsPlumbInstance,
    		jsPlumbInstanceStore,
    		canvasElement,
    		tables,
    		jsPlumbInstance,
    		currentFlow,
    		thisHandlePanning,
    		handleConnection,
    		handleMouseDown,
    		handleMouseUp,
    		handleDragEnd,
    		$jsPlumbInstanceStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('canvasElement' in $$props) $$invalidate(1, canvasElement = $$props.canvasElement);
    		if ('tables' in $$props) tables = $$props.tables;
    		if ('jsPlumbInstance' in $$props) jsPlumbInstance = $$props.jsPlumbInstance;
    		if ('currentFlow' in $$props) $$invalidate(0, currentFlow = $$props.currentFlow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		currentFlow,
    		canvasElement,
    		handleMouseDown,
    		handleMouseUp,
    		handleDragEnd,
    		canvasmenu_flowName_binding,
    		switch_instance_formContext_binding,
    		switch_instance_top_binding,
    		switch_instance_left_binding,
    		switch_instance_formContext_binding_1,
    		switch_instance_top_binding_1,
    		switch_instance_left_binding_1,
    		div0_binding,
    		wheel_handler
    	];
    }

    class Canvas extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { currentFlow: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Canvas",
    			options,
    			id: create_fragment$4.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*currentFlow*/ ctx[0] === undefined && !('currentFlow' in props)) {
    			console_1.warn("<Canvas> was created without expected prop 'currentFlow'");
    		}
    	}

    	get currentFlow() {
    		throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentFlow(value) {
    		throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Theme.svelte generated by Svelte v3.44.2 */

    function create_fragment$3(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Theme', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Theme> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Theme extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Theme",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src/FlowIcon.svelte generated by Svelte v3.44.2 */

    const file$2 = "src/FlowIcon.svelte";

    function create_fragment$2(ctx) {
    	let svg;
    	let defs;
    	let g;
    	let circle0;
    	let circle1;
    	let circle2;
    	let circle3;
    	let rect0;
    	let rect1;
    	let rect2;
    	let rect3;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			defs = svg_element("defs");
    			g = svg_element("g");
    			circle0 = svg_element("circle");
    			circle1 = svg_element("circle");
    			circle2 = svg_element("circle");
    			circle3 = svg_element("circle");
    			rect0 = svg_element("rect");
    			rect1 = svg_element("rect");
    			rect2 = svg_element("rect");
    			rect3 = svg_element("rect");
    			attr_dev(defs, "id", "defs2");
    			add_location(defs, file$2, 9, 2, 178);
    			set_style(circle0, "stroke", "none");
    			set_style(circle0, "stroke-width", "1");
    			set_style(circle0, "stroke-linecap", "round");
    			set_style(circle0, "stroke-linejoin", "round");
    			attr_dev(circle0, "id", "path868");
    			attr_dev(circle0, "cx", "8.4666662");
    			attr_dev(circle0, "cy", "-13.229167");
    			attr_dev(circle0, "r", "2.1166666");
    			attr_dev(circle0, "transform", "rotate(90)");
    			attr_dev(circle0, "class", "svelte-1a62sme");
    			add_location(circle0, file$2, 11, 4, 220);
    			set_style(circle1, "stroke", "none");
    			set_style(circle1, "stroke-width", "1");
    			set_style(circle1, "stroke-linecap", "round");
    			set_style(circle1, "stroke-linejoin", "round");
    			attr_dev(circle1, "id", "path868-2");
    			attr_dev(circle1, "cx", "3.175");
    			attr_dev(circle1, "cy", "-3.7041669");
    			attr_dev(circle1, "r", "2.1166666");
    			attr_dev(circle1, "transform", "rotate(90)");
    			attr_dev(circle1, "class", "svelte-1a62sme");
    			add_location(circle1, file$2, 19, 4, 434);
    			set_style(circle2, "stroke", "none");
    			set_style(circle2, "stroke-width", "1");
    			set_style(circle2, "stroke-linecap", "round");
    			set_style(circle2, "stroke-linejoin", "round");
    			attr_dev(circle2, "id", "path868-9");
    			attr_dev(circle2, "cx", "8.4666662");
    			attr_dev(circle2, "cy", "-3.7041669");
    			attr_dev(circle2, "r", "2.1166666");
    			attr_dev(circle2, "transform", "rotate(90)");
    			attr_dev(circle2, "class", "svelte-1a62sme");
    			add_location(circle2, file$2, 27, 4, 646);
    			set_style(circle3, "stroke", "none");
    			set_style(circle3, "stroke-width", "1");
    			set_style(circle3, "stroke-linecap", "round");
    			set_style(circle3, "stroke-linejoin", "round");
    			attr_dev(circle3, "id", "path868-1");
    			attr_dev(circle3, "cx", "13.758333");
    			attr_dev(circle3, "cy", "-3.7041669");
    			attr_dev(circle3, "r", "2.1166666");
    			attr_dev(circle3, "transform", "rotate(90)");
    			attr_dev(circle3, "class", "svelte-1a62sme");
    			add_location(circle3, file$2, 35, 4, 862);
    			set_style(rect0, "stroke", "none");
    			set_style(rect0, "stroke-width", "1.04601");
    			set_style(rect0, "stroke-linecap", "round");
    			set_style(rect0, "stroke-linejoin", "round");
    			attr_dev(rect0, "id", "rect1309");
    			attr_dev(rect0, "width", "2.1166666");
    			attr_dev(rect0, "height", "6.3499999");
    			attr_dev(rect0, "x", "7.4083333");
    			attr_dev(rect0, "y", "-11.641667");
    			attr_dev(rect0, "transform", "rotate(90)");
    			attr_dev(rect0, "class", "svelte-1a62sme");
    			add_location(rect0, file$2, 43, 4, 1078);
    			set_style(rect1, "stroke", "none");
    			set_style(rect1, "stroke-width", "1.04601");
    			set_style(rect1, "stroke-linecap", "round");
    			set_style(rect1, "stroke-linejoin", "round");
    			attr_dev(rect1, "id", "rect1309-7");
    			attr_dev(rect1, "width", "2.1166666");
    			attr_dev(rect1, "height", "6.3499999");
    			attr_dev(rect1, "x", "12.7");
    			attr_dev(rect1, "y", "-9.5249996");
    			attr_dev(rect1, "transform", "rotate(90)");
    			attr_dev(rect1, "class", "svelte-1a62sme");
    			add_location(rect1, file$2, 52, 4, 1324);
    			set_style(rect2, "stroke", "none");
    			set_style(rect2, "stroke-width", "1.04601");
    			set_style(rect2, "stroke-linecap", "round");
    			set_style(rect2, "stroke-linejoin", "round");
    			attr_dev(rect2, "id", "rect1309-7-0");
    			attr_dev(rect2, "width", "2.1166666");
    			attr_dev(rect2, "height", "6.3499999");
    			attr_dev(rect2, "x", "2.1166666");
    			attr_dev(rect2, "y", "-9.5249996");
    			attr_dev(rect2, "transform", "rotate(90)");
    			attr_dev(rect2, "class", "svelte-1a62sme");
    			add_location(rect2, file$2, 61, 4, 1567);
    			set_style(rect3, "stroke", "none");
    			set_style(rect3, "stroke-width", "1.35039");
    			set_style(rect3, "stroke-linecap", "round");
    			set_style(rect3, "stroke-linejoin", "round");
    			attr_dev(rect3, "id", "rect1309-2");
    			attr_dev(rect3, "width", "2.1166666");
    			attr_dev(rect3, "height", "10.583333");
    			attr_dev(rect3, "x", "-9.5249996");
    			attr_dev(rect3, "y", "-13.758333");
    			attr_dev(rect3, "transform", "scale(-1)");
    			attr_dev(rect3, "class", "svelte-1a62sme");
    			add_location(rect3, file$2, 70, 4, 1817);
    			attr_dev(g, "id", "layer1");
    			add_location(g, file$2, 10, 2, 200);
    			attr_dev(svg, "width", "64");
    			attr_dev(svg, "height", "64");
    			attr_dev(svg, "viewBox", "0 0 16.933333 16.933333");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "id", "svg5");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:svg", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "class", "svelte-1a62sme");
    			add_location(svg, file$2, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, defs);
    			append_dev(svg, g);
    			append_dev(g, circle0);
    			append_dev(g, circle1);
    			append_dev(g, circle2);
    			append_dev(g, circle3);
    			append_dev(g, rect0);
    			append_dev(g, rect1);
    			append_dev(g, rect2);
    			append_dev(g, rect3);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FlowIcon', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FlowIcon> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class FlowIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FlowIcon",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/sidebar/Sidebar.svelte generated by Svelte v3.44.2 */
    const file$1 = "src/sidebar/Sidebar.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (22:2) <ButtonControl     variant="transparent"     handleClick={(e) => {       loadFlow(createEmptyFlow());     }}   >
    function create_default_slot_1(ctx) {
    	let span;
    	let flowicon;
    	let t;
    	let current;
    	flowicon = new FlowIcon({ $$inline: true });

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(flowicon.$$.fragment);
    			t = text("New Flow");
    			attr_dev(span, "class", "svelte-bzysnc");
    			add_location(span, file$1, 27, 4, 846);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(flowicon, span, null);
    			append_dev(span, t);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(flowicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(flowicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(flowicon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(22:2) <ButtonControl     variant=\\\"transparent\\\"     handleClick={(e) => {       loadFlow(createEmptyFlow());     }}   >",
    		ctx
    	});

    	return block;
    }

    // (32:4) <ButtonControl       variant="transparent"       handleClick={(e) => {         loadFlow(flow);         // console.log("setting flow", flow);       }}     >
    function create_default_slot(ctx) {
    	let span;
    	let flowicon;
    	let t0_value = /*flow*/ ctx[6].name + "";
    	let t0;
    	let t1;
    	let current;
    	flowicon = new FlowIcon({ $$inline: true });

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(flowicon.$$.fragment);
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(span, "class", "svelte-bzysnc");
    			add_location(span, file$1, 38, 6, 1115);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(flowicon, span, null);
    			append_dev(span, t0);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*flows*/ 1) && t0_value !== (t0_value = /*flow*/ ctx[6].name + "")) set_data_dev(t0, t0_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(flowicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(flowicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(flowicon);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(32:4) <ButtonControl       variant=\\\"transparent\\\"       handleClick={(e) => {         loadFlow(flow);         // console.log(\\\"setting flow\\\", flow);       }}     >",
    		ctx
    	});

    	return block;
    }

    // (31:2) {#each flows as flow}
    function create_each_block(ctx) {
    	let buttoncontrol;
    	let current;

    	function func_1(...args) {
    		return /*func_1*/ ctx[3](/*flow*/ ctx[6], ...args);
    	}

    	buttoncontrol = new ButtonControl({
    			props: {
    				variant: "transparent",
    				handleClick: func_1,
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(buttoncontrol.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(buttoncontrol, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const buttoncontrol_changes = {};
    			if (dirty & /*flows*/ 1) buttoncontrol_changes.handleClick = func_1;

    			if (dirty & /*$$scope, flows*/ 513) {
    				buttoncontrol_changes.$$scope = { dirty, ctx };
    			}

    			buttoncontrol.$set(buttoncontrol_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttoncontrol.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(buttoncontrol.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(buttoncontrol, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(31:2) {#each flows as flow}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let div;
    	let buttoncontrol;
    	let t0;
    	let h3;
    	let t2;
    	let current;

    	buttoncontrol = new ButtonControl({
    			props: {
    				variant: "transparent",
    				handleClick: /*func*/ ctx[2],
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value = /*flows*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(buttoncontrol.$$.fragment);
    			t0 = space();
    			h3 = element("h3");
    			h3.textContent = "Existing Flows";
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h3, file$1, 29, 2, 901);
    			attr_dev(div, "class", "sidebar svelte-bzysnc");
    			add_location(div, file$1, 20, 0, 705);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(buttoncontrol, div, null);
    			append_dev(div, t0);
    			append_dev(div, h3);
    			append_dev(div, t2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const buttoncontrol_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				buttoncontrol_changes.$$scope = { dirty, ctx };
    			}

    			buttoncontrol.$set(buttoncontrol_changes);

    			if (dirty & /*loadFlow, flows*/ 1) {
    				each_value = /*flows*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttoncontrol.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(buttoncontrol.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(buttoncontrol);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Sidebar', slots, []);
    	let { apiUrl = "http://localhost:8321" } = $$props;
    	const tableApi = Resource(apiUrl, "flow");
    	const serviceFs = flowSyncService(tableApi);
    	let flows;

    	flowStore.subscribe(serverFlows => {
    		$$invalidate(0, flows = serverFlows);
    	});

    	onMount(() => {
    		serviceFs.updateClientFlows();
    	});

    	const writable_props = ['apiUrl'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sidebar> was created with unknown prop '${key}'`);
    	});

    	const func = e => {
    		loadFlow(createEmptyFlow());
    	};

    	const func_1 = (flow, e) => {
    		loadFlow(flow);
    	}; // console.log("setting flow", flow);

    	$$self.$$set = $$props => {
    		if ('apiUrl' in $$props) $$invalidate(1, apiUrl = $$props.apiUrl);
    	};

    	$$self.$capture_state = () => ({
    		flowSyncService,
    		Resource,
    		onMount,
    		flowStore,
    		ButtonControl,
    		loadFlow,
    		FlowIcon,
    		createEmptyFlow,
    		apiUrl,
    		tableApi,
    		serviceFs,
    		flows
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiUrl' in $$props) $$invalidate(1, apiUrl = $$props.apiUrl);
    		if ('flows' in $$props) $$invalidate(0, flows = $$props.flows);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [flows, apiUrl, func, func_1];
    }

    class Sidebar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { apiUrl: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Sidebar",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get apiUrl() {
    		throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set apiUrl(value) {
    		throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/App.svelte generated by Svelte v3.44.2 */
    const file = "src/App.svelte";

    // (29:4) {#key refreshKey}
    function create_key_block(ctx) {
    	let canvas;
    	let updating_currentFlow;
    	let current;

    	function canvas_currentFlow_binding(value) {
    		/*canvas_currentFlow_binding*/ ctx[2](value);
    	}

    	let canvas_props = {};

    	if (/*$currentFlowStore*/ ctx[0] !== void 0) {
    		canvas_props.currentFlow = /*$currentFlowStore*/ ctx[0];
    	}

    	canvas = new Canvas({ props: canvas_props, $$inline: true });
    	binding_callbacks.push(() => bind(canvas, 'currentFlow', canvas_currentFlow_binding));

    	const block = {
    		c: function create() {
    			create_component(canvas.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(canvas, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const canvas_changes = {};

    			if (!updating_currentFlow && dirty & /*$currentFlowStore*/ 1) {
    				updating_currentFlow = true;
    				canvas_changes.currentFlow = /*$currentFlowStore*/ ctx[0];
    				add_flush_callback(() => updating_currentFlow = false);
    			}

    			canvas.$set(canvas_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(canvas.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(canvas.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(canvas, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block.name,
    		type: "key",
    		source: "(29:4) {#key refreshKey}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let theme;
    	let t0;
    	let main;
    	let appbar;
    	let t1;
    	let div;
    	let sidebar;
    	let t2;
    	let previous_key = /*refreshKey*/ ctx[1];
    	let current;
    	theme = new Theme({ $$inline: true });
    	appbar = new Appbar({ $$inline: true });
    	sidebar = new Sidebar({ $$inline: true });
    	let key_block = create_key_block(ctx);

    	const block = {
    		c: function create() {
    			create_component(theme.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(appbar.$$.fragment);
    			t1 = space();
    			div = element("div");
    			create_component(sidebar.$$.fragment);
    			t2 = space();
    			key_block.c();
    			attr_dev(div, "class", "appContent svelte-1htyceg");
    			add_location(div, file, 26, 2, 799);
    			attr_dev(main, "class", "svelte-1htyceg");
    			add_location(main, file, 24, 0, 777);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(theme, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(appbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			mount_component(sidebar, div, null);
    			append_dev(div, t2);
    			key_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*refreshKey*/ 2 && safe_not_equal(previous_key, previous_key = /*refreshKey*/ ctx[1])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(div, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(theme.$$.fragment, local);
    			transition_in(appbar.$$.fragment, local);
    			transition_in(sidebar.$$.fragment, local);
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(theme.$$.fragment, local);
    			transition_out(appbar.$$.fragment, local);
    			transition_out(sidebar.$$.fragment, local);
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(theme, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(appbar);
    			destroy_component(sidebar);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $currentFlowStore;
    	validate_store(currentFlowStore, 'currentFlowStore');
    	component_subscribe($$self, currentFlowStore, $$value => $$invalidate(0, $currentFlowStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let refreshKey;

    	refreshStore.subscribe(value => {
    		$$invalidate(1, refreshKey = value);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	function canvas_currentFlow_binding(value) {
    		$currentFlowStore = value;
    		currentFlowStore.set($currentFlowStore);
    	}

    	$$self.$capture_state = () => ({
    		Appbar,
    		Canvas,
    		Theme,
    		Sidebar,
    		refreshStore,
    		currentFlowStore,
    		flowStore,
    		refreshKey,
    		$currentFlowStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('refreshKey' in $$props) $$invalidate(1, refreshKey = $$props.refreshKey);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$currentFlowStore*/ 1) {
    			{
    				if ($currentFlowStore) {
    					flowStore.update(flows => {
    						if (flows.find(f => $currentFlowStore.id === f.id) !== undefined) {
    							const flowsNoCurrent = flows.filter(f => $currentFlowStore.id !== f.id);
    							return [...flowsNoCurrent, $currentFlowStore];
    						}

    						return flows;
    					});
    				}
    			}
    		}
    	};

    	return [$currentFlowStore, refreshKey, canvas_currentFlow_binding];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
        target: document.body,
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
